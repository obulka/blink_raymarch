#! /usr/local/Nuke13.0v2/libnuke-13.0.2.so -nx
version 13.0 v2
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="1976" y="188" w="2504" h="1376" maximized="1" screen="0">
        <splitter orientation="1">
            <split size="40"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="1841" stretch="1"/>
            <splitter orientation="2">
                <split size="785"/>
                <dock id="" activePageId="Viewer.1">
                    <page id="Viewer.1"/>
                </dock>
                <split size="548"/>
                <dock id="" activePageId="DAG.1" focus="true">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                    <page id="DAG.2"/>
                    <page id="DAG.3"/>
                </dock>
            </splitter>
            <split size="615"/>
            <dock id="" activePageId="Properties.1">
                <page id="Properties.1"/>
                <page id="uk.co.thefoundry.backgroundrenderview.1"/>
            </dock>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name /home/ob1/software/nuke/dev/raymarch/nuke_scripts/raymarch_test.nk
 frame 42
 last_frame 200
 format "1920 1080 0 0 1920 1080 1 HD_1080"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement Nuke
 workingSpaceLUT linear
 monitorLut sRGB
 monitorOutLUT rec709
 int8Lut sRGB
 int16Lut sRGB
 logLut Cineon
 floatLut linear
}
Read {
 inputs 0
 file_type exr
 file /home/ob1/software/nuke/dev/raymarch/images/ninomaru_teien_4k.exr
 format "4096 2048 0 0 4096 2048 1 4K_LatLong"
 origset true
 name Read14
 xpos 17971
 ypos 849
}
Reformat {
 type scale
 scale 0.25
 name Reformat1
 xpos 17971
 ypos 967
}
Dot {
 name Dot19
 xpos 18005
 ypos 1066
}
Axis2 {
 inputs 0
 rotate {-10 0 0}
 name Axis2
 xpos 17878
 ypos 843
}
Camera2 {
 translate {0 0 2}
 focal 12.8
 haperture 18
 name Camera2
 xpos 17878
 ypos 942
}
Dot {
 name Dot18
 xpos 17902
 ypos 1063
}
Group {
 inputs 0
 name sdf_light
 xpos 18233
 ypos 912
 addUserKnob {20 User}
 addUserKnob {4 type l Type M {None Directional Point Dome ""}}
 type Directional
 addUserKnob {13 dir_pos l Direction/Position}
 dir_pos {-0.5 1 -1}
 addUserKnob {7 intensity l Intensity}
 intensity 1
 addUserKnob {18 colour l Colour}
 colour {1 1 1}
 addUserKnob {6 colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
}
add_layer {sdf_light sdf_light.light_pos_dir_x sdf_light.light_pos_dir_y sdf_light.light_pos_dir_z sdf_light.intensity}
 Constant {
  inputs 0
  channels sdf_light
  color {{parent.dir_pos.x} {parent.dir_pos.y} {parent.dir_pos.z} {parent.intensity}}
  format "1 1 0 0 1 1 1 1x1"
  name light
  xpos 434
  ypos 12
 }
 Dot {
  name Dot9
  xpos 468
  ypos 279
 }
add_layer {sdf_light_properties sdf_light_properties.colour_r sdf_light_properties.colour_g sdf_light_properties.colour_b sdf_light_properties.type}
 Constant {
  inputs 0
  channels sdf_light_properties
  color {{parent.colour.r} {parent.colour.g} {parent.colour.b} {"parent.type - 1"}}
  format "1 1 0 0 1 1 1 1x1"
  name light_props
  xpos 561
  ypos 12
 }
 Dot {
  name Dot6
  xpos 591
  ypos 282
 }
 Copy {
  inputs 2
  channels all
  name Copy1
  xpos 501
  ypos 380
 }
 Output {
  name Output1
  xpos 501
  ypos 516
 }
end_group
Dot {
 name Dot1
 xpos 18267
 ypos 1112
}
Group {
 inputs 0
 name sdf_primitive2
 xpos 18444
 ypos 874
 addUserKnob {20 User}
 addUserKnob {4 shape l Shape M {sphere ellipsoid "cut sphere" "hollow sphere" "death star" "solid angle" "rectangular prism" "rectangular prism frame" rhombus "triangular prism" cylinder "infinite cylinder" plane capsule cone "infinite cone" "capped cone" "rounded cone" torus "capped torus" "hexagonal prism" octahedron link mandelbulb}}
 addUserKnob {19 dimensions l Dimensions t "The dimensions of the object, the values change meaning depending on the shape, and for some, not all values are used.\n\nSphere:\n    r = radius\n\nEllipsoid:\n    r = The radius along the x-axis of the ellipsoid.\n    g = The radius along the y-axis of the ellipsoid.\n    b = The radius along the z-axis of the ellipsoid.\n\n"}
 dimensions {0.3 0.2 2.356194 0.01}
 addUserKnob {6 dimensions_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {18 colour l Colour}
 colour {1 0.25 0.5}
 addUserKnob {6 colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 surface l Surface t "r = reflectivity\ng = transmissivity (TODO)\nb = emissivity (TODO)\na = roughness (TODO)"}
 surface {0 0 0 0}
 addUserKnob {6 surface_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 wall_thickness l "Wall Thickness"}
 wall_thickness 0.01
 addUserKnob {6 hollow l Hollow t "If true, the object will be hollow, with a thickness of 'Wall Thickness'" -STARTLINE}
 addUserKnob {13 elongation l Elongation}
 elongation {0.3 0 0}
 addUserKnob {6 elongate l Elongate -STARTLINE}
 addUserKnob {7 edge_radius l "Edge Radius"}
 addUserKnob {6 mirror_x l "Mirror X" +STARTLINE}
 addUserKnob {6 mirror_y l "Mirror Y" -STARTLINE}
 addUserKnob {6 mirror_z l "Mirror Z" -STARTLINE}
 addUserKnob {26 div0 l "" +STARTLINE}
 addUserKnob {13 position l Position}
 position {0 0 0.25}
 addUserKnob {13 rotation l Rotation}
 addUserKnob {7 uniform_scale l "Uniform Scale" R 0 10}
 uniform_scale 1
 addUserKnob {26 div1 l "" +STARTLINE}
 addUserKnob {19 repetition_params l Repetition}
 repetition_params {5 5 1 1.5}
 addUserKnob {6 repetition_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {4 repetition_type l Type -STARTLINE M {None Finite Infinite "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {7 blend_strength l "Blend Strength"}
 addUserKnob {4 blend_type l "Blend Type" -STARTLINE M {Union Subtraction Intersection "Smooth Union" "Smooth Subtraction" "Smooth Intersection" ""}}
}
 Input {
  inputs 0
  name children
  xpos 1357
  ypos 418
 }
 Dot {
  name Dot1
  xpos 1391
  ypos 826
 }
add_layer {sdf_position_scale sdf_position_scale.position_x sdf_position_scale.position_y sdf_position_scale.position_z sdf_position_scale.uniform_scale}
 Constant {
  inputs 0
  channels sdf_position_scale
  color {{parent.position.x} {parent.position.y} {parent.position.z} {parent.uniform_scale}}
  format "1 1 0 0 1 1 1 1x1"
  name position_scale
  xpos 280
  ypos 455
 }
 Dot {
  name Dot17
  xpos 314
  ypos 647
 }
add_layer {sdf_rotation_wall_thickness sdf_rotation_wall_thickness.rotation_x sdf_rotation_wall_thickness.rotation_y sdf_rotation_wall_thickness.rotation_z sdf_rotation_wall_thickness.wall_thickness}
 Constant {
  inputs 0
  channels sdf_rotation_wall_thickness
  color {{"parent.rotation.x * pi / 180.0"} {"parent.rotation.y * pi / 180.0"} {"parent.rotation.z * pi / 180.0"} {parent.wall_thickness}}
  format "1 1 0 0 1 1 1 1x1"
  name rotation
  xpos 403
  ypos 457
 }
 Copy {
  inputs 2
  channels all
  name Copy1
  xpos 403
  ypos 726
 }
add_layer {sdf_dimensions sdf_dimensions.dimension_x sdf_dimensions.dimension_y sdf_dimensions.dimension_z sdf_dimensions.dimension_w}
 Constant {
  inputs 0
  channels sdf_dimensions
  color {{parent.dimensions.r} {parent.dimensions.g} {parent.dimensions.b} {parent.dimensions.a}}
  format "1 1 0 0 1 1 1 1x1"
  name dimensions
  xpos 540
  ypos 460
 }
 Copy {
  inputs 2
  channels all
  name Copy2
  xpos 540
  ypos 726
 }
add_layer {sdf_colour sdf_colour.colour_r sdf_colour.colour_g sdf_colour.colour_b sdf_colour.colour_a}
 Constant {
  inputs 0
  channels sdf_colour
  color {{parent.colour.r} {parent.colour.g} {parent.colour.b} 0}
  format "1 1 0 0 1 1 1 1x1"
  name colour
  xpos 669
  ypos 459
 }
 Copy {
  inputs 2
  channels all
  name Copy3
  xpos 669
  ypos 726
 }
add_layer {sdf_shape sdf_shape.shape_type sdf_shape.shape_operations sdf_shape.num_children sdf_shape.blend_strength}
 Constant {
  inputs 0
  channels sdf_shape
  color {{parent.shape} {"parent.repetition_type | (parent.elongate ? 4 : 0) | (parent.mirror_x ? 8 : 0) | (parent.mirror_y ? 16 : 0) | (parent.mirror_z ? 32 : 0) | (parent.hollow ? 64 : 0) | (parent.blend_type > 0 ? (1 << (parent.blend_type + 6)) : 0)"} {"parent.sdf_merge.disable ? 0 : parent.sdf_merge.input1.width"} {parent.blend_strength}}
  format "1 1 0 0 1 1 1 1x1"
  name shape
  xpos 806
  ypos 462
 }
 Copy {
  inputs 2
  channels all
  name Copy4
  xpos 806
  ypos 726
 }
add_layer {sdf_surface sdf_surface.reflection sdf_surface.transmission sdf_surface.emission sdf_surface.roughness}
 Constant {
  inputs 0
  channels sdf_surface
  color {{parent.surface.r} {parent.surface.g} {parent.surface.b} {parent.surface.a}}
  format "1 1 0 0 1 1 1 1x1"
  name surface
  xpos 935
  ypos 460
 }
 Copy {
  inputs 2
  channels all
  name Copy5
  xpos 936
  ypos 726
 }
add_layer {sdf_shape_mods_0 sdf_shape_mods_0.repetion_x sdf_shape_mods_0.repetion_y sdf_shape_mods_0.repetion_z sdf_shape_mods_0.repetion_w}
 Constant {
  inputs 0
  channels sdf_shape_mods_0
  color {{parent.repetition_params.r} {parent.repetition_params.g} {parent.repetition_params.b} {parent.repetition_params.a}}
  format "1 1 0 0 1 1 1 1x1"
  name shape_mods
  xpos 1056
  ypos 463
 }
 Copy {
  inputs 2
  channels all
  name Copy6
  xpos 1056
  ypos 726
 }
add_layer {sdf_shape_mods_1 sdf_shape_mods_1.elongation_x sdf_shape_mods_1.elongation_y sdf_shape_mods_1.elongation_z sdf_shape_mods_1.edge_radius}
 Constant {
  inputs 0
  channels sdf_shape_mods_1
  color {{parent.elongation.x} {parent.elongation.y} {parent.elongation.z} {parent.edge_radius}}
  format "1 1 0 0 1 1 1 1x1"
  name shape_mods1
  xpos 1183
  ypos 465
 }
 Copy {
  inputs 2
  channels all
  name Copy7
  xpos 1183
  ypos 726
 }
 Group {
  inputs 2
  name sdf_merge
  xpos 1183
  ypos 822
  disable {{"\[exists parent.input0] ? 0 : 1"}}
  addUserKnob {20 User}
  addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
 }
  Reformat {
   inputs 0
   type "to box"
   box_width 1
   box_height 1
   box_fixed true
   name Reformat1
   xpos -119
   ypos 440
  }
  Input {
   inputs 0
   name Input2
   xpos 158
   ypos -28
   number 1
  }
  Dot {
   name Dot2
   xpos 192
   ypos -2
  }
set Nc0986400 [stack 0]
  Dot {
   name Dot3
   xpos 329
   ypos -2
  }
  Dot {
   name Dot4
   xpos 329
   ypos 391
  }
  Input {
   inputs 0
   name Input1
   xpos 0
   ypos -32
  }
  Dot {
   name Dot1
   xpos 34
   ypos -6
  }
set Nc0984800 [stack 0]
  Dot {
   name Dot6
   xpos -98
   ypos -6
  }
  Dot {
   name Dot5
   xpos -98
   ypos 336
  }
push $Nc0986400
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop3
   xpos 158
   ypos 69
  }
  Crop {
   box {0 0 {parent.Dot2.width} 1}
   name Crop4
   xpos 158
   ypos 95
  }
  Transform {
   translate {{parent.Dot1.width} 0}
   center {1 0.5}
   name Transform2
   xpos 158
   ypos 121
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop5
   xpos 158
   ypos 167
  }
push $Nc0984800
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop6
   xpos 0
   ypos 66
  }
  Crop {
   box {0 0 {parent.Dot1.width} 1}
   name Crop7
   xpos 0
   ypos 92
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop8
   xpos 0
   ypos 164
  }
  Merge2 {
   inputs 2
   also_merge all
   name Merge1
   xpos 0
   ypos 262
   disable {{"\[exists parent.input1] ? 0:1"}}
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input1] ? 0:1"}}
   name Switch2
   xpos 0
   ypos 332
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:1"}}
   name Switch1
   xpos 0
   ypos 387
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
   name Switch3
   xpos 0
   ypos 456
  }
  Dot {
   name out_dot
   xpos 36
   ypos 518
  }
  Output {
   name Output1
   xpos 2
   ypos 661
  }
 end_group
 Output {
  name Output1
  xpos 1183
  ypos 1002
 }
end_group
Group {
 name sdf_primitive1
 xpos 18444
 ypos 927
 addUserKnob {20 User}
 addUserKnob {4 shape l Shape M {sphere ellipsoid "cut sphere" "hollow sphere" "death star" "solid angle" "rectangular prism" "rectangular prism frame" rhombus "triangular prism" cylinder "infinite cylinder" plane capsule cone "infinite cone" "capped cone" "rounded cone" torus "capped torus" "hexagonal prism" octahedron link mandelbulb}}
 addUserKnob {19 dimensions l Dimensions t "The dimensions of the object, the values change meaning depending on the shape, and for some, not all values are used.\n\nSphere:\n    r = radius\n\nEllipsoid:\n    r = The radius along the x-axis of the ellipsoid.\n    g = The radius along the y-axis of the ellipsoid.\n    b = The radius along the z-axis of the ellipsoid.\n\n"}
 dimensions {0.3 0.2 2.356194 0.01}
 addUserKnob {6 dimensions_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {18 colour l Colour}
 colour {1 0.25 0.5}
 addUserKnob {6 colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 surface l Surface t "r = reflectivity\ng = transmissivity (TODO)\nb = emissivity (TODO)\na = roughness (TODO)"}
 surface {0 0 0 0}
 addUserKnob {6 surface_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 wall_thickness l "Wall Thickness"}
 wall_thickness 0.01
 addUserKnob {6 hollow l Hollow t "If true, the object will be hollow, with a thickness of 'Wall Thickness'" -STARTLINE}
 addUserKnob {13 elongation l Elongation}
 elongation {0.3 0 0}
 addUserKnob {6 elongate l Elongate -STARTLINE}
 addUserKnob {7 edge_radius l "Edge Radius"}
 addUserKnob {6 mirror_x l "Mirror X" +STARTLINE}
 addUserKnob {6 mirror_y l "Mirror Y" -STARTLINE}
 addUserKnob {6 mirror_z l "Mirror Z" -STARTLINE}
 addUserKnob {26 div0 l "" +STARTLINE}
 addUserKnob {13 position l Position}
 position {-0.25 0 0}
 addUserKnob {13 rotation l Rotation}
 rotation {0 50 0}
 addUserKnob {7 uniform_scale l "Uniform Scale" R 0 10}
 uniform_scale 1
 addUserKnob {26 div1 l "" +STARTLINE}
 addUserKnob {19 repetition_params l Repetition}
 repetition_params {5 5 1 1.5}
 addUserKnob {6 repetition_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {4 repetition_type l Type -STARTLINE M {None Finite Infinite "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {7 blend_strength l "Blend Strength"}
 addUserKnob {4 blend_type l "Blend Type" -STARTLINE M {Union Subtraction Intersection "Smooth Union" "Smooth Subtraction" "Smooth Intersection" ""}}
}
 Input {
  inputs 0
  name children
  xpos 1357
  ypos 418
 }
 Dot {
  name Dot1
  xpos 1391
  ypos 826
 }
 Constant {
  inputs 0
  channels sdf_position_scale
  color {{parent.position.x} {parent.position.y} {parent.position.z} {parent.uniform_scale}}
  format "1 1 0 0 1 1 1 1x1"
  name position_scale
  xpos 280
  ypos 455
 }
 Dot {
  name Dot17
  xpos 314
  ypos 647
 }
 Constant {
  inputs 0
  channels sdf_rotation_wall_thickness
  color {{"parent.rotation.x * pi / 180.0"} {"parent.rotation.y * pi / 180.0"} {"parent.rotation.z * pi / 180.0"} {parent.wall_thickness}}
  format "1 1 0 0 1 1 1 1x1"
  name rotation
  xpos 403
  ypos 457
 }
 Copy {
  inputs 2
  channels all
  name Copy1
  xpos 403
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_dimensions
  color {{parent.dimensions.r} {parent.dimensions.g} {parent.dimensions.b} {parent.dimensions.a}}
  format "1 1 0 0 1 1 1 1x1"
  name dimensions
  xpos 540
  ypos 460
 }
 Copy {
  inputs 2
  channels all
  name Copy2
  xpos 540
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_colour
  color {{parent.colour.r} {parent.colour.g} {parent.colour.b} 0}
  format "1 1 0 0 1 1 1 1x1"
  name colour
  xpos 669
  ypos 459
 }
 Copy {
  inputs 2
  channels all
  name Copy3
  xpos 669
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_shape
  color {{parent.shape} {"parent.repetition_type | (parent.elongate ? 4 : 0) | (parent.mirror_x ? 8 : 0) | (parent.mirror_y ? 16 : 0) | (parent.mirror_z ? 32 : 0) | (parent.hollow ? 64 : 0) | (parent.blend_type > 0 ? (1 << (parent.blend_type + 6)) : 0)"} {"parent.sdf_merge.disable ? 0 : parent.sdf_merge.input1.width"} {parent.blend_strength}}
  format "1 1 0 0 1 1 1 1x1"
  name shape
  xpos 806
  ypos 462
 }
 Copy {
  inputs 2
  channels all
  name Copy4
  xpos 806
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_surface
  color {{parent.surface.r} {parent.surface.g} {parent.surface.b} {parent.surface.a}}
  format "1 1 0 0 1 1 1 1x1"
  name surface
  xpos 935
  ypos 460
 }
 Copy {
  inputs 2
  channels all
  name Copy5
  xpos 936
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_shape_mods_0
  color {{parent.repetition_params.r} {parent.repetition_params.g} {parent.repetition_params.b} {parent.repetition_params.a}}
  format "1 1 0 0 1 1 1 1x1"
  name shape_mods
  xpos 1056
  ypos 463
 }
 Copy {
  inputs 2
  channels all
  name Copy6
  xpos 1056
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_shape_mods_1
  color {{parent.elongation.x} {parent.elongation.y} {parent.elongation.z} {parent.edge_radius}}
  format "1 1 0 0 1 1 1 1x1"
  name shape_mods1
  xpos 1183
  ypos 465
 }
 Copy {
  inputs 2
  channels all
  name Copy7
  xpos 1183
  ypos 726
 }
 Group {
  inputs 2
  name sdf_merge
  xpos 1183
  ypos 822
  disable {{"\[exists parent.input0] ? 0 : 1"}}
  addUserKnob {20 User}
  addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
 }
  Reformat {
   inputs 0
   type "to box"
   box_width 1
   box_height 1
   box_fixed true
   name Reformat1
   xpos -119
   ypos 440
  }
  Input {
   inputs 0
   name Input2
   xpos 158
   ypos -28
   number 1
  }
  Dot {
   name Dot2
   xpos 192
   ypos -2
  }
set Ne8a23900 [stack 0]
  Dot {
   name Dot3
   xpos 329
   ypos -2
  }
  Dot {
   name Dot4
   xpos 329
   ypos 391
  }
  Input {
   inputs 0
   name Input1
   xpos 0
   ypos -32
  }
  Dot {
   name Dot1
   xpos 34
   ypos -6
  }
set Ne8a21d00 [stack 0]
  Dot {
   name Dot6
   xpos -98
   ypos -6
  }
  Dot {
   name Dot5
   xpos -98
   ypos 336
  }
push $Ne8a23900
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop3
   xpos 158
   ypos 69
  }
  Crop {
   box {0 0 {parent.Dot2.width} 1}
   name Crop4
   xpos 158
   ypos 95
  }
  Transform {
   translate {{parent.Dot1.width} 0}
   center {1 0.5}
   name Transform2
   xpos 158
   ypos 121
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop5
   xpos 158
   ypos 167
  }
push $Ne8a21d00
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop6
   xpos 0
   ypos 66
  }
  Crop {
   box {0 0 {parent.Dot1.width} 1}
   name Crop7
   xpos 0
   ypos 92
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop8
   xpos 0
   ypos 164
  }
  Merge2 {
   inputs 2
   also_merge all
   name Merge1
   xpos 0
   ypos 262
   disable {{"\[exists parent.input1] ? 0:1"}}
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input1] ? 0:1"}}
   name Switch2
   xpos 0
   ypos 332
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:1"}}
   name Switch1
   xpos 0
   ypos 387
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
   name Switch3
   xpos 0
   ypos 456
  }
  Dot {
   name out_dot
   xpos 36
   ypos 518
  }
  Output {
   name Output1
   xpos 2
   ypos 661
  }
 end_group
 Output {
  name Output1
  xpos 1183
  ypos 1002
 }
end_group
Group {
 name sdf_primitive
 xpos 18444
 ypos 1012
 addUserKnob {20 User}
 addUserKnob {4 shape l Shape M {sphere ellipsoid "cut sphere" "hollow sphere" "death star" "solid angle" "rectangular prism" "rectangular prism frame" rhombus "triangular prism" cylinder "infinite cylinder" plane capsule cone "infinite cone" "capped cone" "rounded cone" torus "capped torus" "hexagonal prism" octahedron link mandelbulb}}
 addUserKnob {19 dimensions l Dimensions t "The dimensions of the object, the values change meaning depending on the shape, and for some, not all values are used.\n\nSphere:\n    r = radius\n\nEllipsoid:\n    r = The radius along the x-axis of the ellipsoid.\n    g = The radius along the y-axis of the ellipsoid.\n    b = The radius along the z-axis of the ellipsoid.\n\n"}
 dimensions {0.3 0.2 2.356194 0.01}
 addUserKnob {6 dimensions_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {18 colour l Colour}
 colour {1 0.25 0.5}
 addUserKnob {6 colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 surface l Surface t "r = reflectivity\ng = transmissivity (TODO)\nb = emissivity (TODO)\na = roughness (TODO)"}
 surface {0 0 0 0}
 addUserKnob {6 surface_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 wall_thickness l "Wall Thickness"}
 wall_thickness 0.01
 addUserKnob {6 hollow l Hollow t "If true, the object will be hollow, with a thickness of 'Wall Thickness'" -STARTLINE}
 addUserKnob {13 elongation l Elongation}
 elongation {0.3 0 0}
 addUserKnob {6 elongate l Elongate -STARTLINE}
 addUserKnob {7 edge_radius l "Edge Radius"}
 addUserKnob {6 mirror_x l "Mirror X" +STARTLINE}
 addUserKnob {6 mirror_y l "Mirror Y" -STARTLINE}
 addUserKnob {6 mirror_z l "Mirror Z" -STARTLINE}
 addUserKnob {26 div0 l "" +STARTLINE}
 addUserKnob {13 position l Position}
 addUserKnob {13 rotation l Rotation}
 addUserKnob {7 uniform_scale l "Uniform Scale" R 0 10}
 uniform_scale 1
 addUserKnob {26 div1 l "" +STARTLINE}
 addUserKnob {19 repetition_params l Repetition}
 repetition_params {5 5 1 1.5}
 addUserKnob {6 repetition_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {4 repetition_type l Type -STARTLINE M {None Finite Infinite "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {7 blend_strength l "Blend Strength"}
 blend_strength 0.13
 addUserKnob {4 blend_type l "Blend Type" -STARTLINE M {Union Subtraction Intersection "Smooth Union" "Smooth Subtraction" "Smooth Intersection" ""}}
 blend_type Intersection
}
 Input {
  inputs 0
  name children
  xpos 1357
  ypos 418
 }
 Dot {
  name Dot1
  xpos 1391
  ypos 826
 }
 Constant {
  inputs 0
  channels sdf_position_scale
  color {{parent.position.x} {parent.position.y} {parent.position.z} {parent.uniform_scale}}
  format "1 1 0 0 1 1 1 1x1"
  name position_scale
  xpos 280
  ypos 455
 }
 Dot {
  name Dot17
  xpos 314
  ypos 647
 }
 Constant {
  inputs 0
  channels sdf_rotation_wall_thickness
  color {{"parent.rotation.x * pi / 180.0"} {"parent.rotation.y * pi / 180.0"} {"parent.rotation.z * pi / 180.0"} {parent.wall_thickness}}
  format "1 1 0 0 1 1 1 1x1"
  name rotation
  xpos 403
  ypos 457
 }
 Copy {
  inputs 2
  channels all
  name Copy1
  xpos 403
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_dimensions
  color {{parent.dimensions.r} {parent.dimensions.g} {parent.dimensions.b} {parent.dimensions.a}}
  format "1 1 0 0 1 1 1 1x1"
  name dimensions
  xpos 540
  ypos 460
 }
 Copy {
  inputs 2
  channels all
  name Copy2
  xpos 540
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_colour
  color {{parent.colour.r} {parent.colour.g} {parent.colour.b} 0}
  format "1 1 0 0 1 1 1 1x1"
  name colour
  xpos 669
  ypos 459
 }
 Copy {
  inputs 2
  channels all
  name Copy3
  xpos 669
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_shape
  color {{parent.shape} {"parent.repetition_type | (parent.elongate ? 4 : 0) | (parent.mirror_x ? 8 : 0) | (parent.mirror_y ? 16 : 0) | (parent.mirror_z ? 32 : 0) | (parent.hollow ? 64 : 0) | (parent.blend_type > 0 ? (1 << (parent.blend_type + 6)) : 0)"} {"parent.sdf_merge.disable ? 0 : parent.sdf_merge.input1.width"} {parent.blend_strength}}
  format "1 1 0 0 1 1 1 1x1"
  name shape
  xpos 806
  ypos 462
 }
 Copy {
  inputs 2
  channels all
  name Copy4
  xpos 806
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_surface
  color {{parent.surface.r} {parent.surface.g} {parent.surface.b} {parent.surface.a}}
  format "1 1 0 0 1 1 1 1x1"
  name surface
  xpos 935
  ypos 460
 }
 Copy {
  inputs 2
  channels all
  name Copy5
  xpos 936
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_shape_mods_0
  color {{parent.repetition_params.r} {parent.repetition_params.g} {parent.repetition_params.b} {parent.repetition_params.a}}
  format "1 1 0 0 1 1 1 1x1"
  name shape_mods
  xpos 1056
  ypos 463
 }
 Copy {
  inputs 2
  channels all
  name Copy6
  xpos 1056
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_shape_mods_1
  color {{parent.elongation.x} {parent.elongation.y} {parent.elongation.z} {parent.edge_radius}}
  format "1 1 0 0 1 1 1 1x1"
  name shape_mods1
  xpos 1183
  ypos 465
 }
 Copy {
  inputs 2
  channels all
  name Copy7
  xpos 1183
  ypos 726
 }
 Group {
  inputs 2
  name sdf_merge
  xpos 1183
  ypos 822
  disable {{"\[exists parent.input0] ? 0 : 1"}}
  addUserKnob {20 User}
  addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
 }
  Reformat {
   inputs 0
   type "to box"
   box_width 1
   box_height 1
   box_fixed true
   name Reformat1
   xpos -119
   ypos 440
  }
  Input {
   inputs 0
   name Input2
   xpos 158
   ypos -28
   number 1
  }
  Dot {
   name Dot2
   xpos 192
   ypos -2
  }
set N77420f00 [stack 0]
  Dot {
   name Dot3
   xpos 329
   ypos -2
  }
  Dot {
   name Dot4
   xpos 329
   ypos 391
  }
  Input {
   inputs 0
   name Input1
   xpos 0
   ypos -32
  }
  Dot {
   name Dot1
   xpos 34
   ypos -6
  }
set N77403200 [stack 0]
  Dot {
   name Dot6
   xpos -98
   ypos -6
  }
  Dot {
   name Dot5
   xpos -98
   ypos 336
  }
push $N77420f00
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop3
   xpos 158
   ypos 69
  }
  Crop {
   box {0 0 {parent.Dot2.width} 1}
   name Crop4
   xpos 158
   ypos 95
  }
  Transform {
   translate {{parent.Dot1.width} 0}
   center {1 0.5}
   name Transform2
   xpos 158
   ypos 121
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop5
   xpos 158
   ypos 167
  }
push $N77403200
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop6
   xpos 0
   ypos 66
  }
  Crop {
   box {0 0 {parent.Dot1.width} 1}
   name Crop7
   xpos 0
   ypos 92
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop8
   xpos 0
   ypos 164
  }
  Merge2 {
   inputs 2
   also_merge all
   name Merge1
   xpos 0
   ypos 262
   disable {{"\[exists parent.input1] ? 0:1"}}
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input1] ? 0:1"}}
   name Switch2
   xpos 0
   ypos 332
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:1"}}
   name Switch1
   xpos 0
   ypos 387
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
   name Switch3
   xpos 0
   ypos 456
  }
  Dot {
   name out_dot
   xpos 36
   ypos 518
  }
  Output {
   name Output1
   xpos 2
   ypos 661
  }
 end_group
 Output {
  name Output1
  xpos 1183
  ypos 1002
 }
end_group
Group {
 name sdf_merge
 xpos 18444
 ypos 1085
 addUserKnob {20 User}
 addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
}
 Reformat {
  inputs 0
  type "to box"
  box_width 1
  box_height 1
  box_fixed true
  name Reformat1
  xpos -119
  ypos 440
 }
 Input {
  inputs 0
  name Input2
  xpos 158
  ypos -28
  number 1
 }
 Dot {
  name Dot2
  xpos 192
  ypos -2
 }
set N773b2400 [stack 0]
 Dot {
  name Dot3
  xpos 329
  ypos -2
 }
 Dot {
  name Dot4
  xpos 329
  ypos 391
 }
 Input {
  inputs 0
  name Input1
  xpos 0
  ypos -32
 }
 Dot {
  name Dot1
  xpos 34
  ypos -6
 }
set N773b0800 [stack 0]
 Dot {
  name Dot6
  xpos -98
  ypos -6
 }
 Dot {
  name Dot5
  xpos -98
  ypos 336
 }
push $N773b2400
 Crop {
  box {0 0 {Dot1.width+Dot2.width} 1}
  reformat true
  crop false
  name Crop3
  xpos 158
  ypos 69
 }
 Crop {
  box {0 0 {parent.Dot2.width} 1}
  name Crop4
  xpos 158
  ypos 95
 }
 Transform {
  translate {{parent.Dot1.width} 0}
  center {1 0.5}
  name Transform2
  xpos 158
  ypos 121
 }
 Crop {
  box {0 0 {width} {height}}
  crop false
  name Crop5
  xpos 158
  ypos 167
 }
push $N773b0800
 Crop {
  box {0 0 {Dot1.width+Dot2.width} 1}
  reformat true
  crop false
  name Crop6
  xpos 0
  ypos 66
 }
 Crop {
  box {0 0 {parent.Dot1.width} 1}
  name Crop7
  xpos 0
  ypos 92
 }
 Crop {
  box {0 0 {width} {height}}
  crop false
  name Crop8
  xpos 0
  ypos 164
 }
 Merge2 {
  inputs 2
  also_merge all
  name Merge1
  xpos 0
  ypos 262
  disable {{"\[exists parent.input1] ? 0:1"}}
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input1] ? 0:1"}}
  name Switch2
  xpos 0
  ypos 332
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input0] ? 0:1"}}
  name Switch1
  xpos 0
  ypos 387
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
  name Switch3
  xpos 0
  ypos 456
 }
 Dot {
  name out_dot
  xpos 36
  ypos 518
 }
 Output {
  name Output1
  xpos 2
  ypos 661
 }
end_group
Group {
 inputs 4
 name ray_marcher
 xpos 18317
 ypos 1212
 addUserKnob {20 User}
 addUserKnob {3 pixel_subdivisions l "Pixel Subdivisions" t "Subdivide the pixel and cast a ray for each subdivision, resulting in 2^subdivisions rays"}
 addUserKnob {3 max_bounces l "Max Bounces" t "Rays will reflect this many times before they are stopped"}
 max_bounces 5
 addUserKnob {7 ray_distance l "Max Ray Distance" R 10 10000}
 ray_distance 10
 addUserKnob {3 max_ray_steps l "Max Ray Steps"}
 max_ray_steps 128
 addUserKnob {7 hit_tolerance l "Hit Tolerance" t "The ray will be considered to have hit an object when it is within this distance of its surface" R 1e-06 0.01}
 hit_tolerance 0.001
 addUserKnob {7 shadow_bias l "Shadow Bias" t "The surface will be offset by an additional factor of this amount before determining if it is in shadow" R 1 2}
 shadow_bias 1
 addUserKnob {26 ""}
 addUserKnob {7 haze l "Haze Amount"}
 addUserKnob {7 haze_start l "Haze Start"}
 addUserKnob {7 haze_distance l "Haze Distance"}
 haze_distance 5
 addUserKnob {19 haze_colour l "Haze Colour"}
 haze_colour {1 1 1 0}
 addUserKnob {6 haze_colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 ""}
 addUserKnob {7 iter_glow l "Iter Glow" t "The more steps it takes to compute a pixel the more it will glow"}
 addUserKnob {19 iter_glow_colour l "Iter Glow Colour"}
 iter_glow_colour {0.839216 0.776471 0.286275 0}
 addUserKnob {6 iter_glow_colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 ""}
 addUserKnob {7 skybox_offset_angle l "Sky Box Offset Angle" R 0 360}
}
 BackdropNode {
  inputs 0
  name Lights
  xpos -306
  ypos -1633
  bdwidth 386
  bdheight 854
 }
 BackdropNode {
  inputs 0
  name Objects
  xpos 99
  ypos -1632
  bdwidth 1184
  bdheight 855
 }
 Constant {
  inputs 0
  channels sdf_light
  format "1 1 0 0 1 1 1 1x1"
  name Constant4
  xpos -278
  ypos -1547
 }
 Input {
  inputs 0
  name lights
  xpos -82
  ypos -1575
  number 1
 }
 Merge2 {
  inputs 2
  name Merge3
  xpos -82
  ypos -1518
 }
 Dot {
  name light_dot
  xpos -48
  ypos -1309
 }
set N77339600 [stack 0]
 Shuffle2 {
  fromInput1 {{0} B}
  in1 sdf_light_properties
  fromInput2 {{0} B}
  mappings "4 sdf_light_properties.colour_r 0 0 rgba.red 0 0 sdf_light_properties.colour_g 0 1 rgba.green 0 1 sdf_light_properties.colour_b 0 2 rgba.blue 0 2 sdf_light_properties.type 0 3 rgba.alpha 0 3"
  name light_props
  xpos -147
  ypos -1040
 }
 Dot {
  name Dot8
  xpos -113
  ypos -878
 }
push $N77339600
 Shuffle2 {
  fromInput1 {{0} B}
  in1 sdf_light
  fromInput2 {{0} B}
  mappings "4 sdf_light.light_pos_dir_x 0 0 rgba.red 0 0 sdf_light.light_pos_dir_y 0 1 rgba.green 0 1 sdf_light.light_pos_dir_z 0 2 rgba.blue 0 2 sdf_light.intensity 0 3 rgba.alpha 0 3"
  name light
  xpos -31
  ypos -1042
 }
 Dot {
  name Dot7
  xpos 3
  ypos -862
 }
 Constant {
  inputs 0
  channels sdf_position_scale
  format "1 1 0 0 1 1 1 1x1"
  name Constant2
  xpos 411
  ypos -1545
 }
 Input {
  inputs 0
  name objects
  xpos 607
  ypos -1567
 }
 Merge2 {
  inputs 2
  name Merge2
  xpos 607
  ypos -1516
 }
 Dot {
  name obj_dot
  xpos 641
  ypos -1318
 }
set N77319600 [stack 0]
 Shuffle2 {
  fromInput1 {{0} B}
  in1 sdf_surface
  fromInput2 {{0} B}
  mappings "4 sdf_surface.reflection 0 0 rgba.red 0 0 sdf_surface.transmission 0 1 rgba.green 0 1 sdf_surface.emission 0 2 rgba.blue 0 2 sdf_surface.roughness 0 3 rgba.alpha 0 3"
  name surface
  xpos 288
  ypos -1036
 }
 Dot {
  name Dot2
  xpos 322
  ypos -863
 }
push $N77319600
 Shuffle2 {
  fromInput1 {{0} B}
  in1 sdf_shape_mods_1
  fromInput2 {{0} B}
  mappings "4 sdf_shape_mods_1.elongation_x 0 0 rgba.red 0 0 sdf_shape_mods_1.elongation_y 0 1 rgba.green 0 1 sdf_shape_mods_1.elongation_z 0 2 rgba.blue 0 2 sdf_shape_mods_1.edge_radius 0 3 rgba.alpha 0 3"
  name shape_mods_1
  xpos 746
  ypos -1026
 }
 Dot {
  name Dot12
  xpos 780
  ypos -865
 }
push $N77319600
 Shuffle2 {
  fromInput1 {{0} B}
  in1 sdf_shape_mods_0
  fromInput2 {{0} B}
  mappings "4 sdf_shape_mods_0.repetion_x 0 0 rgba.red 0 0 sdf_shape_mods_0.repetion_y 0 1 rgba.green 0 1 sdf_shape_mods_0.repetion_z 0 2 rgba.blue 0 2 sdf_shape_mods_0.repetion_w 0 3 rgba.alpha 0 3"
  name shape_mods_0
  xpos 607
  ypos -1028
 }
 Dot {
  name Dot3
  xpos 641
  ypos -864
 }
push $N77319600
 Shuffle2 {
  fromInput1 {{0} B}
  in1 sdf_shape
  fromInput2 {{0} B}
  mappings "4 sdf_shape.shape_type 0 0 rgba.red 0 0 sdf_shape.shape_operations 0 1 rgba.green 0 1 sdf_shape.num_children 0 2 rgba.blue 0 2 sdf_shape.blend_strength 0 3 rgba.alpha 0 3"
  name shape
  xpos 439
  ypos -1032
 }
 Dot {
  name Dot4
  xpos 473
  ypos -863
 }
push $N77319600
 Shuffle2 {
  fromInput1 {{0} B}
  in1 sdf_colour
  fromInput2 {{0} B}
  mappings "4 sdf_colour.colour_r 0 0 rgba.red 0 0 sdf_colour.colour_g 0 1 rgba.green 0 1 sdf_colour.colour_b 0 2 rgba.blue 0 2 sdf_colour.colour_a 0 3 rgba.alpha 0 3"
  name colour
  xpos 131
  ypos -1041
 }
 Dot {
  name Dot5
  xpos 165
  ypos -864
 }
push $N77319600
 Shuffle2 {
  fromInput1 {{0} B}
  in1 sdf_dimensions
  fromInput2 {{0} B}
  mappings "4 sdf_dimensions.dimension_x 0 0 rgba.red 0 0 sdf_dimensions.dimension_y 0 1 rgba.green 0 1 sdf_dimensions.dimension_z 0 2 rgba.blue 0 2 sdf_dimensions.dimension_w 0 3 rgba.alpha 0 3"
  name dimensions
  xpos 1193
  ypos -1021
 }
 Dot {
  name Dot10
  xpos 1227
  ypos -857
 }
push $N77319600
 Shuffle2 {
  fromInput1 {{0} B}
  in1 sdf_rotation_wall_thickness
  fromInput2 {{0} B}
  mappings "4 sdf_rotation_wall_thickness.rotation_x 0 0 rgba.red 0 0 sdf_rotation_wall_thickness.rotation_y 0 1 rgba.green 0 1 sdf_rotation_wall_thickness.rotation_z 0 2 rgba.blue 0 2 sdf_rotation_wall_thickness.wall_thickness 0 3 rgba.alpha 0 3"
  name rotation_wall_thickness
  xpos 1042
  ypos -1023
 }
 Dot {
  name Dot9
  xpos 1076
  ypos -854
 }
push $N77319600
 Shuffle2 {
  fromInput1 {{0} B}
  in1 sdf_position_scale
  fromInput2 {{0} B}
  mappings "4 sdf_position_scale.position_x 0 0 rgba.red 0 0 sdf_position_scale.position_y 0 1 rgba.green 0 1 sdf_position_scale.position_z 0 2 rgba.blue 0 2 sdf_position_scale.uniform_scale 0 3 rgba.alpha 0 3"
  name position_scale
  xpos 900
  ypos -1022
 }
 Dot {
  name Dot6
  xpos 934
  ypos -859
 }
 Constant {
  inputs 0
  format "2 1 0 0 2 1 1 lights"
  name Constant3
  xpos 1551
  ypos -1546
 }
 Input {
  inputs 0
  name sky
  xpos 1661
  ypos -1577
  number 3
 }
 Merge2 {
  inputs 2
  name Merge1
  xpos 1661
  ypos -1523
 }
 Dot {
  name sky_dot
  xpos 1695
  ypos -1474
 }
 Constant {
  inputs 0
  name Constant1
  xpos 1835
  ypos -605
 }
 Dot {
  name resolution_dot
  xpos 1869
  ypos -451
 }
 BlinkScript {
  inputs 12
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/raymarch.blink
  recompileCount 1076
  ProgramGroup 1
  KernelDescription "2 \"RayMarchKernel\" iterate pixelWise 0938e1dd73b786fcf049a2afbbf87a6424b94e0c8006c90b6cf680652b8c255f 13 \"bg\" Read Point \"skyBox\" Read Random \"positions\" Read Random \"rotations\" Read Random \"dimensions\" Read Random \"colours\" Read Random \"shapeProperties\" Read Random \"shapeModParameters0\" Read Random \"shapeModParameters1\" Read Random \"surfaceProperties\" Read Random \"lights\" Read Random \"lightProperties\" Read Random \"dst\" Write Point 26 \"Focal Length\" Float 1 AABIQg== \"Horizontal Aperture\" Float 1 ppvEQQ== \"Near Plane\" Float 1 zczMPQ== \"Far Plane\" Float 1 AEAcRg== \"Camera World Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"Screen Width\" Float 1 AABwRQ== \"Screen Height\" Float 1 AAAHRQ== \"SkyBox Offset Angle\" Float 1 AAAAAA== \"SkyBox Width\" Int 1 AAgAAA== \"SkyBox Height\" Int 1 AAQAAA== \"Pixel Subdivisions\" Int 1 AAAAAA== \"Max Bounces\" Int 1 AQAAAA== \"Max Ray Distance\" Float 1 AAB6RA== \"Max Ray Steps\" Int 1 gAAAAA== \"Hit Tolerance\" Float 1 bxKDOg== \"Shadow Bias\" Float 1 AACAPw== \"Object Texture Height\" Int 1 AAAAAA== \"Object Texture Width\" Int 1 AAAAAA== \"Light Texture Height\" Int 1 AAAAAA== \"Light Texture Width\" Int 1 AAAAAA== \"Haze Amount\" Float 1 AAAAAA== \"Haze Start\" Float 1 AAAAAA== \"Haze Distance\" Float 1 AAB6RA== \"Haze Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"Iter Glow Amount\" Float 1 AAAAAA== \"Iter Glow Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== 26 \"focalLength\" 1 1 \"horizontalAperture\" 1 1 \"nearPlane\" 1 1 \"farPlane\" 1 1 \"cameraWorldMatrix\" 16 1 \"formatWidth\" 1 1 \"formatHeight\" 1 1 \"skyBoxOffsetAngle\" 1 1 \"skyFormatWidth\" 1 1 \"skyFormatHeight\" 1 1 \"subdivisions\" 1 1 \"maxBounces\" 1 1 \"maxRayDistance\" 1 1 \"maxRaySteps\" 1 1 \"hitTolerance\" 1 1 \"shadowBias\" 1 1 \"objectTextureHeight\" 1 1 \"objectTextureWidth\" 1 1 \"lightTextureHeight\" 1 1 \"lightTextureWidth\" 1 1 \"hazeAmount\" 1 1 \"hazeStart\" 1 1 \"hazeDistance\" 1 1 \"hazeColour\" 4 1 \"iterGlowAmount\" 1 1 \"iterGlowColour\" 4 1 6 \"inverseCameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"bouncesPerRay\" Int 1 1 AAAAAA== \"numSubPixels\" Int 1 1 AAAAAA== \"subdividedPixelSize\" Float 1 1 AAAAAA== \"skyBoxPixelSize\" Float 2 1 AAAAAAAAAAA= \"skyBoxOffsetRadians\" Float 1 1 AAAAAA=="
  kernelSource "#include \"camera.h\"\n#include \"lights.h\"\n#include \"mmath.h\"\n#include \"sdfs.h\"\n#include \"sdfTransforms.h\"\n#include \"sdTransforms.h\"\n\n\nkernel RayMarchKernel : ImageComputationKernel<ePixelWise>\n\{\n    // the input for format, process called once per pixel\n    Image<eRead, eAccessPoint, eEdgeNone> bg;\n\n    // the skybox in latlong format\n    Image<eRead, eAccessRandom, eEdgeNone> skyBox;\n\n\n    // the shape positons.xyz, scale.w\n    Image<eRead, eAccessRandom, eEdgeNone> positions;\n\n    // the shape rotations.xyz, wall thickness.w\n    Image<eRead, eAccessRandom, eEdgeNone> rotations;\n\n    // the shape dimensions.xyzw (some shapes may not use all channels)\n    Image<eRead, eAccessRandom, eEdgeNone> dimensions;\n\n    // the shape colours.xyz\n    Image<eRead, eAccessRandom, eEdgeNone> colours;\n\n\n    // shape type.x, operation.y, numChildren.z, blend strength.w\n    Image<eRead, eAccessRandom, eEdgeNone> shapeProperties;\n\n    // repetition params.xyzw\n    Image<eRead, eAccessRandom, eEdgeNone> shapeModParameters0;\n\n    // elongation.xyz edgeRadius.w\n    Image<eRead, eAccessRandom, eEdgeNone> shapeModParameters1;\n\n    // reflection.x, transmission.y, emission.z, roughness.w (TODO)\n    Image<eRead, eAccessRandom, eEdgeNone> surfaceProperties;\n\n\n    // the input lights direction/position.xyz intensity.w\n    Image<eRead, eAccessRandom, eEdgeNone> lights;\n\n    // colour.xyz, type.w\n    // w in \[0, 1) = directional, \[1, inf) = point\n    Image<eRead, eAccessRandom, eEdgeNone> lightProperties;\n\n    // the output image\n    Image<eWrite> dst;\n\n\n    param:\n        // These parameters are made available to the user.\n\n        // Camera params\n        float focalLength;\n        float horizontalAperture;\n        float nearPlane;\n        float farPlane;\n        float4x4 cameraWorldMatrix;\n\n        // Image params\n        float formatWidth;\n        float formatHeight;\n\n        float skyBoxOffsetAngle;\n        int skyFormatWidth;\n        int skyFormatHeight;\n\n        // Ray params\n        int subdivisions;\n        int maxBounces;\n        float maxRayDistance;\n        int maxRaySteps;\n        float hitTolerance;\n        float shadowBias;\n\n        // Scene params\n        // Shape Textures\n        int objectTextureHeight;\n        int objectTextureWidth;\n\n        // Light textures\n        int lightTextureHeight;\n        int lightTextureWidth;\n\n        float hazeAmount;\n        float hazeStart;\n        float hazeDistance;\n        float4 hazeColour;\n\n        float iterGlowAmount;\n        float4 iterGlowColour;\n\n    local:\n        // These local variables are not exposed to the user.\n\n        float4x4 inverseCameraProjectionMatrix;\n\n        int bouncesPerRay;\n\n        int numSubPixels;\n        float subdividedPixelSize;\n\n        float2 skyBoxPixelSize;\n        float skyBoxOffsetRadians;\n\n\n\n    // In define(), parameters can be given labels and default values.\n    void define()\n    \{\n        // Camera params\n        defineParam(focalLength, \"Focal Length\", 50.0f);\n        defineParam(horizontalAperture, \"Horizontal Aperture\", 24.576f);\n        defineParam(nearPlane, \"Near Plane\", 0.1f);\n        defineParam(farPlane, \"Far Plane\", 10000.0f);\n        defineParam(\n            cameraWorldMatrix,\n            \"Camera World Matrix\",\n            float4x4(\n                1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1\n            )\n        );\n\n        // Image params\n        defineParam(formatHeight, \"Screen Height\", 2160.0f);\n        defineParam(formatWidth, \"Screen Width\", 3840.0f);\n        defineParam(skyBoxOffsetAngle, \"SkyBox Offset Angle\", 0.0f);\n        defineParam(skyFormatHeight, \"SkyBox Height\", 1024);\n        defineParam(skyFormatWidth, \"SkyBox Width\", 2048);\n\n        // Ray params\n        defineParam(subdivisions, \"Pixel Subdivisions\", 0);\n        defineParam(maxRayDistance, \"Max Ray Distance\", 1000.0f);\n        defineParam(maxRaySteps, \"Max Ray Steps\", 128);\n        defineParam(maxBounces, \"Max Bounces\", 1);\n        defineParam(hitTolerance, \"Hit Tolerance\", 0.001f);\n        defineParam(shadowBias, \"Shadow Bias\", 1.0f);\n\n        // Scene params\n\n        // Shape Counts\n        defineParam(objectTextureHeight, \"Object Texture Height\", 0);\n        defineParam(objectTextureWidth, \"Object Texture Width\", 0);\n\n        // Light Counts\n        defineParam(lightTextureHeight, \"Light Texture Height\", 0);\n        defineParam(lightTextureWidth, \"Light Texture Width\", 0);\n\n        defineParam(hazeAmount, \"Haze Amount\", 0.0f);\n        defineParam(hazeStart, \"Haze Start\", 0.0f);\n        defineParam(hazeDistance, \"Haze Distance\", 1000.0f);\n        defineParam(hazeColour, \"Haze Colour\", float4(1, 1, 1, 1));\n\n        defineParam(iterGlowAmount, \"Iter Glow Amount\", 0.0f);\n        defineParam(iterGlowColour, \"Iter Glow Colour\", float4(1, 1, 1, 1));\n    \}\n\n\n    // The init() function is run before any calls to process().\n    // Local variables can be initialized here.\n    void init()\n    \{\n        bouncesPerRay = maxBounces <= 0 ? 1 : maxBounces;\n\n        // TODO use angles to allow -ve focal length like for latlongs\n        float aspect = aspectRatio(formatHeight, formatWidth);\n        float4x4 cameraProjectionMatrix = projectionMatrix(\n            focalLength,\n            horizontalAperture,\n            aspect,\n            nearPlane,\n            farPlane\n        );\n        inverseCameraProjectionMatrix = cameraProjectionMatrix.invert();\n\n        int subPixelDivisions = pow(2, abs(subdivisions));\n        subdividedPixelSize = 1.0f / (float) subPixelDivisions;\n        numSubPixels = pow(subPixelDivisions, 2);\n\n        skyBoxPixelSize = float2(skyFormatWidth / (2 * PI), skyFormatHeight / PI);\n        skyBoxOffsetRadians = skyBoxOffsetAngle * PI / 180.0f;\n    \}\n\n\n    /**\n     * Get the value of sky the ray would hit at infinite distance\n     */\n    float4 readSkyValue(float3 rayDirection)\n    \{\n        float2 angles = cartesionUnitVectorToSpherical(rayDirection, skyBoxOffsetRadians);\n\n        SampleType(skyBox) skyBoxPixel = bilinear(\n            skyBox,\n            skyBoxPixelSize.x * angles.x,\n            skyFormatHeight - (skyBoxPixelSize.y * angles.y)\n        );\n\n        return saturate(skyBoxPixel);\n    \}\n\n\n    //\n    // Render Engine\n    //\n\n\n    float3 transformRay(\n        const float3 &rayOrigin,\n        const float3 &position,\n        const float3 &rotation,\n        const int modifications,\n        const float4 &modParameters0,\n        const float4 &modParameters1)\n    \{\n        float3x3 rotMatrix;\n        float3 transformedRay;\n        rotationMatrix(rotation, rotMatrix);\n        matmul(\n            rotMatrix.invert(),\n            rayOrigin - position,\n            transformedRay\n        );\n        performShapeModification(\n            modifications,\n            modParameters0,\n            modParameters1,\n            transformedRay\n        );\n\n        return transformedRay;\n    \}\n\n\n    float getNextDistance(\n        const float3 &rayOrigin,\n        const int shape,\n        const float4 &dimension,\n        const float uniformScale,\n        const int modifications,\n        const float edgeRadius,\n        const float wallThickness)\n    \{\n        float nextDistance = distanceToObject(\n            rayOrigin / uniformScale,\n            shape,\n            dimension\n        ) * uniformScale;\n\n        return performDistanceModification(\n            modifications,\n            edgeRadius,\n            wallThickness,\n            nextDistance\n        );\n    \}\n\n\n    /**\n     * Compute the minimum distance to an object in the scene\n     */\n    float getMinDistanceToObjectInScene(\n            const float3 &rayOrigin,\n            float4 &colour,\n            float4 &surface)\n    \{\n        float distance = maxRayDistance;\n\n        for (int i=0; i < objectTextureHeight; i++)\n        \{\n            for (int j=0; j < objectTextureWidth; j++)\n            \{\n                SampleType(positions) position = positions(j, i);\n                SampleType(rotations) rotation = rotations(j, i);\n                SampleType(dimensions) dimension = dimensions(j, i);\n                SampleType(shapeProperties) shapeProperty = shapeProperties(j, i);\n                SampleType(shapeModParameters0) modParameters0 = shapeModParameters0(j, i);\n                SampleType(shapeModParameters1) modParameters1 = shapeModParameters1(j, i);\n\n                const int modifications = (int) shapeProperty.y;\n                const float scale = position.w;\n\n                const float3 transformedRay = transformRay(\n                    rayOrigin,\n                    float3(position.x, position.y, position.z),\n                    float3(rotation.x, rotation.y, rotation.z),\n                    modifications,\n                    modParameters0,\n                    modParameters1\n                );\n\n                float nextDistance = getNextDistance(\n                    transformedRay,\n                    (int) shapeProperty.x,\n                    dimension,\n                    scale,\n                    modifications,\n                    modParameters1.w,\n                    rotation.w\n                );\n\n                const int numChildren = (int) shapeProperty.z;\n                const float blendStrength = shapeProperty.w;\n\n                // TODO should be able to get rid of this duplication in a clever way\n                // maybe cahce the parent values as you compute the child then pop back\n                // and allow infinite child depth\n                for (int child=j + 1; child < j + 1 + numChildren; child++)\n                \{\n                    SampleType(positions) childPosition = positions(child, i);\n                    SampleType(rotations) childRotation = rotations(child, i);\n                    SampleType(dimensions) childDimension = dimensions(child, i);\n                    SampleType(shapeProperties) childShapeProperty = shapeProperties(child, i);\n                    SampleType(shapeModParameters0) childModParameters0 = shapeModParameters0(child, i);\n                    SampleType(shapeModParameters1) childModParameters1 = shapeModParameters1(child, i);\n\n                    const int childModifications = (int) childShapeProperty.y;\n                    const float childScale = childPosition.w * scale;\n\n                    const float3 childTransformedRay = transformRay(\n                        transformedRay,\n                        float3(childPosition.x, childPosition.y, childPosition.z),\n                        float3(childRotation.x, childRotation.y, childRotation.z),\n                        childModifications,\n                        childModParameters0,\n                        childModParameters1\n                    );\n\n                    const float childNextDistance = getNextDistance(\n                        childTransformedRay,\n                        (int) childShapeProperty.x,\n                        childDimension,\n                        childScale,\n                        childModifications,\n                        childModParameters1.w,\n                        childRotation.w\n                    );\n\n                    nextDistance = performChildInteraction(\n                        modifications,\n                        childNextDistance,\n                        nextDistance,\n                        blendStrength\n                    );\n                \}\n                j += numChildren;\n\n                if (nextDistance < distance)\n                \{\n                    distance = nextDistance;\n\n                    SampleType(colours) surfaceColour = colours(j, i);\n                    SampleType(surfaceProperties) surfaceProperty = surfaceProperties(j, i);\n\n                    colour = float4(surfaceColour);\n                    surface = float4(surfaceProperty);\n                \}\n            \}\n        \}\n\n        return distance;\n    \}\n\n\n    float computeShadow(\n            const float3 &rayDirection,\n            const float distanceToShadePoint,\n            float3 &rayOrigin)\n    \{\n        float distanceTravelled = 0;\n        float4 colour;\n        float4 surface;\n        int iterations = 0;\n        while (distanceTravelled < distanceToShadePoint && iterations < maxRaySteps / 2)\n        \{\n            float stepDistance = getMinDistanceToObjectInScene(rayOrigin, colour, surface);\n\n            if (fabs(stepDistance) < hitTolerance)\n            \{\n                return 0;\n            \}\n\n            rayOrigin += rayDirection * stepDistance;\n            distanceTravelled += stepDistance;\n            iterations++;\n        \}\n\n        return 1;\n    \}\n\n\n    float2 lightIntensityOnSurface(\n            const float3 &pointOnSurface,\n            const float3 &surfaceNormal,\n            const float3 &light,\n            const int lightType,\n            const float intensity)\n    \{\n        float3 surfaceOffset;\n        float distanceToLight;\n        float3 lightDirection;\n        float3 shadowOffsetLightDirection;\n        float intensityAtPosition = getLightData(\n            pointOnSurface,\n            surfaceNormal,\n            light,\n            lightType,\n            intensity,\n            hitTolerance,\n            maxRayDistance,\n            shadowBias,\n            distanceToLight,\n            surfaceOffset,\n            lightDirection,\n            shadowOffsetLightDirection\n        );\n\n        float normalFactor = dot(surfaceNormal, normalize(lightDirection));\n\n        return saturate(\n            normalFactor * float2(\n                intensityAtPosition,\n                computeShadow(\n                    normalize(shadowOffsetLightDirection),\n                    distanceToLight,\n                    surfaceOffset\n                )\n            )\n        );\n    \}\n\n\n    /**\n     * Get the intensity of the light on the surface of an object\n     *\n     *\n     */\n    float computeLightIntensityOnSurface(const float3 &pointOnSurface, const float3 &surfaceNormal)\n    \{\n        float2 lightIntensity = float2(0, 0);\n\n        for (int i=0; i < lightTextureHeight; i++)\n        \{\n            for (int j=0; j < lightTextureWidth; j++)\n            \{\n                SampleType(lights) light = lights(j, i);\n                SampleType(lightProperties) lightProperty = lightProperties(j, i);\n\n                int lightType = (int) lightProperty.w;\n                if (lightType < 0)\n                \{\n                    lightIntensity += float2(light.w, 1);\n                \}\n                else\n                \{\n                    lightIntensity += lightIntensityOnSurface(\n                        pointOnSurface,\n                        surfaceNormal,\n                        float3(light.x, light.y, light.z),\n                        lightType,\n                        light.w\n                    );\n                \}\n            \}\n        \}\n\n        return saturate(lightIntensity.x * lightIntensity.y);\n    \}\n\n\n    float getHazeAmount(const float distance)\n    \{\n        return hazeAmount * saturate((distance - hazeStart) / hazeDistance);\n    \}\n\n\n    /**\n     * Estimate the surface normal at the closest point on the closest\n     * object to a point\n     *\n     * @arg point: The point near which to get the surface normal\n     *\n     * @returns: The normalized surface normal\n     */\n    float3 estimateSurfaceNormal(const float3 &point) \{\n        float4 colour;\n        float4 surface;\n        return normalize(\n            float3(\n                getMinDistanceToObjectInScene(\n                    float3(\n                        point.x + hitTolerance,\n                        point.y,\n                        point.z\n                    ),\n                    colour,\n                    surface\n                ) - getMinDistanceToObjectInScene(\n                    float3(\n                        point.x - hitTolerance,\n                        point.y,\n                        point.z\n                    ),\n                    colour,\n                    surface\n                ),\n                getMinDistanceToObjectInScene(\n                    float3(\n                        point.x,\n                        point.y + hitTolerance,\n                        point.z\n                    ),\n                    colour,\n                    surface\n                ) - getMinDistanceToObjectInScene(\n                    float3(\n                        point.x,\n                        point.y - hitTolerance,\n                        point.z\n                    ),\n                    colour,\n                    surface\n                ),\n                getMinDistanceToObjectInScene(\n                    float3(\n                        point.x,\n                        point.y,\n                        point.z+hitTolerance\n                    ),\n                    colour,\n                    surface\n                ) - getMinDistanceToObjectInScene(\n                    float3(\n                        point.x,\n                        point.y,\n                        point.z - hitTolerance\n                    ),\n                    colour,\n                    surface\n                )\n        ));\n    \}\n\n\n    /**\n     * March a ray through the scene\n     *\n     * @returns: The ray colour\n     */\n    float4 marchRay(\n            const float3 &rayOrigin,\n            const float3 &rayDirection,\n            const int numBounces,\n            const float rayDistance)\n    \{\n        float3 origin = rayOrigin;\n        float3 direction = rayDirection;\n        float4 colour;\n        float4 surface;\n\n        int bounces = 0;\n        float distanceTravelled = 0;\n        float lastHitDistance = distanceTravelled;\n\n        float lightIntensity = 1;\n\n        float4 rayColour = float4(0, 0, 0, 0);\n\n        float rayStrength = 1;\n\n        int iterations = 1;\n        while (distanceTravelled < rayDistance && rayStrength > 0 && iterations <= maxRaySteps)\n        \{\n            float stepDistance = getMinDistanceToObjectInScene(origin, colour, surface);\n            distanceTravelled += stepDistance;\n            origin += direction * stepDistance;\n\n            if (fabs(stepDistance) < hitTolerance)\n            \{\n                bounces++;\n\n                float3 surfaceNormal = estimateSurfaceNormal(\n                    origin - direction * hitTolerance\n                );\n\n                lightIntensity = computeLightIntensityOnSurface(\n                    origin,\n                    surfaceNormal\n                );\n\n                rayColour = blend(\n                    iterGlowColour,\n                    blend(\n                        hazeColour,\n                        blend(\n                            colour,\n                            rayColour,\n                            rayStrength * (1 - surface.x) * lightIntensity\n                        ),\n                        getHazeAmount(distanceTravelled - lastHitDistance)\n                    ),\n                    saturate(iterGlowAmount * iterations)\n                );\n\n                if (bounces >= numBounces)\n                \{\n                    rayColour.w = 1.0f;\n                    return rayColour;\n                \}\n\n                rayStrength *= surface.x;\n\n                direction = reflectRayOffSurface(\n                    direction,\n                    surfaceNormal\n                );\n                origin = offsetPoint(\n                    origin,\n                    direction + surfaceNormal,\n                    hitTolerance\n                );\n\n                lastHitDistance = distanceTravelled;\n            \}\n            iterations++;\n        \}\n\n        rayColour = blend(\n            blend(\n                iterGlowColour,\n                blend(\n                    hazeColour,\n                    readSkyValue(direction),\n                    getHazeAmount(distanceTravelled - lastHitDistance)\n                ),\n                saturate(iterGlowAmount * iterations)\n            ),\n            rayColour,\n            rayStrength * lightIntensity\n        );\n        rayColour.w = bounces > 0;\n        return rayColour;\n    \}\n\n\n    /**\n     * Compute a raymarched pixel value\n     */\n    void process(int2 pos)\n    \{\n        float4 resultPixel(0, 0, 0, 0);\n\n        float2 pixelLocation = float2(pos.x, pos.y);\n\n        float2 pixelOffset;\n        for (\n            pixelOffset.x = 0.0f;\n            pixelOffset.x < 1.0f;\n            pixelOffset.x += subdividedPixelSize\n        ) \{\n            for (\n                pixelOffset.y = 0.0f;\n                pixelOffset.y < 1.0f;\n                pixelOffset.y += subdividedPixelSize\n            ) \{\n                // Generate a ray from the camera\n                float3 rayOrigin;\n                float3 rayDirection;\n                createCameraRay(\n                    cameraWorldMatrix,\n                    inverseCameraProjectionMatrix,\n                    pixelsToUV(\n                        pixelLocation + pixelOffset,\n                        float2(formatWidth, formatHeight)\n                    ),\n                    rayOrigin,\n                    rayDirection\n                );\n\n                resultPixel += marchRay(\n                    rayOrigin,\n                    rayDirection,\n                    bouncesPerRay,\n                    maxRayDistance\n                );\n            \}\n        \}\n\n        dst() = resultPixel / numSubPixels;\n    \}\n\};\n"
  rebuild ""
  "RayMarchKernel_Focal Length" {{parent.DummyCam.focal}}
  "RayMarchKernel_Horizontal Aperture" {{parent.DummyCam.haperture}}
  "RayMarchKernel_Near Plane" {{parent.DummyCam.near}}
  "RayMarchKernel_Far Plane" {{parent.DummyCam.far}}
  "RayMarchKernel_Camera World Matrix" {
      {{parent.DummyCam.world_matrix.0} {parent.DummyCam.world_matrix.1} {parent.DummyCam.world_matrix.2} {parent.DummyCam.world_matrix.3}}
      {{parent.DummyCam.world_matrix.4} {parent.DummyCam.world_matrix.5} {parent.DummyCam.world_matrix.6} {parent.DummyCam.world_matrix.7}}
      {{parent.DummyCam.world_matrix.8} {parent.DummyCam.world_matrix.9} {parent.DummyCam.world_matrix.10} {parent.DummyCam.world_matrix.11}}
      {{parent.DummyCam.world_matrix.12} {parent.DummyCam.world_matrix.13} {parent.DummyCam.world_matrix.14} {parent.DummyCam.world_matrix.15}}
    }
  "RayMarchKernel_Screen Width" {{parent.resolution_dot.width}}
  "RayMarchKernel_Screen Height" {{parent.resolution_dot.height}}
  "RayMarchKernel_SkyBox Offset Angle" {{parent.skybox_offset_angle}}
  "RayMarchKernel_SkyBox Width" {{parent.sky_dot.width}}
  "RayMarchKernel_SkyBox Height" {{parent.sky_dot.height}}
  "RayMarchKernel_Pixel Subdivisions" {{parent.pixel_subdivisions}}
  "RayMarchKernel_Max Bounces" {{parent.max_bounces}}
  "RayMarchKernel_Max Ray Distance" {{parent.ray_distance}}
  "RayMarchKernel_Max Ray Steps" {{parent.max_ray_steps}}
  "RayMarchKernel_Hit Tolerance" {{parent.hit_tolerance}}
  "RayMarchKernel_Shadow Bias" {{parent.shadow_bias}}
  "RayMarchKernel_Object Texture Height" {{parent.obj_dot.height}}
  "RayMarchKernel_Object Texture Width" {{parent.obj_dot.width}}
  "RayMarchKernel_Light Texture Height" {{parent.light_dot.height}}
  "RayMarchKernel_Light Texture Width" {{parent.light_dot.width}}
  "RayMarchKernel_Haze Amount" {{parent.haze}}
  "RayMarchKernel_Haze Start" {{parent.haze_start}}
  "RayMarchKernel_Haze Distance" {{parent.haze_distance}}
  "RayMarchKernel_Haze Colour" {{parent.haze_colour.r} {parent.haze_colour.g} {parent.haze_colour.b} {parent.haze_colour.a}}
  "RayMarchKernel_Iter Glow Amount" {{parent.iter_glow}}
  "RayMarchKernel_Iter Glow Colour" {{parent.iter_glow_colour.r} {parent.iter_glow_colour.g} {parent.iter_glow_colour.b} {parent.iter_glow_colour.a}}
  format "2048 1024 0 0 2048 1024 1 2K_LatLong"
  rebuild_finalise ""
  name BlinkRayMarcher
  xpos 1661
  ypos -461
 }
 Output {
  name Output1
  xpos 1661
  ypos -122
 }
 Input {
  inputs 0
  name camera
  xpos 1354
  ypos -1578
  number 2
 }
 Camera {
  projection_mode {{"\[expression \[value the_cam]projection_mode(\[value the_frame])]"}}
  focal {{"\[expression \[value the_cam]focal(\[value the_frame])]"}}
  haperture {{"\[expression \[value the_cam]haperture(\[value the_frame])]"}}
  vaperture {{"\[expression \[value the_cam]vaperture(\[value the_frame])]"}}
  near {{"\[expression \[value the_cam]near(\[value the_frame])]"}}
  far {{"\[expression \[value the_cam]far(\[value the_frame])]"}}
  win_translate {{"\[expression \[value the_cam]win_translate.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_translate.v(\[value the_frame])]"}}
  win_scale {{"\[expression \[value the_cam]win_scale.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_scale.v(\[value the_frame])]"}}
  winroll {{"\[expression \[value the_cam]winroll(\[value the_frame])]"}}
  focal_point {{"\[expression \[value the_cam]focal_point(\[value the_frame])]"}}
  fstop {{"\[expression \[value the_cam]fstop(\[value the_frame])]"}}
  name DummyCam
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if no Camera connected. Can also be used inside of groups and gizmos, as many levels deep as you want :D All using live and super fast TCL.\n\nUpdated v1.1: Now grabs the correct frame too (thanks Erwan Leroy for the idea).\n\nUpdated v1.3: Now accepts Nuke13's Camera3\n\nadrianpueyo.com, 2019-2021"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  xpos 1364
  ypos -1473
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\n#DummyCam v1.3 - Updated 5 May 2021.\nset starting_point \"this.input0\"\nset default \"this.d_\"\n\n# If cam has no inputs, return the default.\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera3\" && \[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera3\"||\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{ \[class \$x]==\"Input\" \} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{ \[exists \$inp] \} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {43 the_frame +INVISIBLE}
  the_frame "\[\nset the_camera \[string trimright \[value the_cam] .]\nif \{\[exists \$the_camera]\} \{\n    return \[value \$the_camera.frame]\n\} \{ \n    return \[frame]\n\}\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l "focal length" R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {30 d_win_translate l "window translate"}
  addUserKnob {30 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 version l " " t "Updated 5 May 2021" T "<span style=\"color:#666\"><br/><b>DummyCam v1.3</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019-2021</span>"}
 }
end_group
Viewer {
 frame_range 1-200
 channels rgb
 colour_sample_bbox {0.2001953125 0.1083984375 0.2006835938 0.1088867188}
 name Viewer1
 xpos 18317
 ypos 1291
}
Group {
 inputs 0
 name sdf_primitive4
 xpos 18583
 ypos 880
 addUserKnob {20 User}
 addUserKnob {4 shape l Shape M {sphere ellipsoid "cut sphere" "hollow sphere" "death star" "solid angle" "rectangular prism" "rectangular prism frame" rhombus "triangular prism" cylinder "infinite cylinder" plane capsule cone "infinite cone" "capped cone" "rounded cone" torus "capped torus" "hexagonal prism" octahedron link mandelbulb}}
 addUserKnob {19 dimensions l Dimensions t "The dimensions of the object, the values change meaning depending on the shape, and for some, not all values are used.\n\nSphere:\n    r = radius\n\nEllipsoid:\n    r = The radius along the x-axis of the ellipsoid.\n    g = The radius along the y-axis of the ellipsoid.\n    b = The radius along the z-axis of the ellipsoid.\n\n"}
 dimensions {0.3 0.2 2.356194 0.01}
 addUserKnob {6 dimensions_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {18 colour l Colour}
 colour {1 0.25 0.5}
 addUserKnob {6 colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 surface l Surface t "r = reflectivity\ng = transmissivity (TODO)\nb = emissivity (TODO)\na = roughness (TODO)"}
 surface {0 0 0 0}
 addUserKnob {6 surface_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 wall_thickness l "Wall Thickness"}
 wall_thickness 0.01
 addUserKnob {6 hollow l Hollow t "If true, the object will be hollow, with a thickness of 'Wall Thickness'" -STARTLINE}
 addUserKnob {13 elongation l Elongation}
 elongation {0.3 0 0}
 addUserKnob {6 elongate l Elongate -STARTLINE}
 addUserKnob {7 edge_radius l "Edge Radius"}
 addUserKnob {6 mirror_x l "Mirror X" +STARTLINE}
 addUserKnob {6 mirror_y l "Mirror Y" -STARTLINE}
 addUserKnob {6 mirror_z l "Mirror Z" -STARTLINE}
 addUserKnob {26 div0 l "" +STARTLINE}
 addUserKnob {13 position l Position}
 position {-0.25 0 0}
 addUserKnob {13 rotation l Rotation}
 rotation {0 50 0}
 addUserKnob {7 uniform_scale l "Uniform Scale" R 0 10}
 uniform_scale 1
 addUserKnob {26 div1 l "" +STARTLINE}
 addUserKnob {19 repetition_params l Repetition}
 repetition_params {5 5 1 1.5}
 addUserKnob {6 repetition_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {4 repetition_type l Type -STARTLINE M {None Finite Infinite "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {7 blend_strength l "Blend Strength"}
 addUserKnob {4 blend_type l "Blend Type" -STARTLINE M {Union Subtraction Intersection "Smooth Union" "Smooth Subtraction" "Smooth Intersection" ""}}
}
 Input {
  inputs 0
  name children
  xpos 1357
  ypos 418
 }
 Dot {
  name Dot1
  xpos 1391
  ypos 826
 }
 Constant {
  inputs 0
  channels sdf_position_scale
  color {{parent.position.x} {parent.position.y} {parent.position.z} {parent.uniform_scale}}
  format "1 1 0 0 1 1 1 1x1"
  name position_scale
  xpos 280
  ypos 455
 }
 Dot {
  name Dot17
  xpos 314
  ypos 647
 }
 Constant {
  inputs 0
  channels sdf_rotation_wall_thickness
  color {{"parent.rotation.x * pi / 180.0"} {"parent.rotation.y * pi / 180.0"} {"parent.rotation.z * pi / 180.0"} {parent.wall_thickness}}
  format "1 1 0 0 1 1 1 1x1"
  name rotation
  xpos 403
  ypos 457
 }
 Copy {
  inputs 2
  channels all
  name Copy1
  xpos 403
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_dimensions
  color {{parent.dimensions.r} {parent.dimensions.g} {parent.dimensions.b} {parent.dimensions.a}}
  format "1 1 0 0 1 1 1 1x1"
  name dimensions
  xpos 540
  ypos 460
 }
 Copy {
  inputs 2
  channels all
  name Copy2
  xpos 540
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_colour
  color {{parent.colour.r} {parent.colour.g} {parent.colour.b} 0}
  format "1 1 0 0 1 1 1 1x1"
  name colour
  xpos 669
  ypos 459
 }
 Copy {
  inputs 2
  channels all
  name Copy3
  xpos 669
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_shape
  color {{parent.shape} {"parent.repetition_type | (parent.elongate ? 4 : 0) | (parent.mirror_x ? 8 : 0) | (parent.mirror_y ? 16 : 0) | (parent.mirror_z ? 32 : 0) | (parent.hollow ? 64 : 0) | (parent.blend_type > 0 ? (1 << (parent.blend_type + 6)) : 0)"} {"parent.sdf_merge.disable ? 0 : parent.sdf_merge.input1.width"} {parent.blend_strength}}
  format "1 1 0 0 1 1 1 1x1"
  name shape
  xpos 806
  ypos 462
 }
 Copy {
  inputs 2
  channels all
  name Copy4
  xpos 806
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_surface
  color {{parent.surface.r} {parent.surface.g} {parent.surface.b} {parent.surface.a}}
  format "1 1 0 0 1 1 1 1x1"
  name surface
  xpos 935
  ypos 460
 }
 Copy {
  inputs 2
  channels all
  name Copy5
  xpos 936
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_shape_mods_0
  color {{parent.repetition_params.r} {parent.repetition_params.g} {parent.repetition_params.b} {parent.repetition_params.a}}
  format "1 1 0 0 1 1 1 1x1"
  name shape_mods
  xpos 1056
  ypos 463
 }
 Copy {
  inputs 2
  channels all
  name Copy6
  xpos 1056
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_shape_mods_1
  color {{parent.elongation.x} {parent.elongation.y} {parent.elongation.z} {parent.edge_radius}}
  format "1 1 0 0 1 1 1 1x1"
  name shape_mods1
  xpos 1183
  ypos 465
 }
 Copy {
  inputs 2
  channels all
  name Copy7
  xpos 1183
  ypos 726
 }
 Group {
  inputs 2
  name sdf_merge
  xpos 1183
  ypos 822
  disable {{"\[exists parent.input0] ? 0 : 1"}}
  addUserKnob {20 User}
  addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
 }
  Reformat {
   inputs 0
   type "to box"
   box_width 1
   box_height 1
   box_fixed true
   name Reformat1
   xpos -119
   ypos 440
  }
  Input {
   inputs 0
   name Input2
   xpos 158
   ypos -28
   number 1
  }
  Dot {
   name Dot2
   xpos 192
   ypos -2
  }
set Nf0637200 [stack 0]
  Dot {
   name Dot3
   xpos 329
   ypos -2
  }
  Dot {
   name Dot4
   xpos 329
   ypos 391
  }
  Input {
   inputs 0
   name Input1
   xpos 0
   ypos -32
  }
  Dot {
   name Dot1
   xpos 34
   ypos -6
  }
set Nf0635600 [stack 0]
  Dot {
   name Dot6
   xpos -98
   ypos -6
  }
  Dot {
   name Dot5
   xpos -98
   ypos 336
  }
push $Nf0637200
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop3
   xpos 158
   ypos 69
  }
  Crop {
   box {0 0 {parent.Dot2.width} 1}
   name Crop4
   xpos 158
   ypos 95
  }
  Transform {
   translate {{parent.Dot1.width} 0}
   center {1 0.5}
   name Transform2
   xpos 158
   ypos 121
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop5
   xpos 158
   ypos 167
  }
push $Nf0635600
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop6
   xpos 0
   ypos 66
  }
  Crop {
   box {0 0 {parent.Dot1.width} 1}
   name Crop7
   xpos 0
   ypos 92
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop8
   xpos 0
   ypos 164
  }
  Merge2 {
   inputs 2
   also_merge all
   name Merge1
   xpos 0
   ypos 262
   disable {{"\[exists parent.input1] ? 0:1"}}
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input1] ? 0:1"}}
   name Switch2
   xpos 0
   ypos 332
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:1"}}
   name Switch1
   xpos 0
   ypos 387
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
   name Switch3
   xpos 0
   ypos 456
  }
  Dot {
   name out_dot
   xpos 36
   ypos 518
  }
  Output {
   name Output1
   xpos 2
   ypos 661
  }
 end_group
 Output {
  name Output1
  xpos 1183
  ypos 1002
 }
end_group
Group {
 inputs 0
 name sdf_primitive3
 xpos 18704
 ypos 880
 addUserKnob {20 User}
 addUserKnob {4 shape l Shape M {sphere ellipsoid "cut sphere" "hollow sphere" "death star" "solid angle" "rectangular prism" "rectangular prism frame" rhombus "triangular prism" cylinder "infinite cylinder" plane capsule cone "infinite cone" "capped cone" "rounded cone" torus "capped torus" "hexagonal prism" octahedron link mandelbulb}}
 addUserKnob {19 dimensions l Dimensions t "The dimensions of the object, the values change meaning depending on the shape, and for some, not all values are used.\n\nSphere:\n    r = radius\n\nEllipsoid:\n    r = The radius along the x-axis of the ellipsoid.\n    g = The radius along the y-axis of the ellipsoid.\n    b = The radius along the z-axis of the ellipsoid.\n\n"}
 dimensions {0.3 0.2 2.356194 0.01}
 addUserKnob {6 dimensions_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {18 colour l Colour}
 colour {1 0.25 0.5}
 addUserKnob {6 colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 surface l Surface t "r = reflectivity\ng = transmissivity (TODO)\nb = emissivity (TODO)\na = roughness (TODO)"}
 surface {0 0 0 0}
 addUserKnob {6 surface_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 wall_thickness l "Wall Thickness"}
 wall_thickness 0.01
 addUserKnob {6 hollow l Hollow t "If true, the object will be hollow, with a thickness of 'Wall Thickness'" -STARTLINE}
 addUserKnob {13 elongation l Elongation}
 elongation {0.3 0 0}
 addUserKnob {6 elongate l Elongate -STARTLINE}
 addUserKnob {7 edge_radius l "Edge Radius"}
 addUserKnob {6 mirror_x l "Mirror X" +STARTLINE}
 addUserKnob {6 mirror_y l "Mirror Y" -STARTLINE}
 addUserKnob {6 mirror_z l "Mirror Z" -STARTLINE}
 addUserKnob {26 div0 l "" +STARTLINE}
 addUserKnob {13 position l Position}
 position {0 0 0.25}
 addUserKnob {13 rotation l Rotation}
 addUserKnob {7 uniform_scale l "Uniform Scale" R 0 10}
 uniform_scale 1
 addUserKnob {26 div1 l "" +STARTLINE}
 addUserKnob {19 repetition_params l Repetition}
 repetition_params {5 5 1 1.5}
 addUserKnob {6 repetition_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {4 repetition_type l Type -STARTLINE M {None Finite Infinite "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {7 blend_strength l "Blend Strength"}
 addUserKnob {4 blend_type l "Blend Type" -STARTLINE M {Union Subtraction Intersection "Smooth Union" "Smooth Subtraction" "Smooth Intersection" ""}}
}
 Input {
  inputs 0
  name children
  xpos 1357
  ypos 418
 }
 Dot {
  name Dot1
  xpos 1391
  ypos 826
 }
 Constant {
  inputs 0
  channels sdf_position_scale
  color {{parent.position.x} {parent.position.y} {parent.position.z} {parent.uniform_scale}}
  format "1 1 0 0 1 1 1 1x1"
  name position_scale
  xpos 280
  ypos 455
 }
 Dot {
  name Dot17
  xpos 314
  ypos 647
 }
 Constant {
  inputs 0
  channels sdf_rotation_wall_thickness
  color {{"parent.rotation.x * pi / 180.0"} {"parent.rotation.y * pi / 180.0"} {"parent.rotation.z * pi / 180.0"} {parent.wall_thickness}}
  format "1 1 0 0 1 1 1 1x1"
  name rotation
  xpos 403
  ypos 457
 }
 Copy {
  inputs 2
  channels all
  name Copy1
  xpos 403
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_dimensions
  color {{parent.dimensions.r} {parent.dimensions.g} {parent.dimensions.b} {parent.dimensions.a}}
  format "1 1 0 0 1 1 1 1x1"
  name dimensions
  xpos 540
  ypos 460
 }
 Copy {
  inputs 2
  channels all
  name Copy2
  xpos 540
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_colour
  color {{parent.colour.r} {parent.colour.g} {parent.colour.b} 0}
  format "1 1 0 0 1 1 1 1x1"
  name colour
  xpos 669
  ypos 459
 }
 Copy {
  inputs 2
  channels all
  name Copy3
  xpos 669
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_shape
  color {{parent.shape} {"parent.repetition_type | (parent.elongate ? 4 : 0) | (parent.mirror_x ? 8 : 0) | (parent.mirror_y ? 16 : 0) | (parent.mirror_z ? 32 : 0) | (parent.hollow ? 64 : 0) | (parent.blend_type > 0 ? (1 << (parent.blend_type + 6)) : 0)"} {"parent.sdf_merge.disable ? 0 : parent.sdf_merge.input1.width"} {parent.blend_strength}}
  format "1 1 0 0 1 1 1 1x1"
  name shape
  xpos 806
  ypos 462
 }
 Copy {
  inputs 2
  channels all
  name Copy4
  xpos 806
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_surface
  color {{parent.surface.r} {parent.surface.g} {parent.surface.b} {parent.surface.a}}
  format "1 1 0 0 1 1 1 1x1"
  name surface
  xpos 935
  ypos 460
 }
 Copy {
  inputs 2
  channels all
  name Copy5
  xpos 936
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_shape_mods_0
  color {{parent.repetition_params.r} {parent.repetition_params.g} {parent.repetition_params.b} {parent.repetition_params.a}}
  format "1 1 0 0 1 1 1 1x1"
  name shape_mods
  xpos 1056
  ypos 463
 }
 Copy {
  inputs 2
  channels all
  name Copy6
  xpos 1056
  ypos 726
 }
 Constant {
  inputs 0
  channels sdf_shape_mods_1
  color {{parent.elongation.x} {parent.elongation.y} {parent.elongation.z} {parent.edge_radius}}
  format "1 1 0 0 1 1 1 1x1"
  name shape_mods1
  xpos 1183
  ypos 465
 }
 Copy {
  inputs 2
  channels all
  name Copy7
  xpos 1183
  ypos 726
 }
 Group {
  inputs 2
  name sdf_merge
  xpos 1183
  ypos 822
  disable {{"\[exists parent.input0] ? 0 : 1"}}
  addUserKnob {20 User}
  addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
 }
  Reformat {
   inputs 0
   type "to box"
   box_width 1
   box_height 1
   box_fixed true
   name Reformat1
   xpos -119
   ypos 440
  }
  Input {
   inputs 0
   name Input2
   xpos 158
   ypos -28
   number 1
  }
  Dot {
   name Dot2
   xpos 192
   ypos -2
  }
set N8e37900 [stack 0]
  Dot {
   name Dot3
   xpos 329
   ypos -2
  }
  Dot {
   name Dot4
   xpos 329
   ypos 391
  }
  Input {
   inputs 0
   name Input1
   xpos 0
   ypos -32
  }
  Dot {
   name Dot1
   xpos 34
   ypos -6
  }
set N8e35d00 [stack 0]
  Dot {
   name Dot6
   xpos -98
   ypos -6
  }
  Dot {
   name Dot5
   xpos -98
   ypos 336
  }
push $N8e37900
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop3
   xpos 158
   ypos 69
  }
  Crop {
   box {0 0 {parent.Dot2.width} 1}
   name Crop4
   xpos 158
   ypos 95
  }
  Transform {
   translate {{parent.Dot1.width} 0}
   center {1 0.5}
   name Transform2
   xpos 158
   ypos 121
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop5
   xpos 158
   ypos 167
  }
push $N8e35d00
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop6
   xpos 0
   ypos 66
  }
  Crop {
   box {0 0 {parent.Dot1.width} 1}
   name Crop7
   xpos 0
   ypos 92
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop8
   xpos 0
   ypos 164
  }
  Merge2 {
   inputs 2
   also_merge all
   name Merge1
   xpos 0
   ypos 262
   disable {{"\[exists parent.input1] ? 0:1"}}
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input1] ? 0:1"}}
   name Switch2
   xpos 0
   ypos 332
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:1"}}
   name Switch1
   xpos 0
   ypos 387
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
   name Switch3
   xpos 0
   ypos 456
  }
  Dot {
   name out_dot
   xpos 36
   ypos 518
  }
  Output {
   name Output1
   xpos 2
   ypos 661
  }
 end_group
 Output {
  name Output1
  xpos 1183
  ypos 1002
 }
end_group
Group {
 inputs 2
 name sdf_merge1
 xpos 18615
 ypos 957
 addUserKnob {20 User}
 addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
}
 Reformat {
  inputs 0
  type "to box"
  box_width 1
  box_height 1
  box_fixed true
  name Reformat1
  xpos -119
  ypos 440
 }
 Input {
  inputs 0
  name Input2
  xpos 158
  ypos -28
  number 1
 }
 Dot {
  name Dot2
  xpos 192
  ypos -2
 }
set Nc0907900 [stack 0]
 Dot {
  name Dot3
  xpos 329
  ypos -2
 }
 Dot {
  name Dot4
  xpos 329
  ypos 391
 }
 Input {
  inputs 0
  name Input1
  xpos 0
  ypos -32
 }
 Dot {
  name Dot1
  xpos 34
  ypos -6
 }
set Nc0905d00 [stack 0]
 Dot {
  name Dot6
  xpos -98
  ypos -6
 }
 Dot {
  name Dot5
  xpos -98
  ypos 336
 }
push $Nc0907900
 Crop {
  box {0 0 {Dot1.width+Dot2.width} 1}
  reformat true
  crop false
  name Crop3
  xpos 158
  ypos 69
 }
 Crop {
  box {0 0 {parent.Dot2.width} 1}
  name Crop4
  xpos 158
  ypos 95
 }
 Transform {
  translate {{parent.Dot1.width} 0}
  center {1 0.5}
  name Transform2
  xpos 158
  ypos 121
 }
 Crop {
  box {0 0 {width} {height}}
  crop false
  name Crop5
  xpos 158
  ypos 167
 }
push $Nc0905d00
 Crop {
  box {0 0 {Dot1.width+Dot2.width} 1}
  reformat true
  crop false
  name Crop6
  xpos 0
  ypos 66
 }
 Crop {
  box {0 0 {parent.Dot1.width} 1}
  name Crop7
  xpos 0
  ypos 92
 }
 Crop {
  box {0 0 {width} {height}}
  crop false
  name Crop8
  xpos 0
  ypos 164
 }
 Merge2 {
  inputs 2
  also_merge all
  name Merge1
  xpos 0
  ypos 262
  disable {{"\[exists parent.input1] ? 0:1"}}
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input1] ? 0:1"}}
  name Switch2
  xpos 0
  ypos 332
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input0] ? 0:1"}}
  name Switch1
  xpos 0
  ypos 387
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
  name Switch3
  xpos 0
  ypos 456
 }
 Dot {
  name out_dot
  xpos 36
  ypos 518
 }
 Output {
  name Output1
  xpos 2
  ypos 661
 }
end_group
