#! /usr/local/Nuke13.0v2/libnuke-13.0.2.so -nx
version 13.0 v2
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="1976" y="188" w="2504" h="1376" maximized="1" screen="0">
        <splitter orientation="1">
            <split size="40"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="1841" stretch="1"/>
            <splitter orientation="2">
                <split size="783"/>
                <dock id="" activePageId="Viewer.1">
                    <page id="Viewer.1"/>
                </dock>
                <split size="550"/>
                <dock id="" activePageId="DAG.1" focus="true">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                    <page id="DAG.2"/>
                </dock>
            </splitter>
            <split size="615"/>
            <dock id="" activePageId="Properties.1">
                <page id="Properties.1"/>
                <page id="uk.co.thefoundry.backgroundrenderview.1"/>
            </dock>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name /home/ob1/software/nuke/dev/raymarch/nuke_scripts/raymarch_test.nk
 last_frame 479
 format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement Nuke
 workingSpaceLUT linear
 monitorLut sRGB
 monitorOutLUT rec709
 int8Lut sRGB
 int16Lut sRGB
 logLut Cineon
 floatLut linear
}
BackdropNode {
 inputs 0
 name lights
 xpos 18428
 ypos 511
 bdwidth 231
 bdheight 432
}
Group {
 inputs 0
 name sdf_light2
 xpos 18490
 ypos 721
 addUserKnob {20 User l "SDF LIght"}
 addUserKnob {4 type M {None Directional Point "Ambient Occlusion"}}
 type Point
 addUserKnob {13 dir_pos l direction/position}
 dir_pos {2 -0.2 0}
 addUserKnob {7 intensity}
 intensity 0.1
 addUserKnob {7 falloff R 0 5}
 falloff 4
 addUserKnob {18 colour}
 colour {1 1 1}
 addUserKnob {6 colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 shadow_hardness l "shadow hardness" R 1 100}
 shadow_hardness 75
 addUserKnob {6 soften_shadows l "soften shadows" -STARTLINE}
}
 Input {
  inputs 0
  name Input1
  xpos 922
  ypos 30
 }
 Dot {
  name Dot1
  xpos 956
  ypos 488
 }
add_layer {sdf_light sdf_light.light_pos_dir_x sdf_light.light_pos_dir_y sdf_light.light_pos_dir_z sdf_light.intensity}
 Constant {
  inputs 0
  channels sdf_light
  color {{parent.dir_pos.x} {parent.dir_pos.y} {parent.dir_pos.z} {parent.intensity}}
  format "1 1 0 0 1 1 1 1x1"
  name light
  xpos 434
  ypos 12
 }
 Dot {
  name Dot9
  xpos 468
  ypos 279
 }
add_layer {sdf_light_properties sdf_light_properties.colour_r sdf_light_properties.colour_g sdf_light_properties.colour_b sdf_light_properties.type}
 Constant {
  inputs 0
  channels sdf_light_properties
  color {{parent.colour.r} {parent.colour.g} {parent.colour.b} {"parent.soften_shadows ? -parent.type : parent.type"}}
  format "1 1 0 0 1 1 1 1x1"
  name light_props
  xpos 561
  ypos 12
 }
 Dot {
  name Dot6
  xpos 591
  ypos 282
 }
 Copy {
  inputs 2
  channels all
  name Copy1
  xpos 501
  ypos 380
 }
add_layer {sdf_light_properties1 sdf_light_properties1.shadow_hardness sdf_light_properties1.falloff}
 Constant {
  inputs 0
  channels sdf_light_properties1
  color {{parent.shadow_hardness} {parent.falloff} 0 0}
  format "1 1 0 0 1 1 1 1x1"
  name light_props1
  xpos 697
  ypos 12
 }
 Dot {
  name Dot2
  xpos 727
  ypos 282
 }
 Copy {
  inputs 2
  channels all
  name Copy2
  xpos 693
  ypos 380
 }
 Group {
  inputs 2
  name sdf_merge2
  xpos 693
  ypos 484
  disable {{"\[exists parent.input0] ? 0 : 1"}}
  addUserKnob {20 User}
  addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
 }
  Reformat {
   inputs 0
   type "to box"
   box_width 1
   box_height 1
   box_fixed true
   name Reformat1
   xpos -119
   ypos 440
  }
  Input {
   inputs 0
   name Input2
   xpos 158
   ypos -28
   number 1
  }
  Dot {
   name Dot2
   xpos 192
   ypos -2
  }
set N40672b00 [stack 0]
  Dot {
   name Dot3
   xpos 329
   ypos -2
  }
  Dot {
   name Dot4
   xpos 329
   ypos 391
  }
  Input {
   inputs 0
   name Input1
   xpos 0
   ypos -32
  }
  Dot {
   name Dot1
   xpos 34
   ypos -6
  }
set N40670f00 [stack 0]
  Dot {
   name Dot6
   xpos -98
   ypos -6
  }
  Dot {
   name Dot5
   xpos -98
   ypos 336
  }
push $N40672b00
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop3
   xpos 158
   ypos 69
  }
  Crop {
   box {0 0 {parent.Dot2.width} 1}
   name Crop4
   xpos 158
   ypos 95
  }
  Transform {
   translate {{parent.Dot1.width} 0}
   center {1 0.5}
   name Transform2
   xpos 158
   ypos 121
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop5
   xpos 158
   ypos 167
  }
push $N40670f00
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop6
   xpos 0
   ypos 66
  }
  Crop {
   box {0 0 {parent.Dot1.width} 1}
   name Crop7
   xpos 0
   ypos 92
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop8
   xpos 0
   ypos 164
  }
  Merge2 {
   inputs 2
   also_merge all
   name Merge1
   xpos 0
   ypos 262
   disable {{"\[exists parent.input1] ? 0:1"}}
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input1] ? 0:1"}}
   name Switch2
   xpos 0
   ypos 332
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:1"}}
   name Switch1
   xpos 0
   ypos 387
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
   name Switch3
   xpos 0
   ypos 456
  }
  Dot {
   name out_dot
   xpos 36
   ypos 518
  }
  Output {
   name Output1
   xpos 2
   ypos 661
  }
 end_group
 Output {
  name Output1
  xpos 693
  ypos 562
 }
end_group
Group {
 name sdf_light3
 xpos 18490
 ypos 779
 addUserKnob {20 User l "SDF LIght"}
 addUserKnob {4 type M {None Directional Point "Ambient Occlusion"}}
 type Point
 addUserKnob {13 dir_pos l direction/position}
 dir_pos {2 0.2 0}
 addUserKnob {7 intensity}
 intensity 0.1
 addUserKnob {7 falloff R 0 5}
 falloff 4
 addUserKnob {18 colour}
 colour {1 1 1}
 addUserKnob {6 colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 shadow_hardness l "shadow hardness" R 1 100}
 shadow_hardness 50
 addUserKnob {6 soften_shadows l "soften shadows" -STARTLINE}
}
 Input {
  inputs 0
  name Input1
  xpos 922
  ypos 30
 }
 Dot {
  name Dot1
  xpos 956
  ypos 488
 }
 Constant {
  inputs 0
  channels sdf_light
  color {{parent.dir_pos.x} {parent.dir_pos.y} {parent.dir_pos.z} {parent.intensity}}
  format "1 1 0 0 1 1 1 1x1"
  name light
  xpos 434
  ypos 12
 }
 Dot {
  name Dot9
  xpos 468
  ypos 279
 }
 Constant {
  inputs 0
  channels sdf_light_properties
  color {{parent.colour.r} {parent.colour.g} {parent.colour.b} {"parent.soften_shadows ? -parent.type : parent.type"}}
  format "1 1 0 0 1 1 1 1x1"
  name light_props
  xpos 561
  ypos 12
 }
 Dot {
  name Dot6
  xpos 591
  ypos 282
 }
 Copy {
  inputs 2
  channels all
  name Copy1
  xpos 501
  ypos 380
 }
 Constant {
  inputs 0
  channels sdf_light_properties1
  color {{parent.shadow_hardness} {parent.falloff} 0 0}
  format "1 1 0 0 1 1 1 1x1"
  name light_props1
  xpos 697
  ypos 12
 }
 Dot {
  name Dot2
  xpos 727
  ypos 282
 }
 Copy {
  inputs 2
  channels all
  name Copy2
  xpos 693
  ypos 380
 }
 Group {
  inputs 2
  name sdf_merge2
  xpos 693
  ypos 484
  disable {{"\[exists parent.input0] ? 0 : 1"}}
  addUserKnob {20 User}
  addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
 }
  Reformat {
   inputs 0
   type "to box"
   box_width 1
   box_height 1
   box_fixed true
   name Reformat1
   xpos -119
   ypos 440
  }
  Input {
   inputs 0
   name Input2
   xpos 158
   ypos -28
   number 1
  }
  Dot {
   name Dot2
   xpos 192
   ypos -2
  }
set N405d5600 [stack 0]
  Dot {
   name Dot3
   xpos 329
   ypos -2
  }
  Dot {
   name Dot4
   xpos 329
   ypos 391
  }
  Input {
   inputs 0
   name Input1
   xpos 0
   ypos -32
  }
  Dot {
   name Dot1
   xpos 34
   ypos -6
  }
set N405af900 [stack 0]
  Dot {
   name Dot6
   xpos -98
   ypos -6
  }
  Dot {
   name Dot5
   xpos -98
   ypos 336
  }
push $N405d5600
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop3
   xpos 158
   ypos 69
  }
  Crop {
   box {0 0 {parent.Dot2.width} 1}
   name Crop4
   xpos 158
   ypos 95
  }
  Transform {
   translate {{parent.Dot1.width} 0}
   center {1 0.5}
   name Transform2
   xpos 158
   ypos 121
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop5
   xpos 158
   ypos 167
  }
push $N405af900
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop6
   xpos 0
   ypos 66
  }
  Crop {
   box {0 0 {parent.Dot1.width} 1}
   name Crop7
   xpos 0
   ypos 92
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop8
   xpos 0
   ypos 164
  }
  Merge2 {
   inputs 2
   also_merge all
   name Merge1
   xpos 0
   ypos 262
   disable {{"\[exists parent.input1] ? 0:1"}}
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input1] ? 0:1"}}
   name Switch2
   xpos 0
   ypos 332
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:1"}}
   name Switch1
   xpos 0
   ypos 387
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
   name Switch3
   xpos 0
   ypos 456
  }
  Dot {
   name out_dot
   xpos 36
   ypos 518
  }
  Output {
   name Output1
   xpos 2
   ypos 661
  }
 end_group
 Output {
  name Output1
  xpos 693
  ypos 562
 }
end_group
Read {
 inputs 0
 file_type exr
 file /home/ob1/software/nuke/dev/raymarch/images/ninomaru_teien_4k.exr
 format "4096 2048 0 0 4096 2048 1 4K_LatLong"
 origset true
 auto_alpha true
 name Read14
 xpos 18791
 ypos 791
}
Read {
 inputs 0
 file_type exr
 file /home/ob1/software/nuke/dev/raymarch/images/studio_small_02_4k.exr
 format "4096 2048 0 0 4096 2048 1 4K_LatLong"
 origset true
 name Read2
 xpos 19035
 ypos 789
}
Group {
 inputs 0
 name sdf_light1
 xpos 18490
 ypos 844
 addUserKnob {20 User l "SDF LIght"}
 addUserKnob {4 type M {None Directional Point "Ambient Occlusion"}}
 type Point
 addUserKnob {13 dir_pos l direction/position}
 dir_pos {0.5 0.75 0.75}
 addUserKnob {7 intensity}
 intensity 100
 addUserKnob {7 falloff R 0 5}
 falloff 4
 addUserKnob {18 colour}
 colour {1 0 0}
 addUserKnob {6 colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 shadow_hardness l "shadow hardness" R 1 100}
 shadow_hardness 11
 addUserKnob {6 soften_shadows l "soften shadows" -STARTLINE}
}
 Input {
  inputs 0
  name Input1
  xpos 922
  ypos 30
 }
 Dot {
  name Dot1
  xpos 956
  ypos 488
 }
 Constant {
  inputs 0
  channels sdf_light
  color {{parent.dir_pos.x} {parent.dir_pos.y} {parent.dir_pos.z} {parent.intensity}}
  format "1 1 0 0 1 1 1 1x1"
  name light
  xpos 434
  ypos 12
 }
 Dot {
  name Dot9
  xpos 468
  ypos 279
 }
 Constant {
  inputs 0
  channels sdf_light_properties
  color {{parent.colour.r} {parent.colour.g} {parent.colour.b} {"parent.soften_shadows ? -parent.type : parent.type"}}
  format "1 1 0 0 1 1 1 1x1"
  name light_props
  xpos 561
  ypos 12
 }
 Dot {
  name Dot6
  xpos 591
  ypos 282
 }
 Copy {
  inputs 2
  channels all
  name Copy1
  xpos 501
  ypos 380
 }
 Constant {
  inputs 0
  channels sdf_light_properties1
  color {{parent.shadow_hardness} {parent.falloff} 0 0}
  format "1 1 0 0 1 1 1 1x1"
  name light_props1
  xpos 697
  ypos 12
 }
 Dot {
  name Dot2
  xpos 727
  ypos 282
 }
 Copy {
  inputs 2
  channels all
  name Copy2
  xpos 693
  ypos 380
 }
 Group {
  inputs 2
  name sdf_merge2
  xpos 693
  ypos 484
  disable {{"\[exists parent.input0] ? 0 : 1"}}
  addUserKnob {20 User}
  addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
 }
  Reformat {
   inputs 0
   type "to box"
   box_width 1
   box_height 1
   box_fixed true
   name Reformat1
   xpos -119
   ypos 440
  }
  Input {
   inputs 0
   name Input2
   xpos 158
   ypos -28
   number 1
  }
  Dot {
   name Dot2
   xpos 192
   ypos -2
  }
set Na00e6400 [stack 0]
  Dot {
   name Dot3
   xpos 329
   ypos -2
  }
  Dot {
   name Dot4
   xpos 329
   ypos 391
  }
  Input {
   inputs 0
   name Input1
   xpos 0
   ypos -32
  }
  Dot {
   name Dot1
   xpos 34
   ypos -6
  }
set Na00e4800 [stack 0]
  Dot {
   name Dot6
   xpos -98
   ypos -6
  }
  Dot {
   name Dot5
   xpos -98
   ypos 336
  }
push $Na00e6400
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop3
   xpos 158
   ypos 69
  }
  Crop {
   box {0 0 {parent.Dot2.width} 1}
   name Crop4
   xpos 158
   ypos 95
  }
  Transform {
   translate {{parent.Dot1.width} 0}
   center {1 0.5}
   name Transform2
   xpos 158
   ypos 121
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop5
   xpos 158
   ypos 167
  }
push $Na00e4800
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop6
   xpos 0
   ypos 66
  }
  Crop {
   box {0 0 {parent.Dot1.width} 1}
   name Crop7
   xpos 0
   ypos 92
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop8
   xpos 0
   ypos 164
  }
  Merge2 {
   inputs 2
   also_merge all
   name Merge1
   xpos 0
   ypos 262
   disable {{"\[exists parent.input1] ? 0:1"}}
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input1] ? 0:1"}}
   name Switch2
   xpos 0
   ypos 332
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:1"}}
   name Switch1
   xpos 0
   ypos 387
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
   name Switch3
   xpos 0
   ypos 456
  }
  Dot {
   name out_dot
   xpos 36
   ypos 518
  }
  Output {
   name Output1
   xpos 2
   ypos 661
  }
 end_group
 Output {
  name Output1
  xpos 693
  ypos 562
 }
end_group
Group {
 name sdf_light
 xpos 18490
 ypos 902
 addUserKnob {20 User l "SDF LIght"}
 addUserKnob {4 type M {None Directional Point "Ambient Occlusion"}}
 type Point
 addUserKnob {13 dir_pos l direction/position}
 dir_pos {-0.5 0.75 0.75}
 addUserKnob {7 intensity}
 intensity 1000
 addUserKnob {7 falloff R 0 5}
 falloff 4
 addUserKnob {18 colour}
 colour {0 1 0}
 addUserKnob {6 colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 shadow_hardness l "shadow hardness" R 1 100}
 shadow_hardness 8.5
 addUserKnob {6 soften_shadows l "soften shadows" -STARTLINE}
}
 Input {
  inputs 0
  name Input1
  xpos 922
  ypos 30
 }
 Dot {
  name Dot1
  xpos 956
  ypos 488
 }
 Constant {
  inputs 0
  channels sdf_light
  color {{parent.dir_pos.x} {parent.dir_pos.y} {parent.dir_pos.z} {parent.intensity}}
  format "1 1 0 0 1 1 1 1x1"
  name light
  xpos 434
  ypos 12
 }
 Dot {
  name Dot9
  xpos 468
  ypos 279
 }
 Constant {
  inputs 0
  channels sdf_light_properties
  color {{parent.colour.r} {parent.colour.g} {parent.colour.b} {"parent.soften_shadows ? -parent.type : parent.type"}}
  format "1 1 0 0 1 1 1 1x1"
  name light_props
  xpos 561
  ypos 12
 }
 Dot {
  name Dot6
  xpos 591
  ypos 282
 }
 Copy {
  inputs 2
  channels all
  name Copy1
  xpos 501
  ypos 380
 }
 Constant {
  inputs 0
  channels sdf_light_properties1
  color {{parent.shadow_hardness} {parent.falloff} 0 0}
  format "1 1 0 0 1 1 1 1x1"
  name light_props1
  xpos 697
  ypos 12
 }
 Dot {
  name Dot2
  xpos 727
  ypos 282
 }
 Copy {
  inputs 2
  channels all
  name Copy2
  xpos 693
  ypos 380
 }
 Group {
  inputs 2
  name sdf_merge2
  xpos 693
  ypos 484
  disable {{"\[exists parent.input0] ? 0 : 1"}}
  addUserKnob {20 User}
  addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
 }
  Reformat {
   inputs 0
   type "to box"
   box_width 1
   box_height 1
   box_fixed true
   name Reformat1
   xpos -119
   ypos 440
  }
  Input {
   inputs 0
   name Input2
   xpos 158
   ypos -28
   number 1
  }
  Dot {
   name Dot2
   xpos 192
   ypos -2
  }
set Na0054f00 [stack 0]
  Dot {
   name Dot3
   xpos 329
   ypos -2
  }
  Dot {
   name Dot4
   xpos 329
   ypos 391
  }
  Input {
   inputs 0
   name Input1
   xpos 0
   ypos -32
  }
  Dot {
   name Dot1
   xpos 34
   ypos -6
  }
set Na002f200 [stack 0]
  Dot {
   name Dot6
   xpos -98
   ypos -6
  }
  Dot {
   name Dot5
   xpos -98
   ypos 336
  }
push $Na0054f00
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop3
   xpos 158
   ypos 69
  }
  Crop {
   box {0 0 {parent.Dot2.width} 1}
   name Crop4
   xpos 158
   ypos 95
  }
  Transform {
   translate {{parent.Dot1.width} 0}
   center {1 0.5}
   name Transform2
   xpos 158
   ypos 121
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop5
   xpos 158
   ypos 167
  }
push $Na002f200
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop6
   xpos 0
   ypos 66
  }
  Crop {
   box {0 0 {parent.Dot1.width} 1}
   name Crop7
   xpos 0
   ypos 92
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop8
   xpos 0
   ypos 164
  }
  Merge2 {
   inputs 2
   also_merge all
   name Merge1
   xpos 0
   ypos 262
   disable {{"\[exists parent.input1] ? 0:1"}}
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input1] ? 0:1"}}
   name Switch2
   xpos 0
   ypos 332
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:1"}}
   name Switch1
   xpos 0
   ypos 387
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
   name Switch3
   xpos 0
   ypos 456
  }
  Dot {
   name out_dot
   xpos 36
   ypos 518
  }
  Output {
   name Output1
   xpos 2
   ypos 661
  }
 end_group
 Output {
  name Output1
  xpos 693
  ypos 562
 }
end_group
Read {
 inputs 0
 file_type exr
 file /home/ob1/software/nuke/dev/raymarch/images/kloppenheim_02_4k.exr
 format "4096 2048 0 0 4096 2048 1 4K_LatLong"
 origset true
 auto_alpha true
 name Read1
 xpos 18921
 ypos 794
}
Reformat {
 format "2048 1024 0 0 2048 1024 1 2K_LatLong"
 scale 0.25
 resize fill
 center false
 name Reformat1
 xpos 18921
 ypos 912
}
Dot {
 name Dot19
 xpos 18955
 ypos 998
}
Axis2 {
 inputs 0
 name Axis2
 xpos 18685
 ypos 792
}
Camera3 {
 translate {0 0 3}
 name Camera1
 xpos 18685
 ypos 891
}
Dot {
 name Dot18
 xpos 18709
 ypos 1001
}
push 0
Group {
 inputs 0
 name sdf_primitive
 onCreate "__import__('sdf.sdf_primitive', fromlist='SDFPrimitive').SDFPrimitive.handle_node_created()"
 knobChanged "__import__('sdf.sdf_primitive', fromlist='SDFPrimitive').SDFPrimitive.handle_knob_changed()"
 xpos 18311
 ypos 1091
 addUserKnob {20 User l "SDF Primitive"}
 addUserKnob {4 shape M {sphere ellipsoid "cut sphere" "hollow sphere" "death star" "solid angle" "rectangular prism" "rectangular prism frame" rhombus "triangular prism" cylinder "infinite cylinder" plane capsule cone "infinite cone" "capped cone" "rounded cone" torus "capped torus" link "hexagonal prism" octahedron mandelbulb ""}}
 shape rhombus
 addUserKnob {7 dimension_x l width t "The width (x) of the rhombus." R 0 10}
 dimension_x 0.5
 addUserKnob {7 dimension_y l height t "The height (y) of the rhombus."}
 dimension_y 0.75
 addUserKnob {7 dimension_z l depth t "The depth (z) of the rhombus, this the extruded dimension, or thickness."}
 dimension_z 0.25
 addUserKnob {7 dimension_w l "corner radius" t "The radius of the corners of the rhombus' xy-plane parallel  face."}
 dimension_w 0.05
 addUserKnob {7 wall_thickness l "wall thickness" +DISABLED}
 wall_thickness 0.001
 addUserKnob {6 hollow t "If true, the object will be hollow, with a thickness of 'Wall Thickness'" -STARTLINE}
 addUserKnob {7 edge_radius l "edge radius"}
 addUserKnob {6 mirror_x l "mirror x" +STARTLINE}
 addUserKnob {6 mirror_y l "mirror y" -STARTLINE}
 addUserKnob {6 mirror_z l "mirror z" -STARTLINE}
 addUserKnob {6 is_bound l "is bound" +DISABLED +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {18 colour}
 colour {1 1 1}
 addUserKnob {6 colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 reflection}
 addUserKnob {7 transmission}
 addUserKnob {7 refractive_index l "refractive index" R 1 4}
 refractive_index 1.33
 addUserKnob {7 roughness t "Scatter the light more the higher this value is.\nIncrease the \"Pixel Subdivisions\" to clean up the noise."}
 addUserKnob {7 emission}
 addUserKnob {26 div0 l "" +STARTLINE}
 addUserKnob {13 translate}
 addUserKnob {13 rotate}
 addUserKnob {13 elongation +DISABLED}
 elongation {0.1 0 0}
 addUserKnob {6 elongate -STARTLINE}
 addUserKnob {7 uniform_scale l "uniform scale" R 0 10}
 uniform_scale 1
 addUserKnob {26 div1 l "" +STARTLINE}
 addUserKnob {19 repetition_params l repetition}
 repetition_params {0 0 0 0}
 addUserKnob {6 repetition_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {4 repetition_type l type -STARTLINE M {None Finite Infinite "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {7 blend_strength l "blend strength" +DISABLED}
 blend_strength 0.11
 addUserKnob {4 blend_type l "blend type" -STARTLINE +DISABLED M {Union Subtraction Intersection "Smooth Union" "Smooth Subtraction" "Smooth Intersection" ""}}
}
 Input {
  inputs 0
  name siblings
  xpos 1484
  ypos 476
 }
 Dot {
  name Dot2
  xpos 1518
  ypos 904
 }
 Input {
  inputs 0
  name children
  xpos 1357
  ypos 475
  number 1
 }
 Dot {
  name Dot1
  xpos 1391
  ypos 826
 }
add_layer {sdf_position_scale sdf_position_scale.position_x sdf_position_scale.position_y sdf_position_scale.position_z sdf_position_scale.uniform_scale}
 Constant {
  inputs 0
  channels sdf_position_scale
  color {{parent.translate.x} {parent.translate.y} {parent.translate.z} {parent.uniform_scale}}
  format "1 1 0 0 1 1 1 1x1"
  name position_scale
  xpos 280
  ypos 455
 }
 Dot {
  name Dot17
  xpos 314
  ypos 647
 }
add_layer {sdf_rotation_wall_thickness sdf_rotation_wall_thickness.rotation_x sdf_rotation_wall_thickness.rotation_y sdf_rotation_wall_thickness.rotation_z sdf_rotation_wall_thickness.wall_thickness}
 Constant {
  inputs 0
  channels sdf_rotation_wall_thickness
  color {{"parent.rotate.x * pi / 180"} {"parent.rotate.y * pi / 180"} {"parent.rotate.z * pi / 180"} {parent.wall_thickness}}
  format "1 1 0 0 1 1 1 1x1"
  name rotation
  xpos 403
  ypos 457
 }
 Copy {
  inputs 2
  channels all
  name Copy1
  xpos 403
  ypos 726
 }
add_layer {sdf_dimensions sdf_dimensions.dimension_x sdf_dimensions.dimension_y sdf_dimensions.dimension_z sdf_dimensions.dimension_w}
 Constant {
  inputs 0
  channels sdf_dimensions
  color {{parent.dimension_x} {parent.dimension_y} {parent.dimension_z} {parent.dimension_w}}
  format "1 1 0 0 1 1 1 1x1"
  name dimensions
  xpos 540
  ypos 460
 }
 Copy {
  inputs 2
  channels all
  name Copy2
  xpos 540
  ypos 726
 }
add_layer {sdf_colour sdf_colour.colour_r sdf_colour.colour_g sdf_colour.colour_b sdf_colour.colour_a}
 Constant {
  inputs 0
  channels sdf_colour
  color {{parent.colour.r} {parent.colour.g} {parent.colour.b} {parent.refractive_index}}
  format "1 1 0 0 1 1 1 1x1"
  name colour
  xpos 669
  ypos 459
 }
 Copy {
  inputs 2
  channels all
  name Copy3
  xpos 669
  ypos 726
 }
add_layer {sdf_shape sdf_shape.shape_type sdf_shape.shape_operations sdf_shape.num_children sdf_shape.blend_strength}
 Constant {
  inputs 0
  channels sdf_shape
  color {{parent.shape} {"parent.repetition_type | (parent.elongate ? 4 : 0) | (parent.mirror_x ? 8 : 0) | (parent.mirror_y ? 16 : 0) | (parent.mirror_z ? 32 : 0) | (parent.hollow ? 64 : 0) | (parent.blend_type > 0 ? (1 << (parent.blend_type + 6)) : 0) | (parent.is_bound ? 4096 : 0)"} {"parent.sdf_merge.disable ? 0 : parent.sdf_merge.input1.width"} {parent.blend_strength}}
  format "1 1 0 0 1 1 1 1x1"
  name shape
  xpos 806
  ypos 462
 }
 Copy {
  inputs 2
  channels all
  name Copy4
  xpos 806
  ypos 726
 }
add_layer {sdf_surface sdf_surface.reflection sdf_surface.transmission sdf_surface.emission sdf_surface.roughness}
 Constant {
  inputs 0
  channels sdf_surface
  color {{parent.reflection} {parent.transmission} {parent.emission} {parent.roughness}}
  format "1 1 0 0 1 1 1 1x1"
  name surface
  xpos 935
  ypos 460
 }
 Copy {
  inputs 2
  channels all
  name Copy5
  xpos 936
  ypos 726
 }
add_layer {sdf_shape_mods_0 sdf_shape_mods_0.repetion_x sdf_shape_mods_0.repetion_y sdf_shape_mods_0.repetion_z sdf_shape_mods_0.repetion_w}
 Constant {
  inputs 0
  channels sdf_shape_mods_0
  color {{parent.repetition_params.r} {parent.repetition_params.g} {parent.repetition_params.b} {parent.repetition_params.a}}
  format "1 1 0 0 1 1 1 1x1"
  name shape_mods
  xpos 1056
  ypos 463
 }
 Copy {
  inputs 2
  channels all
  name Copy6
  xpos 1056
  ypos 726
 }
add_layer {sdf_shape_mods_1 sdf_shape_mods_1.elongation_x sdf_shape_mods_1.elongation_y sdf_shape_mods_1.elongation_z sdf_shape_mods_1.edge_radius}
 Constant {
  inputs 0
  channels sdf_shape_mods_1
  color {{parent.elongation.x} {parent.elongation.y} {parent.elongation.z} {parent.edge_radius}}
  format "1 1 0 0 1 1 1 1x1"
  name shape_mods1
  xpos 1183
  ypos 465
 }
 Copy {
  inputs 2
  channels all
  name Copy7
  xpos 1183
  ypos 726
 }
 Group {
  inputs 2
  name sdf_merge
  xpos 1183
  ypos 822
  disable {{"\[exists parent.input1] ? 0 : 1"}}
  addUserKnob {20 User}
  addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
 }
  Reformat {
   inputs 0
   type "to box"
   box_width 1
   box_height 1
   box_fixed true
   name Reformat1
   xpos -119
   ypos 440
  }
  Input {
   inputs 0
   name Input2
   xpos 158
   ypos -28
   number 1
  }
  Dot {
   name Dot2
   xpos 192
   ypos -2
  }
set N55cc0f00 [stack 0]
  Dot {
   name Dot3
   xpos 329
   ypos -2
  }
  Dot {
   name Dot4
   xpos 329
   ypos 391
  }
  Input {
   inputs 0
   name Input1
   xpos 0
   ypos -32
  }
  Dot {
   name Dot1
   xpos 34
   ypos -6
  }
set N6c1bf200 [stack 0]
  Dot {
   name Dot6
   xpos -98
   ypos -6
  }
  Dot {
   name Dot5
   xpos -98
   ypos 336
  }
push $N55cc0f00
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop3
   xpos 158
   ypos 69
  }
  Crop {
   box {0 0 {parent.Dot2.width} 1}
   name Crop4
   xpos 158
   ypos 95
  }
  Transform {
   translate {{parent.Dot1.width} 0}
   center {1 0.5}
   name Transform2
   xpos 158
   ypos 121
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop5
   xpos 158
   ypos 167
  }
push $N6c1bf200
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop6
   xpos 0
   ypos 66
  }
  Crop {
   box {0 0 {parent.Dot1.width} 1}
   name Crop7
   xpos 0
   ypos 92
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop8
   xpos 0
   ypos 164
  }
  Merge2 {
   inputs 2
   also_merge all
   name Merge1
   xpos 0
   ypos 262
   disable {{"\[exists parent.input1] ? 0:1"}}
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input1] ? 0:1"}}
   name Switch2
   xpos 0
   ypos 332
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:1"}}
   name Switch1
   xpos 0
   ypos 387
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
   name Switch3
   xpos 0
   ypos 456
  }
  Dot {
   name out_dot
   xpos 36
   ypos 518
  }
  Output {
   name Output1
   xpos 2
   ypos 661
  }
 end_group
 Group {
  inputs 2
  name sdf_merge1
  xpos 1183
  ypos 900
  disable {{"\[exists parent.input0] ? 0 : 1"}}
  addUserKnob {20 User}
  addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
 }
  Reformat {
   inputs 0
   type "to box"
   box_width 1
   box_height 1
   box_fixed true
   name Reformat1
   xpos -119
   ypos 440
  }
  Input {
   inputs 0
   name Input2
   xpos 158
   ypos -28
   number 1
  }
  Dot {
   name Dot2
   xpos 192
   ypos -2
  }
set N6c162b00 [stack 0]
  Dot {
   name Dot3
   xpos 329
   ypos -2
  }
  Dot {
   name Dot4
   xpos 329
   ypos 391
  }
  Input {
   inputs 0
   name Input1
   xpos 0
   ypos -32
  }
  Dot {
   name Dot1
   xpos 34
   ypos -6
  }
set N6c160f00 [stack 0]
  Dot {
   name Dot6
   xpos -98
   ypos -6
  }
  Dot {
   name Dot5
   xpos -98
   ypos 336
  }
push $N6c162b00
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop3
   xpos 158
   ypos 69
  }
  Crop {
   box {0 0 {parent.Dot2.width} 1}
   name Crop4
   xpos 158
   ypos 95
  }
  Transform {
   translate {{parent.Dot1.width} 0}
   center {1 0.5}
   name Transform2
   xpos 158
   ypos 121
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop5
   xpos 158
   ypos 167
  }
push $N6c160f00
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop6
   xpos 0
   ypos 66
  }
  Crop {
   box {0 0 {parent.Dot1.width} 1}
   name Crop7
   xpos 0
   ypos 92
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop8
   xpos 0
   ypos 164
  }
  Merge2 {
   inputs 2
   also_merge all
   name Merge1
   xpos 0
   ypos 262
   disable {{"\[exists parent.input1] ? 0:1"}}
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input1] ? 0:1"}}
   name Switch2
   xpos 0
   ypos 332
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:1"}}
   name Switch1
   xpos 0
   ypos 387
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
   name Switch3
   xpos 0
   ypos 456
  }
  Dot {
   name out_dot
   xpos 36
   ypos 518
  }
  Output {
   name Output1
   xpos 2
   ypos 661
  }
 end_group
 Output {
  name Output1
  xpos 1183
  ypos 1002
 }
end_group
Group {
 inputs 4
 name ray_march
 xpos 18311
 ypos 1223
 addUserKnob {20 User l "Ray March"}
 addUserKnob {3 pixel_subdivisions l "pixel subdivisions" t "Subdivide the pixel and cast a ray for each subdivision, resulting in 2^subdivisions rays"}
 addUserKnob {3 max_rays_per_subpixel l "max rays per subpixel"}
 max_rays_per_subpixel 10
 addUserKnob {3 max_bounces l "max bounces" t "Rays will reflect this many times before they are stopped"}
 max_bounces 1
 addUserKnob {7 ray_distance l "max ray distance" R 10 10000}
 ray_distance 20
 addUserKnob {3 max_ray_steps l "max ray steps"}
 max_ray_steps 1000
 addUserKnob {7 hit_tolerance l "hit tolerance" t "The ray will be considered to have hit an object when it is within this distance of its surface" R 1e-06 0.01}
 hit_tolerance 0.001
 addUserKnob {3 diffuse_lighting_samples l "diffuse lighting samples"}
 diffuse_lighting_samples 3
 addUserKnob {7 shadow_bias l "shadow bias" t "The surface will be offset by an additional factor of this amount before determining if it is in shadow" R 1 2}
 shadow_bias 1
 addUserKnob {26 ""}
 addUserKnob {7 refractive_index l "refractive index" R 1 4}
 refractive_index 1
 addUserKnob {26 ""}
 addUserKnob {7 haze l "haze amount"}
 addUserKnob {7 haze_start l "haze start"}
 haze_start 2
 addUserKnob {7 haze_distance l "haze distance"}
 haze_distance 3
 addUserKnob {19 haze_colour l "haze colour"}
 haze_colour {1 1 1 0}
 addUserKnob {6 haze_colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 ""}
 addUserKnob {7 iter_glow l "iter glow" t "The more steps it takes to compute a pixel the more it will glow" R 0 0.1}
 addUserKnob {19 iter_glow_colour l "iter glow colour"}
 iter_glow_colour {1 1 1 0}
 addUserKnob {6 iter_glow_colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 ""}
 addUserKnob {7 skybox_offset_angle l "skybox offset angle" R 0 360}
 skybox_offset_angle 252
 addUserKnob {7 skybox_lighting_gain l "skybox lighting gain"}
 skybox_lighting_gain 1
 addUserKnob {7 skybox_shadow_hardness l "skybox shadow hardness" R 1 100}
 skybox_shadow_hardness 1
 addUserKnob {7 skybox_lighting_blur l "skybox lighting blur"}
 skybox_lighting_blur 0.5
 addUserKnob {6 soften_shadows l "soften shadows" -STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {4 output_type l output M {Scene Position Normal Depth ""}}
}
 BackdropNode {
  inputs 0
  name Lights
  xpos -306
  ypos -1633
  bdwidth 386
  bdheight 854
 }
 BackdropNode {
  inputs 0
  name Objects
  xpos 99
  ypos -1632
  bdwidth 1184
  bdheight 855
 }
 Input {
  inputs 0
  name camera
  xpos 1354
  ypos -1578
  number 2
 }
 Camera {
  projection_mode {{"\[expression \[value the_cam]projection_mode(\[value the_frame])]"}}
  focal {{"\[expression \[value the_cam]focal(\[value the_frame])]"}}
  haperture {{"\[expression \[value the_cam]haperture(\[value the_frame])]"}}
  vaperture {{"\[expression \[value the_cam]vaperture(\[value the_frame])]"}}
  near {{"\[expression \[value the_cam]near(\[value the_frame])]"}}
  far {{"\[expression \[value the_cam]far(\[value the_frame])]"}}
  win_translate {{"\[expression \[value the_cam]win_translate.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_translate.v(\[value the_frame])]"}}
  win_scale {{"\[expression \[value the_cam]win_scale.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_scale.v(\[value the_frame])]"}}
  winroll {{"\[expression \[value the_cam]winroll(\[value the_frame])]"}}
  focal_point {{"\[expression \[value the_cam]focal_point(\[value the_frame])]"}}
  fstop {{"\[expression \[value the_cam]fstop(\[value the_frame])]"}}
  name DummyCam
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if no Camera connected. Can also be used inside of groups and gizmos, as many levels deep as you want :D All using live and super fast TCL.\n\nUpdated v1.1: Now grabs the correct frame too (thanks Erwan Leroy for the idea).\n\nUpdated v1.3: Now accepts Nuke13's Camera3\n\nadrianpueyo.com, 2019-2021"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  xpos 1364
  ypos -1473
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\n#DummyCam v1.3 - Updated 5 May 2021.\nset starting_point \"this.input0\"\nset default \"this.d_\"\n\n# If cam has no inputs, return the default.\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera3\" && \[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera3\"||\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{ \[class \$x]==\"Input\" \} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{ \[exists \$inp] \} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {43 the_frame +INVISIBLE}
  the_frame "\[\nset the_camera \[string trimright \[value the_cam] .]\nif \{\[exists \$the_camera]\} \{\n    return \[value \$the_camera.frame]\n\} \{ \n    return \[frame]\n\}\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l "focal length" R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {30 d_win_translate l "window translate"}
  addUserKnob {30 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 version l " " t "Updated 5 May 2021" T "<span style=\"color:#666\"><br/><b>DummyCam v1.3</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019-2021</span>"}
 }
 Constant {
  inputs 0
  format "2 1 0 0 2 1 1 lights"
  name Constant3
  xpos 1551
  ypos -1546
 }
 Input {
  inputs 0
  name sky
  xpos 1661
  ypos -1577
  number 3
 }
 Merge2 {
  inputs 2
  name Merge1
  xpos 1661
  ypos -1523
 }
 Dot {
  name sky_dot
  xpos 1695
  ypos -1474
 }
set N6c0f4800 [stack 0]
 Blur {
  size {{"parent.skybox_lighting_blur * sky_dot.format.height / 2"}}
  name Blur
  xpos 1878
  ypos -1484
 }
 Reformat {
  type scale
  scale {{"floor(min(parent.sky_dot.height, parent.sky_dot.width) / 8) > 0 ? 1/8 : 1"}}
  resize fill
  name Reformat
  xpos 1878
  ypos -1432
 }
 Dot {
  name sky_light_dot
  xpos 1912
  ypos -1362
 }
 Constant {
  inputs 0
  channels sdf_light
  format "1 1 0 0 1 1 1 1x1"
  name Constant4
  xpos -278
  ypos -1547
 }
 Input {
  inputs 0
  name lights
  xpos -82
  ypos -1575
  number 1
 }
 Merge2 {
  inputs 2
  name Merge3
  xpos -82
  ypos -1518
 }
 Dot {
  name light_dot
  xpos -48
  ypos -1309
 }
set N84114f00 [stack 0]
 Shuffle {
  in sdf_light_properties1
  blue green
  alpha green
  name light_props1
  xpos -266
  ypos -1040
 }
 Dot {
  name Dot1
  xpos -232
  ypos -866
 }
push $N84114f00
 Shuffle {
  in sdf_light_properties
  name light_props
  xpos -147
  ypos -1040
 }
 Dot {
  name Dot8
  xpos -113
  ypos -864
 }
push $N84114f00
 Shuffle {
  in sdf_light
  name light
  xpos -31
  ypos -1040
 }
 Dot {
  name Dot7
  xpos 3
  ypos -862
 }
 Constant {
  inputs 0
  channels sdf_position_scale
  format "1 1 0 0 1 1 1 1x1"
  name Constant2
  xpos 411
  ypos -1545
 }
 Input {
  inputs 0
  name objects
  xpos 607
  ypos -1567
 }
 Merge2 {
  inputs 2
  name Merge2
  xpos 607
  ypos -1516
 }
 Dot {
  name obj_dot
  xpos 641
  ypos -1318
 }
set N840e8100 [stack 0]
 Shuffle {
  in sdf_surface
  name surface
  xpos 288
  ypos -1034
 }
 Dot {
  name Dot2
  xpos 322
  ypos -863
 }
push $N840e8100
 Shuffle {
  in sdf_shape_mods_1
  name shape_mods_1
  xpos 746
  ypos -1030
 }
 Dot {
  name Dot12
  xpos 780
  ypos -865
 }
push $N840e8100
 Shuffle {
  in sdf_shape_mods_0
  name shape_mods_0
  xpos 607
  ypos -1031
 }
 Dot {
  name Dot3
  xpos 641
  ypos -864
 }
push $N840e8100
 Shuffle {
  in sdf_shape
  name shape
  xpos 439
  ypos -1035
 }
 Dot {
  name Dot4
  xpos 473
  ypos -863
 }
push $N840e8100
 Shuffle {
  in sdf_colour
  name colour
  xpos 131
  ypos -1037
 }
 Dot {
  name Dot5
  xpos 165
  ypos -864
 }
push $N840e8100
 Shuffle {
  in sdf_dimensions
  name dimensions
  xpos 1193
  ypos -1029
 }
 Dot {
  name Dot10
  xpos 1227
  ypos -857
 }
push $N840e8100
 Shuffle {
  in sdf_rotation_wall_thickness
  name rotation_wall_thickness
  xpos 1042
  ypos -1030
 }
 Dot {
  name Dot9
  xpos 1076
  ypos -854
 }
push $N840e8100
 Shuffle {
  in sdf_position_scale
  name position_scale
  xpos 900
  ypos -1029
 }
 Dot {
  name Dot6
  xpos 934
  ypos -859
 }
push $N6c0f4800
 Constant {
  inputs 0
  name Constant1
  xpos 1958
  ypos -718
 }
 Noise {
  output {rgba.red -rgba.green -rgba.blue rgba.alpha}
  type turbulence
  size 1
  zoffset 0.78
  lacunarity 1.6
  center {512 389}
  name Noise1
  xpos 1958
  ypos -622
 }
 Noise {
  output {-rgba.red rgba.green -rgba.blue rgba.alpha}
  type turbulence
  size 1
  zoffset 1.94
  center {512 389}
  name Noise2
  xpos 1958
  ypos -569
 }
 Noise {
  output {-rgba.red -rgba.green rgba.blue rgba.alpha}
  type turbulence
  size 1
  zoffset 4
  lacunarity 2.14
  center {512 389}
  name Noise3
  xpos 1958
  ypos -511
 }
 Dot {
  name resolution_dot
  xpos 1992
  ypos -451
 }
 BlinkScript {
  inputs 14
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/raymarch.blink
  recompileCount 1658
  ProgramGroup 1
  KernelDescription "2 \"RayMarchKernel\" iterate pixelWise d01a844d89010a61d2a4928e3de3600096e2f48503b0666c0fe3904771c41712 15 \"noise\" Read Point \"skyBox\" Read Random \"positions\" Read Random \"rotations\" Read Random \"dimensions\" Read Random \"colours\" Read Random \"shapeProperties\" Read Random \"shapeModParameters0\" Read Random \"shapeModParameters1\" Read Random \"surfaceProperties\" Read Random \"lights\" Read Random \"lightProperties\" Read Random \"lightProperties1\" Read Random \"skyBoxLight\" Read Random \"dst\" Write Point 34 \"Focal Length\" Float 1 AABIQg== \"Horizontal Aperture\" Float 1 ppvEQQ== \"Near Plane\" Float 1 zczMPQ== \"Far Plane\" Float 1 AEAcRg== \"Camera World Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"Screen Width\" Float 1 AABwRQ== \"Screen Height\" Float 1 AAAHRQ== \"SkyBox Offset Angle\" Float 1 AAAAAA== \"SkyBox Width\" Int 1 AAgAAA== \"SkyBox Height\" Int 1 AAQAAA== \"SkyBox Lighting Gain\" Float 1 zczMPQ== \"SkyBox Shadow Hardness\" Float 1 AACAPw== \"Soften SkyBox Shadows\" Int 1 AQAAAA== \"SkyBox Lighting Width\" Int 1 AAQAAA== \"SkyBox Lighting Height\" Int 1 AAIAAA== \"Pixel Subdivisions\" Int 1 AAAAAA== \"Max Rays Per Subpixel\" Int 1 AQAAAA== \"Max Bounces\" Int 1 AQAAAA== \"Max Ray Distance\" Float 1 AAB6RA== \"Max Ray Steps\" Int 1 gAAAAA== \"Diffuse Lighting Samples\" Int 1 BQAAAA== \"Hit Tolerance\" Float 1 bxKDOg== \"Shadow Bias\" Float 1 AACAPw== \"Index of Refraction\" Float 1 AACAPw== \"Object Texture Width\" Int 1 AAAAAA== \"Light Texture Height\" Int 1 AAAAAA== \"Light Texture Width\" Int 1 AAAAAA== \"Haze Amount\" Float 1 AAAAAA== \"Haze Start\" Float 1 AAAAAA== \"Haze Distance\" Float 1 AAB6RA== \"Haze Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"Iter Glow Amount\" Float 1 AAAAAA== \"Iter Glow Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"Output Type\" Int 1 AAAAAA== 34 \"focalLength\" 1 1 \"horizontalAperture\" 1 1 \"nearPlane\" 1 1 \"farPlane\" 1 1 \"cameraWorldMatrix\" 16 1 \"formatWidth\" 1 1 \"formatHeight\" 1 1 \"skyBoxOffsetAngle\" 1 1 \"skyFormatWidth\" 1 1 \"skyFormatHeight\" 1 1 \"skyLightGain\" 1 1 \"skyLightShadowHardness\" 1 1 \"softenSkyLightShadows\" 1 1 \"skyLightFormatWidth\" 1 1 \"skyLightFormatHeight\" 1 1 \"subdivisions\" 1 1 \"maxRaysPerSubPixel\" 1 1 \"maxBounces\" 1 1 \"maxRayDistance\" 1 1 \"maxRaySteps\" 1 1 \"diffuseSamples\" 1 1 \"hitTolerance\" 1 1 \"shadowBias\" 1 1 \"refractiveIndex\" 1 1 \"objectTextureWidth\" 1 1 \"lightTextureHeight\" 1 1 \"lightTextureWidth\" 1 1 \"hazeAmount\" 1 1 \"hazeStart\" 1 1 \"hazeDistance\" 1 1 \"hazeColour\" 4 1 \"iterGlowAmount\" 1 1 \"iterGlowColour\" 4 1 \"outputType\" 1 1 8 \"skyBoxconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA== \"inverseCameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"bouncesPerRay\" Int 1 1 AAAAAA== \"numSubPixels\" Int 1 1 AAAAAA== \"subdividedPixelSize\" Float 1 1 AAAAAA== \"skyBoxPixelSize\" Float 2 1 AAAAAAAAAAA= \"skyLightPixelSize\" Float 2 1 AAAAAAAAAAA= \"skyBoxOffsetRadians\" Float 1 1 AAAAAA=="
  kernelSource "#include \"camera.h\"\n#include \"lights.h\"\n#include \"mmath.h\"\n#include \"objectInteraction.h\"\n#include \"sdfModifications.h\"\n#include \"sdfs.h\"\n\n\n#define MAX_RAYS_PER_SUBPIXEL 100\n#define MAX_CHILD_DEPTH 100\n\n\nkernel RayMarchKernel : ImageComputationKernel<ePixelWise>\n\{\n    // the input for format, process called once per pixel\n    Image<eRead, eAccessPoint, eEdgeNone> noise;\n\n    // the skybox in latlong format\n    Image<eRead, eAccessRandom, eEdgeConstant> skyBox;\n\n\n    // the shape positons.xyz, scale.w\n    Image<eRead, eAccessRandom, eEdgeNone> positions;\n\n    // the shape rotations.xyz, wall thickness.w\n    Image<eRead, eAccessRandom, eEdgeNone> rotations;\n\n    // the shape dimensions.xyzw (some shapes may not use all channels)\n    Image<eRead, eAccessRandom, eEdgeNone> dimensions;\n\n    // the shape colours.xyz, refractive index.w\n    Image<eRead, eAccessRandom, eEdgeNone> colours;\n\n\n    // shape type.x, operation.y, numChildren.z, blend strength.w\n    Image<eRead, eAccessRandom, eEdgeNone> shapeProperties;\n\n    // repetition params.xyzw\n    Image<eRead, eAccessRandom, eEdgeNone> shapeModParameters0;\n\n    // elongation.xyz edgeRadius.w\n    Image<eRead, eAccessRandom, eEdgeNone> shapeModParameters1;\n\n    // reflection.x, transmission.y, emission.z, roughness.w\n    Image<eRead, eAccessRandom, eEdgeNone> surfaceProperties;\n\n\n    // the input lights direction/position.xyz intensity.w\n    Image<eRead, eAccessRandom, eEdgeNone> lights;\n\n    // colour.xyz, type.w\n    // w in \[0, 1) = directional, \[1, inf) = point\n    Image<eRead, eAccessRandom, eEdgeNone> lightProperties;\n\n    // shadow hardness.x\n    Image<eRead, eAccessRandom, eEdgeNone> lightProperties1;\n\n    // the skybox in latlong format\n    Image<eRead, eAccessRandom, eEdgeNone> skyBoxLight;\n\n    // the output image\n    Image<eWrite> dst;\n\n\n    param:\n        // These parameters are made available to the user.\n\n        // Camera params\n        float focalLength;\n        float horizontalAperture;\n        float nearPlane;\n        float farPlane;\n        float4x4 cameraWorldMatrix;\n\n        // Image params\n        float formatWidth;\n        float formatHeight;\n\n        float skyBoxOffsetAngle;\n        int skyFormatWidth;\n        int skyFormatHeight;\n        float skyLightGain;\n        float skyLightShadowHardness;\n        int softenSkyLightShadows;\n        int skyLightFormatWidth;\n        int skyLightFormatHeight;\n\n        // Ray params\n        int subdivisions;\n        int maxRaysPerSubPixel;\n        int maxBounces;\n        float maxRayDistance;\n        int maxRaySteps;\n        int diffuseSamples;\n        float hitTolerance;\n        float shadowBias;\n\n        // Scene params\n        float refractiveIndex;\n\n        // Shape Textures\n        int objectTextureWidth;\n\n        // Light textures\n        int lightTextureHeight;\n        int lightTextureWidth;\n\n        float hazeAmount;\n        float hazeStart;\n        float hazeDistance;\n        float4 hazeColour;\n\n        float iterGlowAmount;\n        float4 iterGlowColour;\n\n        int outputType;\n\n    local:\n        // These local variables are not exposed to the user.\n\n        float4x4 inverseCameraProjectionMatrix;\n\n        int bouncesPerRay;\n\n        int numSubPixels;\n        float subdividedPixelSize;\n\n        float2 skyBoxPixelSize;\n        float2 skyLightPixelSize;\n        float skyBoxOffsetRadians;\n\n\n\n    // In define(), parameters can be given labels and default values.\n    void define()\n    \{\n        // Camera params\n        defineParam(focalLength, \"Focal Length\", 50.0f);\n        defineParam(horizontalAperture, \"Horizontal Aperture\", 24.576f);\n        defineParam(nearPlane, \"Near Plane\", 0.1f);\n        defineParam(farPlane, \"Far Plane\", 10000.0f);\n        defineParam(\n            cameraWorldMatrix,\n            \"Camera World Matrix\",\n            float4x4(\n                1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1\n            )\n        );\n\n        // Image params\n        defineParam(formatHeight, \"Screen Height\", 2160.0f);\n        defineParam(formatWidth, \"Screen Width\", 3840.0f);\n        defineParam(skyBoxOffsetAngle, \"SkyBox Offset Angle\", 0.0f);\n        defineParam(skyFormatHeight, \"SkyBox Height\", 1024);\n        defineParam(skyFormatWidth, \"SkyBox Width\", 2048);\n        defineParam(skyLightGain, \"SkyBox Lighting Gain\", 0.1f);\n        defineParam(skyLightShadowHardness, \"SkyBox Shadow Hardness\", 1.0f);\n        defineParam(softenSkyLightShadows, \"Soften SkyBox Shadows\", 1);\n        defineParam(skyLightFormatHeight, \"SkyBox Lighting Height\", 512);\n        defineParam(skyLightFormatWidth, \"SkyBox Lighting Width\", 1024);\n\n        // Ray params\n        defineParam(subdivisions, \"Pixel Subdivisions\", 0);\n        defineParam(maxRaysPerSubPixel, \"Max Rays Per Subpixel\", 1);\n        defineParam(maxRayDistance, \"Max Ray Distance\", 1000.0f);\n        defineParam(maxRaySteps, \"Max Ray Steps\", 128);\n        defineParam(maxBounces, \"Max Bounces\", 1);\n        defineParam(diffuseSamples, \"Diffuse Lighting Samples\", 5);\n        defineParam(hitTolerance, \"Hit Tolerance\", 0.001f);\n        defineParam(shadowBias, \"Shadow Bias\", 1.0f);\n\n        // Scene params\n        defineParam(refractiveIndex, \"Index of Refraction\", 1.0f);\n\n        // Shape Counts\n        defineParam(objectTextureWidth, \"Object Texture Width\", 0);\n\n        // Light Counts\n        defineParam(lightTextureHeight, \"Light Texture Height\", 0);\n        defineParam(lightTextureWidth, \"Light Texture Width\", 0);\n\n        defineParam(hazeAmount, \"Haze Amount\", 0.0f);\n        defineParam(hazeStart, \"Haze Start\", 0.0f);\n        defineParam(hazeDistance, \"Haze Distance\", 1000.0f);\n        defineParam(hazeColour, \"Haze Colour\", float4(1, 1, 1, 1));\n\n        defineParam(iterGlowAmount, \"Iter Glow Amount\", 0.0f);\n        defineParam(iterGlowColour, \"Iter Glow Colour\", float4(1, 1, 1, 1));\n\n        defineParam(outputType, \"Output Type\", 0);\n    \}\n\n\n    // The init() function is run before any calls to process().\n    // Local variables can be initialized here.\n    void init()\n    \{\n        bouncesPerRay = maxBounces <= 0 ? 1 : maxBounces;\n\n        // TODO use angles to allow -ve focal length like for latlongs\n        float aspect = aspectRatio(formatHeight, formatWidth);\n        float4x4 cameraProjectionMatrix = projectionMatrix(\n            focalLength,\n            horizontalAperture,\n            aspect,\n            nearPlane,\n            farPlane\n        );\n        inverseCameraProjectionMatrix = cameraProjectionMatrix.invert();\n\n        int subPixelDivisions = pow(2, abs(subdivisions));\n        subdividedPixelSize = 1.0f / (float) subPixelDivisions;\n        numSubPixels = pow(subPixelDivisions, 2);\n\n        skyBoxPixelSize = float2(skyFormatWidth / (2 * PI), skyFormatHeight / PI);\n        skyLightPixelSize = float2(skyLightFormatWidth / (2 * PI), skyLightFormatHeight / PI);\n        skyBoxOffsetRadians = skyBoxOffsetAngle * PI / 180.0f;\n    \}\n\n\n    /**\n     * Get the value of sky the ray would hit at infinite distance\n     */\n    float4 readSkyValue(float3 rayDirection)\n    \{\n        const float2 angles = cartesionUnitVectorToSpherical(rayDirection, skyBoxOffsetRadians);\n\n        const float2 indices = clamp(\n            float2(\n                skyBoxPixelSize.x * angles.x,\n                skyFormatHeight - (skyBoxPixelSize.y * angles.y)\n            ),\n            float2(0),\n            float2(skyFormatWidth, skyFormatHeight) - 1.0f\n        );\n\n        return bilinear(skyBox, indices.x, indices.y);\n    \}\n\n\n    /**\n     * Get the value of sky the ray would hit at infinite distance\n     */\n    float4 readSkyLightValue(float3 rayDirection)\n    \{\n        const float2 angles = cartesionUnitVectorToSpherical(rayDirection, skyBoxOffsetRadians);\n\n        const float2 indices = clamp(\n            float2(\n                skyLightPixelSize.x * angles.x,\n                skyLightFormatHeight - (skyLightPixelSize.y * angles.y)\n            ),\n            float2(0),\n            float2(skyLightFormatWidth, skyLightFormatHeight) - 1.0f\n        );\n\n        return bilinear(skyBoxLight, indices.x, indices.y);\n    \}\n\n\n    //\n    // Render Engine\n    //\n\n\n    float3 transformRay(\n        const float3 &rayOrigin,\n        const float3 &position,\n        const float3 &rotation,\n        const int modifications,\n        const float4 &modParameters0,\n        const float4 &modParameters1)\n    \{\n        float3x3 rotMatrix;\n        float3 transformedRay;\n        rotationMatrix(rotation, rotMatrix);\n        matmul(\n            rotMatrix.invert(),\n            rayOrigin - position,\n            transformedRay\n        );\n        performShapeModification(\n            modifications,\n            modParameters0,\n            modParameters1,\n            transformedRay\n        );\n\n        return transformedRay;\n    \}\n\n\n    float getNextDistance(\n        const float3 &rayOrigin,\n        const int shape,\n        const float4 &dimension,\n        const float uniformScale,\n        const int modifications,\n        const float edgeRadius,\n        const float wallThickness,\n        float4 &colour)\n    \{\n        float nextDistance = distanceToObject(\n            rayOrigin / uniformScale,\n            shape,\n            dimension,\n            colour\n        ) * uniformScale;\n\n        return performDistanceModification(\n            modifications,\n            edgeRadius,\n            wallThickness,\n            nextDistance\n        );\n    \}\n\n\n    /**\n     * Compute the minimum distance to an object in the scene\n     */\n    float2 getMinDistanceToObjectInScene(\n            const float3 &rayOrigin,\n            const float pixelFootprint,\n            float4 &colour,\n            float4 &surface)\n    \{\n        float distance = maxRayDistance;\n        float id = 0.0f;\n\n        // numChildren, transformedRay, mods, nextDistance, colour, refractive\n        // index, surface, blendStrength\n        float parentStack\[MAX_CHILD_DEPTH]\[1 + 3 + 1 + 1 + 3 + 1 +  4 + 1];\n        int parentStackLength = 0;\n\n        for (int j=0; j < objectTextureWidth; j++)\n        \{\n            SampleType(positions) position = positions(j, 0);\n            SampleType(rotations) rotation = rotations(j, 0);\n            SampleType(dimensions) dimension = dimensions(j, 0);\n            SampleType(shapeProperties) shapeProperty = shapeProperties(j, 0);\n            SampleType(shapeModParameters0) modParameters0 = shapeModParameters0(j, 0);\n            SampleType(shapeModParameters1) modParameters1 = shapeModParameters1(j, 0);\n            SampleType(colours) surfaceColour = colours(j, 0);\n            SampleType(surfaceProperties) surfaceProperty = surfaceProperties(j, 0);\n\n            const int modifications = (int) shapeProperty.y;\n            const float scale = position.w;\n\n            const float blendStrength = shapeProperty.w;\n            int numChildren = (int) shapeProperty.z;\n\n            float nextDistance = maxRayDistance;\n\n            int stackLastIndex = parentStackLength - 1;\n\n            float4 blendedColour = surfaceColour;\n            float4 blendedSurface = surfaceProperty;\n            if (numChildren <= 0)\n            \{\n                bool objectIsNotBound = !(modifications & 4096);\n\n                // No Children left, compute interactions with parent\n                if (parentStackLength > 0 && objectIsNotBound)\n                \{\n                    const float3 parentTransformedRay = float3(\n                        parentStack\[stackLastIndex]\[1],\n                        parentStack\[stackLastIndex]\[2],\n                        parentStack\[stackLastIndex]\[3]\n                    );\n\n                    // Use parent transform to position child\n                    const float3 transformedRay = transformRay(\n                        parentTransformedRay,\n                        float3(position.x, position.y, position.z),\n                        float3(rotation.x, rotation.y, rotation.z),\n                        modifications,\n                        modParameters0,\n                        modParameters1\n                    );\n\n                    // Get distance to this child\n                    nextDistance = getNextDistance(\n                        transformedRay,\n                        (int) shapeProperty.x,\n                        dimension,\n                        scale,\n                        modifications,\n                        modParameters1.w,\n                        rotation.w,\n                        blendedColour\n                    );\n\n                    do\n                    \{\n                        const int parentModifications = (int) parentStack\[stackLastIndex]\[4];\n\n                        if (!(parentModifications & 4096))\n                        \{\n                            const float parentNextDistance = parentStack\[stackLastIndex]\[5];\n                            const float4 parentSurfaceColour = float4(\n                                parentStack\[stackLastIndex]\[6],\n                                parentStack\[stackLastIndex]\[7],\n                                parentStack\[stackLastIndex]\[8],\n                                parentStack\[stackLastIndex]\[9]\n                            );\n                            const float4 parentSurfaceProperty = float4(\n                                parentStack\[stackLastIndex]\[10],\n                                parentStack\[stackLastIndex]\[11],\n                                parentStack\[stackLastIndex]\[12],\n                                parentStack\[stackLastIndex]\[13]\n                            );\n                            const float parentBlendStrength = parentStack\[stackLastIndex]\[14];\n\n                            // Compute interaction between parent and this child\n                            nextDistance = performChildInteraction(\n                                parentModifications,\n                                parentNextDistance,\n                                nextDistance,\n                                parentSurfaceColour,\n                                blendedColour,\n                                parentSurfaceProperty,\n                                blendedSurface,\n                                parentBlendStrength\n                            );\n                        \}\n\n                        // Update the global min distance (and surface/colour)\n                        if (fabs(nextDistance) < fabs(distance))\n                        \{\n                            distance = nextDistance;\n\n                            colour = blendedColour;\n                            surface = blendedSurface;\n\n                            id = (float) j;\n                        \}\n\n                        for (int parentIndex=stackLastIndex; parentIndex >= 0; parentIndex--)\n                        \{\n                            parentStack\[parentIndex]\[0]--;\n                        \}\n                        numChildren = parentStack\[stackLastIndex]\[0];\n                    \}\n                    while (numChildren <= 0 && --stackLastIndex >= 0);\n\n                    parentStackLength = stackLastIndex + 1;\n                \}\n                else if (objectIsNotBound)\n                \{\n                    const float3 transformedRay = transformRay(\n                        rayOrigin,\n                        float3(position.x, position.y, position.z),\n                        float3(rotation.x, rotation.y, rotation.z),\n                        modifications,\n                        modParameters0,\n                        modParameters1\n                    );\n\n                    nextDistance = getNextDistance(\n                        transformedRay,\n                        (int) shapeProperty.x,\n                        dimension,\n                        scale,\n                        modifications,\n                        modParameters1.w,\n                        rotation.w,\n                        blendedColour\n                    );\n\n                    if (fabs(nextDistance) < fabs(distance))\n                    \{\n                        distance = nextDistance;\n\n                        colour = blendedColour;\n                        surface = blendedSurface;\n\n                        id = (float) j;\n                    \}\n                \}\n            \}\n            else\n            \{\n                // Node has Children, push it to the stack for later\n                // processing when we have its children\n                float3 parentTransformedRay = rayOrigin;\n                if (parentStackLength > 0)\n                \{\n                    parentTransformedRay.x = parentStack\[stackLastIndex]\[1];\n                    parentTransformedRay.y = parentStack\[stackLastIndex]\[2];\n                    parentTransformedRay.z = parentStack\[stackLastIndex]\[3];\n                \}\n                const float3 transformedRay = transformRay(\n                    parentTransformedRay,\n                    float3(position.x, position.y, position.z),\n                    float3(rotation.x, rotation.y, rotation.z),\n                    modifications,\n                    modParameters0,\n                    modParameters1\n                );\n\n                nextDistance = getNextDistance(\n                    transformedRay,\n                    (int) shapeProperty.x,\n                    dimension,\n                    scale,\n                    modifications,\n                    modParameters1.w,\n                    rotation.w,\n                    blendedColour\n                );\n\n                if (\n                    modifications & 4096\n                    && nextDistance > hitTolerance * (pixelFootprint + 1.0f)\n                ) \{\n                    // This was tagged as a boundary object, skip its children\n                    // since we arent close to hitting it\n                    if (fabs(nextDistance) < fabs(distance))\n                    \{\n                        distance = nextDistance;\n\n                        colour = blendedColour;\n                        surface = blendedSurface;\n\n                        id = (float) j;\n                    \}\n\n                    j += numChildren;\n                \}\n                else\n                \{\n                    // parentStack.push()\n                    parentStack\[parentStackLength]\[0] = numChildren;\n                    parentStack\[parentStackLength]\[1] = transformedRay.x;\n                    parentStack\[parentStackLength]\[2] = transformedRay.y;\n                    parentStack\[parentStackLength]\[3] = transformedRay.z;\n                    parentStack\[parentStackLength]\[4] = (float) modifications;\n                    parentStack\[parentStackLength]\[5] = nextDistance;\n                    parentStack\[parentStackLength]\[6] = blendedColour.x;\n                    parentStack\[parentStackLength]\[7] = blendedColour.y;\n                    parentStack\[parentStackLength]\[8] = blendedColour.z;\n                    parentStack\[parentStackLength]\[9] = blendedColour.w;\n                    parentStack\[parentStackLength]\[10] = blendedSurface.x;\n                    parentStack\[parentStackLength]\[11] = blendedSurface.y;\n                    parentStack\[parentStackLength]\[12] = blendedSurface.z;\n                    parentStack\[parentStackLength]\[13] = blendedSurface.w;\n                    parentStack\[parentStackLength]\[14] = blendStrength;\n                    parentStackLength++;\n                \}\n            \}\n        \}\n\n        return float2(distance, id);\n    \}\n\n\n    float computeSoftShadow(\n            const float3 &rayDirection,\n            const float distanceToShadePoint,\n            const float softness,\n            float3 &rayOrigin,\n            float4 &colour,\n            float4 &surface)\n    \{\n        float distanceTravelled = 0;\n        float shadowIntensity = 1.0f;\n        float lastStepDistance = 1000000000000000000000000.0f;\n\n        int iterations = 0;\n        while (distanceTravelled < distanceToShadePoint && iterations < maxRaySteps / 2)\n        \{\n            const float stepDistance = fabs(\n                getMinDistanceToObjectInScene(\n                    rayOrigin,\n                    distanceTravelled,\n                    colour,\n                    surface\n                ).x\n            );\n            const float stepDistanceSquared = stepDistance * stepDistance;\n            float softOffset = stepDistanceSquared / (2.0f * lastStepDistance);\n            shadowIntensity = min(\n                shadowIntensity,\n                softness * sqrt(stepDistanceSquared - softOffset * softOffset)\n                / max(0.0f, distanceTravelled - softOffset)\n            );\n\n            if (stepDistance < hitTolerance * distanceTravelled)\n            \{\n                surface.z /= pow(1.0f + distanceTravelled, 4);\n                shadowIntensity = saturate(shadowIntensity);\n                return shadowIntensity * shadowIntensity * (3.0f - 2.0f * shadowIntensity);\n            \}\n\n            lastStepDistance = stepDistance;\n            rayOrigin += rayDirection * stepDistance;\n            distanceTravelled += stepDistance;\n            iterations++;\n        \}\n        colour = float4(0);\n        surface = float4(0);\n\n        shadowIntensity = saturate(shadowIntensity);\n        return shadowIntensity * shadowIntensity * (3.0f - 2.0f * shadowIntensity);\n    \}\n\n\n    float computeShadow(\n            const float3 &rayDirection,\n            const float distanceToShadePoint,\n            float3 &rayOrigin,\n            float4 &colour,\n            float4 &surface)\n    \{\n        float distanceTravelled = 0;\n        int iterations = 0;\n        while (distanceTravelled < distanceToShadePoint && iterations < maxRaySteps / 2)\n        \{\n            float stepDistance = fabs(\n                getMinDistanceToObjectInScene(\n                    rayOrigin,\n                    distanceTravelled,\n                    colour,\n                    surface\n                ).x\n            );\n\n            if (stepDistance < hitTolerance * distanceTravelled)\n            \{\n                surface.z /= pow(1.0f + distanceTravelled, 4);\n                return 0;\n            \}\n\n            rayOrigin += rayDirection * stepDistance;\n            distanceTravelled += stepDistance;\n            iterations++;\n        \}\n        colour = float4(0);\n        surface = float4(0);\n\n        return 1;\n    \}\n\n\n    float computeAmbientOcclusion(\n            const float3 &rayDirection,\n            const float3 &rayOrigin,\n            const float amount,\n            const int iterations,\n            float4 &colour,\n            float4 &surface)\n    \{\n        float occlusion = 0.0f;\n        float occlusionScaleFactor = 1.0f;\n        for(int iteration=0; iteration < iterations; iteration++)\n        \{\n            float stepDistance = 0.001f + 0.15f * float(iteration) / 4.0f;\n            float distanceToClosestObject = fabs(getMinDistanceToObjectInScene(\n                rayOrigin + stepDistance * rayDirection,\n                1.0f,\n                colour,\n                surface\n            ).x);\n            occlusion += (stepDistance - distanceToClosestObject) * occlusionScaleFactor;\n            occlusionScaleFactor *= 0.95;\n        \}\n\n        return (\n            amount\n            * saturate(0.5f + 0.5f * rayDirection.y)  // ambient\n            * saturate(1.0f - 1.5f * occlusion)       // occlusion\n        );\n    \}\n\n\n    float2 lightIntensityOnSurface(\n            const float3 &pointOnSurface,\n            const float3 &surfaceNormal,\n            const float3 &light,\n            const int lightType,\n            const float intensity,\n            const float falloff,\n            const float shadow_hardness,\n            float4 &hitColour,\n            float4 &hitSurface)\n    \{\n        int absLightType = abs(lightType);\n        if (absLightType == 3)\n        \{\n            float2 result = float2(\n                1.0f,\n                computeAmbientOcclusion(\n                    surfaceNormal,\n                    pointOnSurface,\n                    intensity,\n                    (int) light.x,\n                    hitColour,\n                    hitSurface\n                )\n            );\n            hitSurface = float4(0);\n            hitColour = float4(0);\n            return result;\n        \}\n\n        float distanceToLight;\n        float3 lightDirection;\n        float intensityAtPosition = getLightData(\n            pointOnSurface,\n            surfaceNormal,\n            light,\n            absLightType,\n            intensity,\n            falloff,\n            maxRayDistance,\n            distanceToLight,\n            lightDirection\n        );\n        float3 surfaceOffset = surfaceOffsetPoint(\n            pointOnSurface,\n            lightDirection,\n            surfaceNormal,\n            shadowBias,\n            hitTolerance \n        );\n        lightDirection = normalize(lightDirection);\n\n        float normalFactor = dot(surfaceNormal, lightDirection);\n\n        float shadowIntensityAtPosition;\n        if (lightType < 0)\n        \{\n            shadowIntensityAtPosition = computeSoftShadow(\n                lightDirection,\n                distanceToLight,\n                shadow_hardness,\n                surfaceOffset,\n                hitColour,\n                hitSurface\n            );\n        \}\n        else\n        \{\n            shadowIntensityAtPosition = computeShadow(\n                lightDirection,\n                distanceToLight,\n                surfaceOffset,\n                hitColour,\n                hitSurface\n            );\n        \}\n\n        return saturate(\n            normalFactor * float2(intensityAtPosition, shadowIntensityAtPosition)\n        );\n    \}\n\n\n    /**\n     * Get the intensity of the light on the surface of an object\n     */\n    float computeLightIntensityOnSurface(\n            const float3 &pointOnSurface,\n            const float3 &surfaceNormal,\n            const float4 &surfaceColour,\n            const float4 &surface,\n            const float3 &seed,\n            float4 &lightColour)\n    \{\n        if (surface.z > 0.0f)\n        \{\n            lightColour = saturate(surfaceColour);\n            return saturate(surface.z);\n        \}\n\n        float2 lightIntensity = float2(0, 0);\n        lightColour = float4(0);\n\n        float2 currentLightIntensity;\n        for (int i=0; i < lightTextureHeight; i++)\n        \{\n            for (int j=0; j < lightTextureWidth; j++)\n            \{\n                float4 hitSurface = float4(0);\n                float4 hitColour = float4(0);\n\n                SampleType(lights) light = lights(j, i);\n                SampleType(lightProperties) lightProperty = lightProperties(j, i);\n                SampleType(lightProperties1) lightProperty1 = lightProperties1(j, i);\n\n                int lightType = (int) lightProperty.w;\n                if (lightType == 0)\n                \{\n                    currentLightIntensity = float2(light.w, 1);\n                \}\n                else\n                \{\n                    currentLightIntensity = lightIntensityOnSurface(\n                        pointOnSurface,\n                        surfaceNormal,\n                        float3(light.x, light.y, light.z),\n                        lightType,\n                        light.w,\n                        lightProperty1.y,\n                        lightProperty1.x,\n                        hitColour,\n                        hitSurface\n                    );\n                    lightColour += hitSurface.z * hitColour;\n                    lightIntensity += float2(hitSurface.z, 1.0f);\n                \}\n                lightColour += currentLightIntensity.x * currentLightIntensity.y * float4(\n                    lightProperty.x,\n                    lightProperty.y,\n                    lightProperty.z,\n                    0.0f\n                );\n                lightIntensity += currentLightIntensity;\n            \}\n        \}\n\n        const float diffuse = saturate(1.0f - surface.x - surface.y);\n        if (diffuse > hitTolerance)\n        \{\n            // Add HDRI lighting\n            float3 rayDirection = surfaceNormal;\n            float3 seedVal = seed * fabs(pointOnSurface) + 0.5773f;\n            for (int iteration=1; iteration <= diffuseSamples; iteration++)\n            \{\n                float4 hitSurface = float4(0);\n                float4 hitColour = float4(0);\n\n                rayDirection = roughen(\n                    surfaceNormal,\n                    saturate(1.0f - surface.x - surface.y),\n                    rayDirection * seedVal + iteration / (float) diffuseSamples\n                );\n                currentLightIntensity = lightIntensityOnSurface(\n                    pointOnSurface,\n                    surfaceNormal,\n                    rayDirection,\n                    softenSkyLightShadows * 100,\n                    skyLightGain,\n                    0.0f,\n                    skyLightShadowHardness,\n                    hitColour,\n                    hitSurface\n                );\n                const float4 skyLightColour = readSkyLightValue(rayDirection);\n                lightColour += (\n                    currentLightIntensity.x\n                    * currentLightIntensity.y\n                    * skyLightColour\n                    + hitSurface.z * hitColour\n                ) / (float) diffuseSamples;\n                lightIntensity += (\n                    (currentLightIntensity + float2(hitSurface.z, 0.0f))\n                    / (float) diffuseSamples\n                );\n            \}\n        \}\n\n        lightColour = saturate(lightColour);\n        return saturate(lightIntensity.x * lightIntensity.y);\n    \}\n\n\n    float getHazeAmount(const float distance)\n    \{\n        return hazeAmount * saturate((distance - hazeStart) / hazeDistance);\n    \}\n\n\n    /**\n     * Estimate the surface normal at the closest point on the closest\n     * object to a point\n     *\n     * @arg point: The point near which to get the surface normal\n     *\n     * @returns: The normalized surface normal\n     */\n    float3 estimateSurfaceNormal(const float3 &point, const float pixelFootprint) \{\n        float4 colour;\n        float4 surface;\n\n        const float epsilon = hitTolerance * pixelFootprint;\n\n        const float3 offset0 = 0.5773f * float3(1, -1, -1);\n        const float3 offset1 = 0.5773f * float3(-1, -1, 1);\n        const float3 offset2 = 0.5773f * float3(-1, 1, -1);\n        const float3 offset3 = 0.5773f * float3(1, 1, 1);\n\n        return normalize(\n            offset0\n            * getMinDistanceToObjectInScene(\n                point + offset0 * epsilon,\n                pixelFootprint,\n                colour,\n                surface\n            ).x\n            + offset1\n            * getMinDistanceToObjectInScene(\n                point + offset1 * epsilon,\n                pixelFootprint,\n                colour,\n                surface\n            ).x\n            + offset2\n            * getMinDistanceToObjectInScene(\n                point + offset2 * epsilon,\n                pixelFootprint,\n                colour,\n                surface\n            ).x\n            + offset3\n            * getMinDistanceToObjectInScene(\n                point + offset3 * epsilon,\n                pixelFootprint,\n                colour,\n                surface\n            ).x\n        );\n    \}\n\n\n    /**\n     * March a ray through the scene\n     *\n     * @returns: The ray colour\n     */\n    float4 marchRay(\n            const float3 &rayOrigin,\n            const float3 &rayDirection,\n            const int numBounces,\n            const float rayDistance,\n            const float3 &seed)\n    \{\n        const int lastRay = min(MAX_RAYS_PER_SUBPIXEL, maxRaysPerSubPixel);\n\n        // rayOrigin, rayDirection, rayIntensity, index of refraction\n        float rays\[MAX_RAYS_PER_SUBPIXEL]\[3 + 3 + 1 + 1];\n        rays\[0]\[0] = rayOrigin.x;\n        rays\[0]\[1] = rayOrigin.y;\n        rays\[0]\[2] = rayOrigin.z;\n\n        rays\[0]\[3] = rayDirection.x;\n        rays\[0]\[4] = rayDirection.y;\n        rays\[0]\[5] = rayDirection.z;\n\n        rays\[0]\[6] = 1.0f;\n\n        rays\[0]\[7] = refractiveIndex;\n\n        int numRays = 1;\n        int currentRayIndex = 0;\n\n        float4 colour;\n        float4 surface;\n\n        float4 rayColour = float4(0);\n        float4 lightColour = float4(0);\n\n        float lastStepDistance = 1.0f;\n\n        float id = 0.0f;\n\n        int bounces = 0;\n        int iterations = 1;\n        while (currentRayIndex < numRays)\n        \{\n            float lightIntensity = 1;\n\n            float distanceTravelled = 0;\n\n            float3 origin = float3(\n                rays\[currentRayIndex]\[0],\n                rays\[currentRayIndex]\[1],\n                rays\[currentRayIndex]\[2]\n            );\n            const float3 direction = float3(\n                rays\[currentRayIndex]\[3],\n                rays\[currentRayIndex]\[4],\n                rays\[currentRayIndex]\[5]\n            );\n            const float rayIntensity = rays\[currentRayIndex]\[6];\n\n            bool madeContact = false;\n\n            while (distanceTravelled < rayDistance && iterations <= maxRaySteps)\n            \{\n                const float2 result = getMinDistanceToObjectInScene(\n                    origin,\n                    distanceTravelled,\n                    colour,\n                    surface\n                );\n                const float signedStepDistance = result.x;\n                const float stepDistance = fabs(signedStepDistance);\n\n                distanceTravelled += stepDistance;\n                origin += direction * stepDistance;\n\n                if (stepDistance < hitTolerance * distanceTravelled)\n                \{\n                    if (bounces == 0)\n                    \{\n                        id = result.y;\n                    \}\n\n                    const float3 surfacePosition = origin - direction * hitTolerance;\n                    float3 surfaceNormal = sign(lastStepDistance) * estimateSurfaceNormal(\n                        surfacePosition,\n                        distanceTravelled\n                    );\n\n                    if (surface.w > 0.0f)\n                    \{\n                        surfaceNormal = roughen(\n                            surfaceNormal,\n                            surface.w,\n                            (iterations * distanceTravelled + stepDistance)\n                            * fabs(surfaceNormal) * seed\n                        );\n                    \}\n\n                    if (outputType > 0)\n                    \{\n                        if (outputType == 1)\n                        \{\n                            return float4(\n                                surfacePosition.x,\n                                surfacePosition.y,\n                                surfacePosition.z,\n                                id\n                            );\n                        \}\n                        if (outputType == 2)\n                        \{\n                            return float4(\n                                surfaceNormal.x,\n                                surfaceNormal.y,\n                                surfaceNormal.z,\n                                id\n                            );\n                        \}\n                        if (outputType == 3)\n                        \{\n                            return float4(\n                                distanceTravelled,\n                                0,\n                                0,\n                                id\n                            );\n                        \}\n                    \}\n                    bounces++;\n\n                    lightIntensity = computeLightIntensityOnSurface(\n                        origin,\n                        surfaceNormal,\n                        colour,\n                        surface,\n                        seed,\n                        lightColour\n                    );\n\n                    rayColour = blend(\n                        iterGlowColour,\n                        blend(\n                            hazeColour,\n                            blend(\n                                lightColour * colour,\n                                rayColour,\n                                rayIntensity * (1 - surface.x - surface.y) * lightIntensity\n                            ),\n                            getHazeAmount(distanceTravelled)\n                        ),\n                        saturate(iterGlowAmount * iterations)\n                    );\n\n                    if (bounces >= numBounces)\n                    \{\n                        rayColour.w = id;\n                        return rayColour;\n                    \}\n\n                    const float incidentRefractiveIndex = rays\[currentRayIndex]\[7];\n                    const float refractedRefractiveIndex = colour.w;\n                    const float reflectivity = schlickReflectionCoefficient(\n                        direction,\n                        surfaceNormal,\n                        incidentRefractiveIndex,\n                        refractedRefractiveIndex\n                    );\n                    const float refraction = saturate(surface.y * (1 - reflectivity));\n                    float intensity = rayIntensity * refraction;\n                    float reflection = surface.x;\n\n                    if (surface.y > 0.0f && numRays < lastRay && intensity > hitTolerance)\n                    \{\n                        reflection = clamp(reflection + reflectivity, 0.0f, 1.0f - refraction);\n\n                        const float3 refractedDirection = refractRayThroughSurface(\n                            direction,\n                            surfaceNormal,\n                            incidentRefractiveIndex,\n                            refractedRefractiveIndex\n                        );\n                        const float3 refractedOrigin = offsetPoint(\n                            surfacePosition,\n                            refractedDirection - surfaceNormal,\n                            2.0f * hitTolerance + stepDistance\n                        );\n\n                        rays\[numRays]\[0] = refractedOrigin.x;\n                        rays\[numRays]\[1] = refractedOrigin.y;\n                        rays\[numRays]\[2] = refractedOrigin.z;\n\n                        rays\[numRays]\[3] = refractedDirection.x;\n                        rays\[numRays]\[4] = refractedDirection.y;\n                        rays\[numRays]\[5] = refractedDirection.z;\n\n                        rays\[numRays]\[6] = intensity;\n\n                        rays\[numRays]\[7] = refractedRefractiveIndex;\n\n                        numRays++;\n                    \}\n\n                    intensity = rayIntensity * reflection;\n                    if (reflection > 0.0f && numRays < lastRay && intensity > hitTolerance)\n                    \{\n                        const float3 reflectedDirection = reflectRayOffSurface(\n                            direction,\n                            surfaceNormal\n                        );\n                        const float3 reflectedOrigin = offsetPoint(\n                            origin,\n                            reflectedDirection + surfaceNormal,\n                            hitTolerance\n                        );\n\n                        rays\[numRays]\[0] = reflectedOrigin.x;\n                        rays\[numRays]\[1] = reflectedOrigin.y;\n                        rays\[numRays]\[2] = reflectedOrigin.z;\n\n                        rays\[numRays]\[3] = reflectedDirection.x;\n                        rays\[numRays]\[4] = reflectedDirection.y;\n                        rays\[numRays]\[5] = reflectedDirection.z;\n\n                        rays\[numRays]\[6] = intensity;\n\n                        rays\[numRays]\[7] = incidentRefractiveIndex;\n\n                        numRays++;\n                    \}\n\n                    madeContact = true;\n                    break;\n                \}\n\n                lastStepDistance = signedStepDistance;\n                iterations++;\n            \}\n\n            if (outputType > 0)\n            \{\n                return float4(0);\n            \}\n\n            if (!madeContact)\n            \{\n                rayColour = blend(\n                    blend(\n                        iterGlowColour,\n                        blend(\n                            hazeColour,\n                            saturate(readSkyValue(direction)),\n                            getHazeAmount(distanceTravelled)\n                        ),\n                        saturate(iterGlowAmount * iterations)\n                    ),\n                    rayColour,\n                    rayIntensity\n                );\n            \}\n\n            currentRayIndex++;\n        \}\n\n        rayColour.w = (bounces > 0) * id;\n        return rayColour;\n    \}\n\n\n    /**\n     * Compute a raymarched pixel value\n     */\n    void process(int2 pos)\n    \{\n        SampleType(noise) seed = noise();\n\n        float4 resultPixel = float4(0);\n\n        float2 pixelLocation = float2(pos.x, pos.y);\n\n        float2 pixelOffset;\n        for (\n            pixelOffset.x = 0.0f;\n            pixelOffset.x < 1.0f;\n            pixelOffset.x += subdividedPixelSize\n        ) \{\n            for (\n                pixelOffset.y = 0.0f;\n                pixelOffset.y < 1.0f;\n                pixelOffset.y += subdividedPixelSize\n            ) \{\n                // Generate a ray from the camera\n                float3 rayOrigin;\n                float3 rayDirection;\n                createCameraRay(\n                    cameraWorldMatrix,\n                    inverseCameraProjectionMatrix,\n                    pixelsToUV(\n                        pixelLocation + pixelOffset,\n                        float2(formatWidth, formatHeight)\n                    ),\n                    rayOrigin,\n                    rayDirection\n                );\n\n                resultPixel += marchRay(\n                    rayOrigin,\n                    rayDirection,\n                    bouncesPerRay,\n                    maxRayDistance,\n                    float3(seed.x, seed.y, seed.z)\n                );\n            \}\n        \}\n\n        dst() = resultPixel / numSubPixels;\n    \}\n\};\n"
  rebuild ""
  "RayMarchKernel_Focal Length" {{parent.DummyCam.focal}}
  "RayMarchKernel_Horizontal Aperture" {{parent.DummyCam.haperture}}
  "RayMarchKernel_Near Plane" {{parent.DummyCam.near}}
  "RayMarchKernel_Far Plane" {{parent.DummyCam.far}}
  "RayMarchKernel_Camera World Matrix" {
      {{parent.DummyCam.world_matrix.0} {parent.DummyCam.world_matrix.1} {parent.DummyCam.world_matrix.2} {parent.DummyCam.world_matrix.3}}
      {{parent.DummyCam.world_matrix.4} {parent.DummyCam.world_matrix.5} {parent.DummyCam.world_matrix.6} {parent.DummyCam.world_matrix.7}}
      {{parent.DummyCam.world_matrix.8} {parent.DummyCam.world_matrix.9} {parent.DummyCam.world_matrix.10} {parent.DummyCam.world_matrix.11}}
      {{parent.DummyCam.world_matrix.12} {parent.DummyCam.world_matrix.13} {parent.DummyCam.world_matrix.14} {parent.DummyCam.world_matrix.15}}
    }
  "RayMarchKernel_Screen Width" {{parent.resolution_dot.width}}
  "RayMarchKernel_Screen Height" {{parent.resolution_dot.height}}
  "RayMarchKernel_SkyBox Offset Angle" {{parent.skybox_offset_angle}}
  "RayMarchKernel_SkyBox Width" {{parent.sky_dot.width}}
  "RayMarchKernel_SkyBox Height" {{parent.sky_dot.height}}
  "RayMarchKernel_SkyBox Lighting Gain" {{parent.skybox_lighting_gain}}
  "RayMarchKernel_SkyBox Shadow Hardness" {{parent.skybox_shadow_hardness}}
  "RayMarchKernel_Soften SkyBox Shadows" {{"parent.soften_shadows ? -1 : 1"}}
  "RayMarchKernel_SkyBox Lighting Width" {{parent.sky_light_dot.width}}
  "RayMarchKernel_SkyBox Lighting Height" {{parent.sky_light_dot.height}}
  "RayMarchKernel_Pixel Subdivisions" {{parent.pixel_subdivisions}}
  "RayMarchKernel_Max Rays Per Subpixel" {{parent.max_rays_per_subpixel}}
  "RayMarchKernel_Max Bounces" {{parent.max_bounces}}
  "RayMarchKernel_Max Ray Distance" {{parent.ray_distance}}
  "RayMarchKernel_Max Ray Steps" {{parent.max_ray_steps}}
  "RayMarchKernel_Diffuse Lighting Samples" {{parent.diffuse_lighting_samples}}
  "RayMarchKernel_Hit Tolerance" {{parent.hit_tolerance}}
  "RayMarchKernel_Shadow Bias" {{parent.shadow_bias}}
  "RayMarchKernel_Index of Refraction" {{parent.refractive_index}}
  "RayMarchKernel_Object Texture Width" {{parent.obj_dot.width}}
  "RayMarchKernel_Light Texture Height" {{parent.light_dot.height}}
  "RayMarchKernel_Light Texture Width" {{parent.light_dot.width}}
  "RayMarchKernel_Haze Amount" {{parent.haze}}
  "RayMarchKernel_Haze Start" {{parent.haze_start}}
  "RayMarchKernel_Haze Distance" {{parent.haze_distance}}
  "RayMarchKernel_Haze Colour" {{parent.haze_colour.r} {parent.haze_colour.g} {parent.haze_colour.b} {parent.haze_colour.a}}
  "RayMarchKernel_Iter Glow Amount" {{parent.iter_glow}}
  "RayMarchKernel_Iter Glow Colour" {{parent.iter_glow_colour.r} {parent.iter_glow_colour.g} {parent.iter_glow_colour.b} {parent.iter_glow_colour.a}}
  "RayMarchKernel_Output Type" {{parent.output_type}}
  format "2048 1024 0 0 2048 1024 1 2K_LatLong"
  rebuild_finalise ""
  name BlinkRayMarcher
  xpos 1661
  ypos -461
 }
 Output {
  name Output1
  xpos 1661
  ypos -122
 }
end_group
Viewer {
 frame 1
 frame_range 1-479
 name Viewer1
 xpos 18311
 ypos 1310
}
