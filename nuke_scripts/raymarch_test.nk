#! /usr/local/Nuke13.0v2/libnuke-13.0.2.so -nx
version 13.0 v2
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="1976" y="188" w="2504" h="1376" maximized="1" screen="0">
        <splitter orientation="1">
            <split size="40"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="1841" stretch="1"/>
            <splitter orientation="2">
                <split size="783"/>
                <dock id="" activePageId="Viewer.1" focus="true">
                    <page id="Viewer.1"/>
                </dock>
                <split size="550"/>
                <dock id="" activePageId="DAG.2">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                    <page id="DAG.2"/>
                </dock>
            </splitter>
            <split size="615"/>
            <dock id="" activePageId="Properties.1">
                <page id="Properties.1"/>
                <page id="uk.co.thefoundry.backgroundrenderview.1"/>
            </dock>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name /home/ob1/software/nuke/dev/raymarch/nuke_scripts/raymarch_test.nk
 frame 30
 format "2048 1556 0 0 2048 1556 1 2K_Super_35(full-ap)"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement Nuke
 workingSpaceLUT linear
 monitorLut sRGB
 monitorOutLUT rec709
 int8Lut sRGB
 int16Lut sRGB
 logLut Cineon
 floatLut linear
}
BackdropNode {
 inputs 0
 name Light
 xpos 14348
 ypos 565
 bdwidth 275
 bdheight 393
}
BackdropNode {
 inputs 0
 name Lights
 xpos 14298
 ypos 517
 appearance Border
 bdwidth 369
 bdheight 506
}
BackdropNode {
 inputs 0
 name Object_Properties
 xpos 15163
 ypos 567
 bdwidth 421
 bdheight 389
}
BackdropNode {
 inputs 0
 name Objects
 xpos 14728
 ypos 566
 bdwidth 413
 bdheight 386
}
BackdropNode {
 inputs 0
 name Shapes
 xpos 14700
 ypos 515
 appearance Border
 bdwidth 926
 bdheight 507
}
Read {
 inputs 0
 file_type tiff
 file /home/ob1/software/nuke/dev/raymarch/images/light_properties.tif
 format "2 1 0 0 2 1 1 lights"
 origset true
 name Read5
 xpos 14503
 ypos 598
}
Dot {
 name Dot7
 xpos 14537
 ypos 926
}
Read {
 inputs 0
 file_type tiff
 file /home/ob1/software/nuke/dev/raymarch/images/lights.tif
 format "2 1 0 0 2 1 1 lights"
 origset true
 name Read4
 xpos 14380
 ypos 597
}
Add {
 value {5 -3 2 0}
 name Add1
 xpos 14380
 ypos 716
 disable true
}
Multiply {
 channels alpha
 value 0.5
 name Multiply3
 xpos 14380
 ypos 775
}
Dot {
 name Dot8
 xpos 14414
 ypos 923
}
Read {
 inputs 0
 file_type tiff
 file /home/ob1/software/nuke/dev/raymarch/images/shape.tif
 format "3 2 0 0 3 2 1 "
 origset true
 name Read2
 xpos 15324
 ypos 600
}
Dot {
 name Dot1
 xpos 15358
 ypos 919
}
Read {
 inputs 0
 file_type tiff
 file /home/ob1/software/nuke/dev/raymarch/images/shape.tif
 format "3 2 0 0 3 2 1 "
 origset true
 name Read7
 xpos 15453
 ypos 600
}
Multiply {
 value 0.2
 name Multiply4
 xpos 15451
 ypos 704
}
Dot {
 name Dot5
 xpos 15487
 ypos 920
}
Read {
 inputs 0
 file_type tiff
 file /home/ob1/software/nuke/dev/raymarch/images/colours.tif
 format "3 2 0 0 3 2 1 "
 origset true
 name Read6
 xpos 15187
 ypos 599
}
Dot {
 name Dot13
 xpos 15221
 ypos 918
}
Read {
 inputs 0
 file_type tiff
 file /home/ob1/software/nuke/dev/raymarch/images/size.tif
 format "3 2 0 0 3 2 1 "
 origset true
 name Read3
 xpos 15015
 ypos 602
}
Multiply {
 value 0.09
 name Multiply1
 xpos 15015
 ypos 730
}
Dot {
 name Dot4
 xpos 15049
 ypos 921
}
Dot {
 inputs 0
 name Dot12
 xpos 14912
 ypos 922
}
Read {
 inputs 0
 file_type tiff
 file /home/ob1/software/nuke/dev/raymarch/images/pos.tif
 format "3 2 0 0 3 2 1 "
 origset true
 name positions
 xpos 14757
 ypos 599
}
Multiply {
 value 0.9
 name Multiply2
 xpos 14757
 ypos 728
 disable true
}
Dot {
 name Dot3
 xpos 14789
 ypos 921
}
Camera3 {
 inputs 0
 translate {-5 5 9}
 rotate {-30 -30 0}
 focal 56.5
 name Camera1
 xpos 14126
 ypos 605
}
Dot {
 name Dot2
 xpos 14150
 ypos 1256
}
Read {
 inputs 0
 file_type exr
 file /home/ob1/software/nuke/dev/raymarch/images/ninomaru_teien_4k.exr
 format "4096 2048 0 0 4096 2048 1 4K_LatLong"
 origset true
 name Read1
 xpos 15693
 ypos 602
}
BlinkScript {
 kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/normalize.blink
 recompileCount 1
 ProgramGroup 1
 KernelDescription "2 \"NormalizationKernel\" iterate pixelWise 5a94524fe024530fd840a25e40148131a7846c2668fed058a4f2953a27b82de4 2 \"src\" Read Point \"dst\" Write Point 0 0 0"
 kernelSource "\nkernel NormalizationKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeNone> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  void process() \{\n    // Read the input image\n    SampleType(src) input = src();\n\n    // Isolate the RGB components\n    float3 dstRGBPixel = float3(input.x, input.y, input.z);\n    dstRGBPixel = dstRGBPixel / length(dstRGBPixel);\n\n    // Write the result to the output image\n    dst() = float4(dstRGBPixel.x, dstRGBPixel.y, dstRGBPixel.z, input.w);\n  \}\n\};\n"
 rebuild ""
 rebuild_finalise ""
 name BlinkScript1
 xpos 15693
 ypos 748
 disable true
}
Grade {
 whitepoint 1.34
 black -0.003
 gamma 0.83
 name Grade1
 xpos 15693
 ypos 815
 disable true
}
Group {
 inputs 10
 name RayMarcher1
 selected true
 xpos 15693
 ypos 1252
}
 BackdropNode {
  inputs 0
  name Light
  xpos -498
  ypos -377
  appearance Border
  bdwidth 544
  bdheight 336
 }
 BackdropNode {
  inputs 0
  name Lights
  xpos -466
  ypos -333
  bdwidth 479
  bdheight 250
 }
 BackdropNode {
  inputs 0
  name Objects
  note_font_color 0x590000ff
  xpos 79
  ypos -376
  appearance Border
  bdwidth 1563
  bdheight 336
 }
 BackdropNode {
  inputs 0
  name Surface_Characteristics
  xpos 109
  ypos -329
  bdwidth 750
  bdheight 251
 }
 BackdropNode {
  inputs 0
  name Transform
  xpos 891
  ypos -329
  bdwidth 720
  bdheight 251
 }
 Constant {
  inputs 0
  channels rgb
  format "1 1 0 0 1 1 1 empty"
  name Constant9
  xpos -450
  ypos -246
 }
 Input {
  inputs 0
  name light_props
  xpos -340
  ypos -296
  number 9
 }
 Merge2 {
  inputs 2
  name Merge8
  xpos -340
  ypos -223
 }
 Dot {
  name Dot8
  xpos -306
  ypos -123
 }
 Constant {
  inputs 0
  channels rgb
  format {{{Constant9.format}}}
  name Constant8
  xpos -225
  ypos -244
 }
 Input {
  inputs 0
  name light
  xpos -115
  ypos -300
  number 8
 }
 Merge2 {
  inputs 2
  name Merge7
  xpos -115
  ypos -221
 }
 Dot {
  name Dot7
  xpos -81
  ypos -109
 }
 Constant {
  inputs 0
  channels rgb
  format {{{DefaultPos.format}}}
  name Constant4
  xpos 356
  ypos -236
 }
 Input {
  inputs 0
  name surface
  xpos 488
  ypos -287
  number 6
 }
 Merge2 {
  inputs 2
  name Merge3
  xpos 488
  ypos -213
 }
 Dot {
  name Dot2
  xpos 522
  ypos -104
 }
 Constant {
  inputs 0
  channels rgb
  format {{{DefaultPos.format}}}
  name Constant5
  xpos 590
  ypos -232
 }
 Input {
  inputs 0
  name shape
  xpos 744
  ypos -288
  number 7
 }
 Merge2 {
  inputs 2
  name Merge4
  xpos 744
  ypos -209
 }
 Dot {
  name Dot4
  xpos 778
  ypos -109
 }
 Constant {
  inputs 0
  channels rgb
  format {{{DefaultPos.format}}}
  name Constant6
  xpos 124
  ypos -237
 }
 Input {
  inputs 0
  name colour
  xpos 253
  ypos -292
  number 5
 }
 Merge2 {
  inputs 2
  name Merge5
  xpos 253
  ypos -214
 }
 Dot {
  name Dot5
  xpos 287
  ypos -118
 }
 Constant {
  inputs 0
  channels rgb
  format {{{DefaultPos.format}}}
  name Constant11
  xpos 1382
  ypos -236
 }
 Input {
  inputs 0
  name scale
  xpos 1511
  ypos -286
  number 4
 }
 Merge2 {
  inputs 2
  name Merge10
  xpos 1511
  ypos -213
 }
 Dot {
  name Dot10
  xpos 1545
  ypos -117
 }
 Constant {
  inputs 0
  channels rgb
  format {{{DefaultPos.format}}}
  name Constant10
  xpos 1153
  ypos -236
 }
 Input {
  inputs 0
  name rot
  xpos 1280
  ypos -287
  number 3
 }
 Merge2 {
  inputs 2
  name Merge9
  xpos 1280
  ypos -213
 }
 Dot {
  name Dot9
  xpos 1314
  ypos -115
 }
 Constant {
  inputs 0
  channels rgb
  format "1 1 0 0 1 1 1 empty"
  name DefaultPos
  xpos 916
  ypos -241
 }
 Input {
  inputs 0
  name pos
  xpos 1043
  ypos -287
  number 2
 }
 Merge2 {
  inputs 2
  name Merge6
  xpos 1043
  ypos -218
 }
 Dot {
  name Dot6
  xpos 1077
  ypos -120
 }
 Constant {
  inputs 0
  channels rgb
  format "2048 1024 0 0 2048 1024 1 2K_LatLong"
  name Constant3
  xpos 1682
  ypos -230
 }
 Input {
  inputs 0
  name sky
  xpos 1792
  ypos -335
 }
 Merge2 {
  inputs 2
  name Merge1
  xpos 1792
  ypos -207
 }
 Constant {
  inputs 0
  channels rgb
  name Constant1
  xpos 1971
  ypos 200
 }
 Dot {
  name Dot1
  xpos 2005
  ypos 304
 }
 BlinkScript {
  inputs 10
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/raymarch.blink
  recompileCount 423
  ProgramGroup 1
  KernelDescription "2 \"RayMarchKernel\" iterate pixelWise 1180fdbe2a51a5eddff76fcc4eeaad16c1308a323cbee483f3087855448e4356 11 \"bg\" Read Point \"skyBox\" Read Random \"positions\" Read Random \"rotations\" Read Random \"scales\" Read Random \"colours\" Read Random \"shapeProperties\" Read Random \"surfaceProperties\" Read Random \"lights\" Read Random \"lightProperties\" Read Random \"dst\" Write Point 21 \"Focal Length\" Float 1 AABIQg== \"Horizontal Aperture\" Float 1 ppvEQQ== \"Near Plane\" Float 1 zczMPQ== \"Far Plane\" Float 1 AEAcRg== \"Camera World Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"Screen Width\" Float 1 AABwRQ== \"Screen Height\" Float 1 AAAHRQ== \"SkyBox Offset Angle\" Float 1 AAAAAA== \"SkyBox Width\" Int 1 AAgAAA== \"SkyBox Height\" Int 1 AAQAAA== \"Pixel Subdivisions\" Int 1 AAAAAA== \"Max Bounces\" Int 1 AQAAAA== \"Max Ray Distance\" Float 1 AAB6RA== \"Hit Tolerance\" Float 1 bxKDOg== \"Intensity in Shadows\" Float 1 AACAPw== \"Rays Per Pixel\" Int 1 AQAAAA== \"Ray Offset\" Float 1 F7fROA== \"Object Texture Height\" Int 1 AAAAAA== \"Object Texture Width\" Int 1 AAAAAA== \"Directional Light Texture Height\" Int 1 AAAAAA== \"Directional Light Texture Width\" Int 1 AAAAAA== 21 \"focalLength\" 1 1 \"horizontalAperture\" 1 1 \"nearPlane\" 1 1 \"farPlane\" 1 1 \"cameraWorldMatrix\" 16 1 \"formatWidth\" 1 1 \"formatHeight\" 1 1 \"skyBoxOffsetAngle\" 1 1 \"skyFormatWidth\" 1 1 \"skyFormatHeight\" 1 1 \"subdivisions\" 1 1 \"maxBounces\" 1 1 \"maxRayDistance\" 1 1 \"hitTolerance\" 1 1 \"intensityInShadow\" 1 1 \"raysPerPixel\" 1 1 \"rayOffset\" 1 1 \"objectTextureHeight\" 1 1 \"objectTextureWidth\" 1 1 \"lightTextureHeight\" 1 1 \"lightTextureWidth\" 1 1 10 \"fieldOfView\" Float 1 1 AAAAAA== \"cameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"inverseCameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraPosition\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"aspect\" Float 1 1 AAAAAA== \"bouncesPerRay\" Int 1 1 AAAAAA== \"numSubPixels\" Int 1 1 AAAAAA== \"subdividedPixelSize\" Float 1 1 AAAAAA== \"skyBoxPixelSize\" Float 2 1 AAAAAAAAAAA= \"skyBoxOffsetRadians\" Float 1 1 AAAAAA=="
  kernelSource "//#include \"colour.h\"\n//#include \"mmath.h\"\n//#include \"sdfs.h\"\n\n\nkernel RayMarchKernel : ImageComputationKernel<ePixelWise>\n\{\n    // the input for format, process called once per pixel\n    Image<eRead, eAccessPoint, eEdgeNone> bg;\n\n    // the skybox in latlong format\n    Image<eRead, eAccessRandom, eEdgeNone> skyBox;\n\n\n    // the shape positons.xyz\n    Image<eRead, eAccessRandom, eEdgeNone> positions;\n\n    // the shape rotations (TODO)\n    Image<eRead, eAccessRandom, eEdgeNone> rotations;\n\n    // the shape scales.xyz (some shapes may not use all channels)\n    Image<eRead, eAccessRandom, eEdgeNone> scales;\n\n    // the shape colours.xyz\n    Image<eRead, eAccessRandom, eEdgeNone> colours;\n\n\n    // shape type.x, operation.y, numChildren.z, blend strength.w\n    // x in \[0, 1) sphere\n    // x in \[1, 2) rectangular prism\n    // x in \[2, 3) cylinder\n    // x in \[3, 4) triangular prism\n    // x in \[4, inf) torus\n    Image<eRead, eAccessRandom, eEdgeNone> shapeProperties;\n\n    // reflection.x, transmission.y, emission.z, roughness.w (TODO)\n    Image<eRead, eAccessRandom, eEdgeNone> surfaceProperties;\n\n\n    // the input directional lights direction.xyz intensity.w\n    Image<eRead, eAccessRandom, eEdgeNone> lights;\n\n    // colour.xyz, type.w\n    // w in \[0, 1) = directional, \[1, inf) = point\n    Image<eRead, eAccessRandom, eEdgeNone> lightProperties;\n\n    // the output image\n    Image<eWrite> dst;\n\n\n    param:\n        // These parameters are made available to the user.\n\n        // Camera params\n        float focalLength;\n        float horizontalAperture;\n        float nearPlane;\n        float farPlane;\n        float4x4 cameraWorldMatrix;\n\n        // Image params\n        float formatWidth;\n        float formatHeight;\n\n        float skyBoxOffsetAngle;\n        int skyFormatWidth;\n        int skyFormatHeight;\n\n        // Ray params\n        int subdivisions;\n        int maxBounces;\n        float maxRayDistance;\n        float hitTolerance;\n\n        // Shader params\n        float intensityInShadow;\n        int raysPerPixel;\n        float rayOffset;\n\n        // Scene params\n        // Shape Textures\n        int objectTextureHeight;\n        int objectTextureWidth;\n\n        // Light textures\n        int lightTextureHeight;\n        int lightTextureWidth;\n\n    local:\n        // These local variables are not exposed to the user.\n\n        float fieldOfView;\n        float4x4 cameraProjectionMatrix;\n        float4x4 inverseCameraProjectionMatrix;\n        float3 cameraPosition;\n        float aspect;\n\n        int bouncesPerRay;\n\n        int numSubPixels;\n        float subdividedPixelSize;\n\n        float2 skyBoxPixelSize;\n        float skyBoxOffsetRadians;\n\n\n    // In define(), parameters can be given labels and default values.\n    void define()\n    \{\n        // Camera params\n        defineParam(focalLength, \"Focal Length\", 50.0f);\n        defineParam(horizontalAperture, \"Horizontal Aperture\", 24.576f);\n        defineParam(nearPlane, \"Near Plane\", 0.1f);\n        defineParam(farPlane, \"Far Plane\", 10000.0f);\n        defineParam(\n            cameraWorldMatrix,\n            \"Camera World Matrix\",\n            float4x4(\n                1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1\n            )\n        );\n\n        // Image params\n        defineParam(formatHeight, \"Screen Height\", 2160.0f);\n        defineParam(formatWidth, \"Screen Width\", 3840.0f);\n        defineParam(skyBoxOffsetAngle, \"SkyBox Offset Angle\", 0.0f);\n        defineParam(skyFormatHeight, \"SkyBox Height\", 1024);\n        defineParam(skyFormatWidth, \"SkyBox Width\", 2048);\n\n        // Ray params\n        defineParam(subdivisions, \"Pixel Subdivisions\", 0);\n        defineParam(maxRayDistance, \"Max Ray Distance\", 1000.0f);\n        defineParam(maxBounces, \"Max Bounces\", 1);\n        defineParam(hitTolerance, \"Hit Tolerance\", 0.001f);\n\n        // Shader params TODO make these surface spawn rays\n        defineParam(intensityInShadow, \"Intensity in Shadows\", 1.0f);\n        defineParam(raysPerPixel, \"Rays Per Pixel\", 1);\n        defineParam(rayOffset, \"Ray Offset\", 0.0001f);\n\n        // Scene params\n\n        // Shape Counts\n        defineParam(objectTextureHeight, \"Object Texture Height\", 0);\n        defineParam(objectTextureWidth, \"Object Texture Width\", 0);\n\n        // Light Counts\n        defineParam(lightTextureHeight, \"Directional Light Texture Height\", 0);\n        defineParam(lightTextureWidth, \"Directional Light Texture Width\", 0);\n    \}\n\n\n    // The init() function is run before any calls to process().\n    // Local variables can be initialized here.\n    void init()\n    \{\n        //formatWidth = formatWidth == 0 ? 1 : formatWidth;\n        //focalLength = focalLength == 0 ? 1 : focalLength;\n        //aspect = aspect == 0 ? 1 : aspect;\n        //horizontalAperture = horizontalAperture == 0 ? 1 : horizontalAperture;\n        //rayOffset = rayOffset == 0 ? 0.000001 : rayOffset;\n\n        bouncesPerRay = maxBounces <= 0 ? 1 : maxBounces;\n\n        float farMinusNear = farPlane - nearPlane;\n\n        // TODO use angles to allow -ve focal length like for latlongs\n        aspect = formatHeight / formatWidth;\n        fieldOfView = 2 * atan(1 / focalLength);\n        cameraProjectionMatrix = float4x4(\n            2 * focalLength / horizontalAperture, 0, 0, 0,\n            0, 2 * focalLength / horizontalAperture / aspect, 0, 0,\n            0, 0, -(farPlane + nearPlane) / farMinusNear, -2 * (farPlane * nearPlane) / farMinusNear,\n            0, 0, -1, 0\n        );\n        invert4x4(cameraProjectionMatrix, inverseCameraProjectionMatrix);\n        positionFromWorldMatrix(cameraWorldMatrix, cameraPosition);\n\n        int subPixelDivisions = pow(2, abs(subdivisions));\n        subdividedPixelSize = 1.0f / (float) subPixelDivisions;\n        numSubPixels = pow(subPixelDivisions, 2);\n\n        skyBoxPixelSize = float2(skyFormatWidth / (2 * PI), skyFormatHeight / PI);\n        skyBoxOffsetRadians = skyBoxOffsetAngle * PI / 180.0f;\n    \}\n\n    /**\n     * Get the value of sky the ray would hit at infinite distance\n     */\n    float4 readSkyValue(float3 rayDirection)\n    \{\n        float rayAnglePhi = fmod(acos(rayDirection.y), PI);\n        rayAnglePhi += PI * (rayAnglePhi < 0);\n\n        float rayAngleTheta = fmod(\n            atan2(rayDirection.z, rayDirection.x) + skyBoxOffsetRadians,\n            2 * PI\n        );\n        rayAngleTheta += 2 * PI * (rayAngleTheta < 0);\n\n        SampleType(skyBox) skyBoxPixel = bilinear(\n            skyBox,\n            skyBoxPixelSize.x * rayAngleTheta,\n            skyFormatHeight - (skyBoxPixelSize.y * rayAnglePhi)\n        );\n\n        return skyBoxPixel;\n    \}\n\n\n    //\n    // Signed Distance Functions\n    //\n\n\n    /**\n     * Compute the signed distance from a point to a sphere\n     *\n     * @arg distanceTo: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg radius: The radius of the sphere\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToSphere(float3 distanceTo, float3 centre, float radius) \{\n        return length(centre - distanceTo) - radius;\n    \}\n\n    /**\n     * Compute the signed distance from a point to a rectangular prism\n     *\n     * @arg distanceTo: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg size: The length, width, and depth of the prism\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToRectangularPrism(float3 distanceTo, float3 centre, float3 size) \{\n        float3 boundingSphereVector = fabs(distanceTo - centre) - size;\n        float ud = length(max(boundingSphereVector, float3(0, 0, 0)));\n        float n = max(\n            max(min(boundingSphereVector.x, 0.0f), min(boundingSphereVector.y, 0.0f)),\n            min(boundingSphereVector.z, 0.0f)\n        );\n\n        return ud + n;\n    \}\n\n    /**\n     * Compute the signed distance from a point to a torus\n     *\n     * @arg distanceTo: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg radii: The inner and outer radius of the torus\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToTorus(float3 distanceTo, float3 centre, float2 radii)\n    \{\n        float3 centreVector = distanceTo - centre;\n        float2 centreXZ = float2(centreVector.x, centreVector.z);\n        float2 inner = float2(\n            length(centreXZ) - radii.y,\n            distanceTo.y - centre.y\n        );\n\n        return length(inner) - radii.x;\n    \}\n\n    /**\n     * Compute the signed distance from a point to a triangular prism\n     *\n     * @arg distanceTo: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg size: The height and depth of the prism\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToTriangularPrism(float3 distanceTo, float3 centre, float2 size) \{\n        float3 centreVector = fabs(distanceTo - centre);\n\n        return max(\n            centreVector.z - size.y,\n            max(\n                centreVector.x * 0.866025f + distanceTo.y * 0.5f,\n                -distanceTo.y\n            ) - size.x * 0.5f\n        );\n    \}\n\n    /**\n     * Compute the signed distance from a point to a cylinder\n     *\n     * @arg distanceTo: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg size: The height and radius of the cylinder\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToCylinder(float3 distanceTo, float3 centre, float2 size) \{\n        float3 centreVector = fabs(distanceTo - centre);\n\n        float2 distanceToXZ = float2(centreVector.x, centreVector.z);\n\n        float2 d = fabs(float2(length(distanceToXZ), centreVector.y)) - size;\n\n        return length(max(d, float2(0, 0))) + min(max(d.x, d.y), 0.0f);\n    \}\n\n\n    //\n    // Matrix and vector math operations\n    //\n\n\n    /**\n     * Saturate a value ie. clamp between 0 and 1\n     *\n     * @args value: The value to saturate\n     *\n     * @returns: The clamped value\n     */\n    float saturate(float value)\n    \{\n        return clamp(value, 0.0f, 1.0f);\n    \}\n\n\n    /**\n     * Get the position component of a world matrix.\n     *\n     * @arg worldMatrix: The world matrix\n     * @arg position: The location to store the position\n     */\n    void positionFromWorldMatrix(const float4x4 &worldMatrix, float3 &position)\n    \{\n        position = float3(\n            worldMatrix\[0]\[3],\n            worldMatrix\[1]\[3],\n            worldMatrix\[2]\[3]\n        );\n    \}\n\n\n    /**\n     * Multiply a 4d vector by a 4x4 matrix.\n     *\n     * @arg m: The matrix that will transform the vector\n     * @arg v: The vector to transform\n     * @arg out: The location to store the resulting vector\n     */\n    void matmul(const float4x4 &m, const float4 &v, float4 &out)\n    \{\n        for (int i=0; i < 4; i++)\n        \{\n            out\[i] = 0;\n\n            for (int j=0; j < 4; j++)\n            \{\n                out\[i] += m\[i]\[j] * v\[j];\n            \}\n        \}\n    \}\n\n\n    /**\n     * Invert a 4x4 matrix\n     *\n     * @arg m: The matrix to invert\n     * @arg invOut: The location to store the inverted matrix\n     *\n     * @returns: true if it was possible to invert the matrix, flase otherwise\n     */\n    bool invert4x4(const float4x4 &m, float4x4 &invOut)\n    \{\n        float4x4 inv;\n        float det;\n\n        inv\[0]\[0] =\n            m\[1]\[1]  * m\[2]\[2] * m\[3]\[3] - \n            m\[1]\[1]  * m\[2]\[3] * m\[3]\[2] - \n            m\[2]\[1]  * m\[1]\[2]  * m\[3]\[3] + \n            m\[2]\[1]  * m\[1]\[3]  * m\[3]\[2] +\n            m\[3]\[1] * m\[1]\[2]  * m\[2]\[3] - \n            m\[3]\[1] * m\[1]\[3]  * m\[2]\[2];\n\n        inv\[1]\[0] =\n            -m\[1]\[0]  * m\[2]\[2] * m\[3]\[3] + \n            m\[1]\[0]  * m\[2]\[3] * m\[3]\[2] + \n            m\[2]\[0]  * m\[1]\[2]  * m\[3]\[3] - \n            m\[2]\[0]  * m\[1]\[3]  * m\[3]\[2] - \n            m\[3]\[0] * m\[1]\[2]  * m\[2]\[3] + \n            m\[3]\[0] * m\[1]\[3]  * m\[2]\[2];\n\n        inv\[2]\[0] =\n            m\[1]\[0]  * m\[2]\[1] * m\[3]\[3] - \n            m\[1]\[0]  * m\[2]\[3] * m\[3]\[1] - \n            m\[2]\[0]  * m\[1]\[1] * m\[3]\[3] + \n            m\[2]\[0]  * m\[1]\[3] * m\[3]\[1] + \n            m\[3]\[0] * m\[1]\[1] * m\[2]\[3] - \n            m\[3]\[0] * m\[1]\[3] * m\[2]\[1];\n\n        inv\[3]\[0] =\n            -m\[1]\[0]  * m\[2]\[1] * m\[3]\[2] + \n            m\[1]\[0]  * m\[2]\[2] * m\[3]\[1] +\n            m\[2]\[0]  * m\[1]\[1] * m\[3]\[2] - \n            m\[2]\[0]  * m\[1]\[2] * m\[3]\[1] - \n            m\[3]\[0] * m\[1]\[1] * m\[2]\[2] + \n            m\[3]\[0] * m\[1]\[2] * m\[2]\[1];\n\n        inv\[0]\[1] =\n            -m\[0]\[1]  * m\[2]\[2] * m\[3]\[3] + \n            m\[0]\[1]  * m\[2]\[3] * m\[3]\[2] + \n            m\[2]\[1]  * m\[0]\[2] * m\[3]\[3] - \n            m\[2]\[1]  * m\[0]\[3] * m\[3]\[2] - \n            m\[3]\[1] * m\[0]\[2] * m\[2]\[3] + \n            m\[3]\[1] * m\[0]\[3] * m\[2]\[2];\n\n        inv\[1]\[1] =\n            m\[0]\[0]  * m\[2]\[2] * m\[3]\[3] - \n            m\[0]\[0]  * m\[2]\[3] * m\[3]\[2] - \n            m\[2]\[0]  * m\[0]\[2] * m\[3]\[3] + \n            m\[2]\[0]  * m\[0]\[3] * m\[3]\[2] + \n            m\[3]\[0] * m\[0]\[2] * m\[2]\[3] - \n            m\[3]\[0] * m\[0]\[3] * m\[2]\[2];\n\n        inv\[2]\[1] = \n            m\[0]\[0]  * m\[2]\[1] * m\[3]\[3] + \n            m\[0]\[0]  * m\[2]\[3] * m\[3]\[1] + \n            m\[2]\[0]  * m\[0]\[1] * m\[3]\[3] - \n            m\[2]\[0]  * m\[0]\[3] * m\[3]\[1] - \n            m\[3]\[0] * m\[0]\[1] * m\[2]\[3] + \n            m\[3]\[0] * m\[0]\[3] * m\[2]\[1];\n\n        inv\[3]\[1] =\n            m\[0]\[0]  * m\[2]\[1] * m\[3]\[2] - \n            m\[0]\[0]  * m\[2]\[2] * m\[3]\[1] - \n            m\[2]\[0]  * m\[0]\[1] * m\[3]\[2] + \n            m\[2]\[0]  * m\[0]\[2] * m\[3]\[1] + \n            m\[3]\[0] * m\[0]\[1] * m\[2]\[2] - \n            m\[3]\[0] * m\[0]\[2] * m\[2]\[1];\n\n        inv\[0]\[2] =\n            m\[0]\[1]  * m\[1]\[2] * m\[3]\[3] - \n            m\[0]\[1]  * m\[1]\[3] * m\[3]\[2] - \n            m\[1]\[1]  * m\[0]\[2] * m\[3]\[3] + \n            m\[1]\[1]  * m\[0]\[3] * m\[3]\[2] + \n            m\[3]\[1] * m\[0]\[2] * m\[1]\[3] - \n            m\[3]\[1] * m\[0]\[3] * m\[1]\[2];\n\n        inv\[1]\[2] =\n            -m\[0]\[0]  * m\[1]\[2] * m\[3]\[3] + \n            m\[0]\[0]  * m\[1]\[3] * m\[3]\[2] + \n            m\[1]\[0]  * m\[0]\[2] * m\[3]\[3] - \n            m\[1]\[0]  * m\[0]\[3] * m\[3]\[2] - \n            m\[3]\[0] * m\[0]\[2] * m\[1]\[3] + \n            m\[3]\[0] * m\[0]\[3] * m\[1]\[2];\n\n        inv\[2]\[2] =\n            m\[0]\[0]  * m\[1]\[1] * m\[3]\[3] - \n            m\[0]\[0]  * m\[1]\[3] * m\[3]\[1] - \n            m\[1]\[0]  * m\[0]\[1] * m\[3]\[3] + \n            m\[1]\[0]  * m\[0]\[3] * m\[3]\[1] + \n            m\[3]\[0] * m\[0]\[1] * m\[1]\[3] - \n            m\[3]\[0] * m\[0]\[3] * m\[1]\[1];\n\n        inv\[3]\[2] =\n            -m\[0]\[0]  * m\[1]\[1] * m\[3]\[2] + \n            m\[0]\[0]  * m\[1]\[2] * m\[3]\[1] + \n            m\[1]\[0]  * m\[0]\[1] * m\[3]\[2] - \n            m\[1]\[0]  * m\[0]\[2] * m\[3]\[1] - \n            m\[3]\[0] * m\[0]\[1] * m\[1]\[2] + \n            m\[3]\[0] * m\[0]\[2] * m\[1]\[1];\n\n        inv\[0]\[3] =\n            -m\[0]\[1] * m\[1]\[2] * m\[2]\[3] + \n            m\[0]\[1] * m\[1]\[3] * m\[2]\[2] + \n            m\[1]\[1] * m\[0]\[2] * m\[2]\[3] - \n            m\[1]\[1] * m\[0]\[3] * m\[2]\[2] - \n            m\[2]\[1] * m\[0]\[2] * m\[1]\[3] + \n            m\[2]\[1] * m\[0]\[3] * m\[1]\[2];\n\n        inv\[1]\[3] =\n            m\[0]\[0] * m\[1]\[2] * m\[2]\[3] - \n            m\[0]\[0] * m\[1]\[3] * m\[2]\[2] - \n            m\[1]\[0] * m\[0]\[2] * m\[2]\[3] + \n            m\[1]\[0] * m\[0]\[3] * m\[2]\[2] + \n            m\[2]\[0] * m\[0]\[2] * m\[1]\[3] - \n            m\[2]\[0] * m\[0]\[3] * m\[1]\[2];\n\n        inv\[2]\[3] =\n            -m\[0]\[0] * m\[1]\[1] * m\[2]\[3] + \n            m\[0]\[0] * m\[1]\[3] * m\[2]\[1] + \n            m\[1]\[0] * m\[0]\[1] * m\[2]\[3] - \n            m\[1]\[0] * m\[0]\[3] * m\[2]\[1] - \n            m\[2]\[0] * m\[0]\[1] * m\[1]\[3] + \n            m\[2]\[0] * m\[0]\[3] * m\[1]\[1];\n\n        inv\[3]\[3] =\n            m\[0]\[0] * m\[1]\[1] * m\[2]\[2] - \n            m\[0]\[0] * m\[1]\[2] * m\[2]\[1] - \n            m\[1]\[0] * m\[0]\[1] * m\[2]\[2] + \n            m\[1]\[0] * m\[0]\[2] * m\[2]\[1] + \n            m\[2]\[0] * m\[0]\[1] * m\[1]\[2] - \n            m\[2]\[0] * m\[0]\[2] * m\[1]\[1];\n\n        det = m\[0]\[0] * inv\[0]\[0] + m\[0]\[1] * inv\[1]\[0] + m\[0]\[2] * inv\[2]\[0] + m\[0]\[3] * inv\[3]\[0];\n\n        if (det == 0)\n            return false;\n\n        det = 1.0 / det;\n\n        for (int i=0; i < 4; i++)\n        \{\n            for (int j=0; j < 4; j++)\n            \{\n                invOut\[i]\[j] = inv\[i]\[j] * det;\n            \}\n        \}\n\n        return true;\n    \}\n\n\n    //\n    // Colour functions\n    //\n\n\n    float2 smoothMinN(float colour0, float colour1, float blendSize, float exponent)\n    \{\n        float m = 0.5f * pow(\n            max(blendSize - fabs(colour0 - colour1), 0.0f) / blendSize,\n            exponent\n        );\n\n        float s = m * blendSize / exponent;\n\n        return (colour0 < colour1) ? float2(colour0 - s, m) : float2(colour1 - s, m - 1.0f);\n    \}\n\n\n    /**\n     * Generate a ray out of the camera\n     */\n    void createCameraRay(float2 pixelLocation, float3 &rayOrigin, float3 &rayDirection)\n    \{\n        float2 uvPosition = float2(\n            2 * pixelLocation.x / formatWidth - 1,\n            2 * pixelLocation.y / formatHeight - 1\n        );\n        rayOrigin = cameraPosition;\n        float4 direction;\n        matmul(\n            inverseCameraProjectionMatrix,\n            float4(uvPosition.x, uvPosition.y, 0, 1),\n            direction\n        );\n        matmul(\n            cameraWorldMatrix,\n            float4(direction.x, direction.y, direction.z, 0),\n            direction\n        );\n        rayDirection = normalize(float3(direction.x, direction.y, direction.z));\n    \}\n\n\n    //\n    // Render Engine\n    //\n\n\n    float distanceToObject(\n            const float3 &position,\n            const int shapeType,\n            const float3 &objectPosition,\n            const float3 &scale)\n    \{\n        if (shapeType == 0)\n        \{\n            return distanceToSphere(position, objectPosition, scale.x);\n        \}\n        if (shapeType == 1)\n        \{\n            return distanceToRectangularPrism(position, objectPosition, scale);\n        \}\n\n        float2 size = float2(scale.x, scale.y);\n        if (shapeType == 2)\n        \{\n            return distanceToCylinder(position, objectPosition, size);\n        \}\n        if (shapeType == 3)\n        \{\n            return distanceToTriangularPrism(position, objectPosition, size);\n        \}\n        return distanceToTorus(position, objectPosition, size);\n    \}\n\n\n    /**\n     * Compute the minimum distance to an object in the scene\n     */\n    float getMinDistanceToObjectInScene(\n            const float3 rayOrigin,\n            float4 &colour,\n            float4 &surface)\n    \{\n        float distance = maxRayDistance;\n\n        for (int i=0; i < objectTextureHeight; i++)\n        \{\n            for (int j=0; j < objectTextureWidth; j++)\n            \{\n                SampleType(positions) position = positions(j, i);\n                //SampleType(spheres) rotation = spheres(j, i);\n                SampleType(scales) scale = scales(j, i);\n                SampleType(shapeProperties) shapeProperty = shapeProperties(j, i);\n\n                float nextDistance = distanceToObject(\n                    rayOrigin,\n                    (int) shapeProperty.x,\n                    float3(position.x, position.y, position.z),\n                    float3(scale.x, scale.y, scale.z)\n                );\n\n                if (nextDistance < distance)\n                \{\n                    distance = nextDistance;\n\n                    SampleType(colours) surfaceColour = colours(j, i);\n                    SampleType(surfaceProperties) surfaceProperty = surfaceProperties(j, i);\n\n                    colour = float4(surfaceColour);\n                    surface = float4(surfaceProperty);\n                \}\n            \}\n        \}\n\n        return distance;\n    \}\n\n\n    /**\n     * Estimate the surface normal at the closest point on the closest\n     * object to a point\n     *\n     * @arg point: The point near which to get the surface normal\n     *\n     * @returns: The normalized surface normal\n     */\n    float3 estimateSurfaceNormal(const float3 &point) \{\n        float4 colour;\n        float4 surface;\n        return normalize(\n            float3(\n                getMinDistanceToObjectInScene(\n                    float3(\n                        point.x + hitTolerance,\n                        point.y,\n                        point.z\n                    ),\n                    colour,\n                    surface\n                ) - getMinDistanceToObjectInScene(\n                    float3(\n                        point.x - hitTolerance,\n                        point.y,\n                        point.z\n                    ),\n                    colour,\n                    surface\n                ),\n                getMinDistanceToObjectInScene(\n                    float3(\n                        point.x,\n                        point.y + hitTolerance,\n                        point.z\n                    ),\n                    colour,\n                    surface\n                ) - getMinDistanceToObjectInScene(\n                    float3(\n                        point.x,\n                        point.y - hitTolerance,\n                        point.z\n                    ),\n                    colour,\n                    surface\n                ),\n                getMinDistanceToObjectInScene(\n                    float3(\n                        point.x,\n                        point.y,\n                        point.z+hitTolerance\n                    ),\n                    colour,\n                    surface\n                ) - getMinDistanceToObjectInScene(\n                    float3(\n                        point.x,\n                        point.y,\n                        point.z - hitTolerance\n                    ),\n                    colour,\n                    surface\n                )\n        ));\n    \}\n\n\n    float computeShadow(float3 rayOrigin, float3 rayDirection, float distanceToShadePoint)\n    \{\n        float distanceTravelled = 0;\n        float4 colour;\n        float4 surface;\n        while (distanceTravelled < distanceToShadePoint)\n        \{\n            float stepDistance = getMinDistanceToObjectInScene(rayOrigin, colour, surface);\n\n            if (stepDistance < hitTolerance)\n            \{\n                return intensityInShadow;\n            \}\n\n            rayOrigin += rayDirection * stepDistance;\n            distanceTravelled += stepDistance;\n        \}\n\n        return 1;\n    \}\n\n\n    static float3 offsetPoint(\n            const float3 &point,\n            const float3 &direction,\n            const float offset)\n    \{\n        return offset * direction + point;\n    \}\n\n\n    void computeDirectionalLightShadow(\n        const float3 &pointOnSurface,\n        const float3 &surfaceNormal,\n        const float3 &light,\n        float3 &lightDirection,\n        float3 &surfaceOffset,\n        float3 &shadowOffsetLightDirection,\n        float &distanceToLight)\n    \{\n        lightDirection = -light;\n        surfaceOffset = offsetPoint(\n            pointOnSurface,\n            lightDirection + surfaceNormal,\n            hitTolerance\n        );\n        shadowOffsetLightDirection = lightDirection;\n\n        distanceToLight = maxRayDistance;\n    \}\n\n\n    void computePointLightShadow(\n        const float3 &pointOnSurface,\n        const float3 &surfaceNormal,\n        const float3 &light,\n        float3 &lightDirection,\n        float3 &surfaceOffset,\n        float3 &shadowOffsetLightDirection,\n        float &distanceToLight)\n    \{\n        lightDirection = light - pointOnSurface;\n        surfaceOffset = offsetPoint(\n            pointOnSurface,\n            lightDirection + surfaceNormal,\n            hitTolerance\n        );\n        shadowOffsetLightDirection = light - surfaceOffset;\n\n        distanceToLight = length(shadowOffsetLightDirection);\n    \}\n\n\n    float2 lightIntensityOnSurface(\n            const float3 &pointOnSurface,\n            const float3 &surfaceNormal,\n            const float3 &light,\n            const int lightType,\n            const float intensity)\n    \{\n        float3 surfaceOffset;\n\n        float distanceToLight;\n        float3 lightDirection;\n        float3 shadowOffsetLightDirection;\n        if (lightType == 0)\n        \{\n            // directional\n            computeDirectionalLightShadow(\n                pointOnSurface,\n                surfaceNormal,\n                light,\n                lightDirection,\n                surfaceOffset,\n                shadowOffsetLightDirection,\n                distanceToLight\n            );\n        \}\n        else\n        \{\n            // point\n            computePointLightShadow(\n                pointOnSurface,\n                surfaceNormal,\n                light,\n                lightDirection,\n                surfaceOffset,\n                shadowOffsetLightDirection,\n                distanceToLight\n            );\n        \}\n\n        return float2(\n            saturate(dot(surfaceNormal, normalize(lightDirection)) * intensity),\n            computeShadow(\n                surfaceOffset,\n                normalize(shadowOffsetLightDirection),\n                distanceToLight\n            )\n        );\n    \}\n\n\n    /**\n     * Get the intensity of the light on the surface of an object\n     *\n     *\n     */\n    float computeLightIntensityOnSurface(const float3 &pointOnSurface, const float3 &surfaceNormal)\n    \{\n        float2 lightIntensity = float2(0, 0);\n\n        for (int i=0; i < lightTextureHeight; i++)\n        \{\n            for (int j=0; j < lightTextureWidth; j++)\n            \{\n                SampleType(lights) light = lights(j, i);\n                SampleType(lightProperties) lightProperty = lightProperties(j, i);\n\n                lightIntensity += lightIntensityOnSurface(\n                    pointOnSurface,\n                    surfaceNormal,\n                    float3(light.x, light.y, light.z),\n                    (int) lightProperty.w,\n                    light.w\n                );\n            \}\n        \}\n\n        return saturate(lightIntensity.x * lightIntensity.y);\n    \}\n\n\n    float3 reflectRayOffSurface(\n        const float3 &incidentRayDirection,\n        const float3 &surfaceNormalDirection)\n    \{\n        return (\n            incidentRayDirection\n            - 2 * dot(incidentRayDirection, surfaceNormalDirection) * surfaceNormalDirection\n        );\n    \}\n\n    /**\n     * March a ray through the scene\n     *\n     * @returns: The ray colour\n     */\n    float4 marchRay(\n            const float3 &rayOrigin,\n            const float3 &rayDirection,\n            const int numBounces,\n            const float rayDistance)\n    \{\n        float3 origin = rayOrigin;\n        float3 direction = rayDirection;\n        float4 colour;\n        float4 surface;\n\n        int bounces = 0;\n        float distanceTravelled = 0;\n\n        float lightIntensity = 1;\n\n        float4 rayColour = float4(0, 0, 0, 0);\n\n        float rayStrength = 1;\n\n        while (distanceTravelled < rayDistance && rayStrength > 0)\n        \{\n            float stepDistance = getMinDistanceToObjectInScene(origin, colour, surface);\n            distanceTravelled += stepDistance;\n            origin += direction * stepDistance;\n\n            if (stepDistance < hitTolerance)\n            \{\n                bounces++;\n\n                float3 surfaceNormal = estimateSurfaceNormal(\n                    origin - direction * hitTolerance\n                );\n\n                lightIntensity = computeLightIntensityOnSurface(\n                    origin,\n                    surfaceNormal\n                );\n\n\n                rayColour += rayStrength * (1 - surface.x) * lightIntensity * colour;\n\n                if (bounces >= numBounces)\n                \{\n                    return rayColour / (float) numBounces;\n                \}\n\n                rayStrength *= surface.x;\n\n                direction = reflectRayOffSurface(\n                    direction,\n                    surfaceNormal\n                );\n                origin = offsetPoint(\n                    origin,\n                    direction + surfaceNormal,\n                    hitTolerance\n                );\n            \}\n        \}\n\n        // If the ray missed, grab the skybox colour\n        float4 skyColour = readSkyValue(direction);\n        if (bounces <= 0)\n        \{\n            return skyColour;\n        \}\n\n        rayColour += rayStrength * lightIntensity * skyColour;\n\n        return rayColour / (float) (bounces + 1);\n    \}\n\n\n    /**\n     * March rays through the scene\n     */\n    void marchRays(\n            const float3 &rayOrigin,\n            const float3 &rayDirection,\n            const int numRays,\n            const int numBounces,\n            const float rayDistance,\n            float4 &resultColour)\n    \{\n        float3 direction = rayDirection;\n\n        float3 rayNormal = normalize(float3(direction.y, -direction.x, 0));\n        float radialOffset = rayOffset;\n        float angularOffset = 0;\n\n        float4 colour;\n\n        for (int rayNum=0; rayNum < numRays; rayNum++)\n        \{\n            resultColour += marchRay(\n                rayOrigin,\n                direction,\n                numBounces,\n                rayDistance\n            );\n\n            // Update the ray direction to send a scattered cluster of rays\n            // TODO these shouldnt diverge more and more the more rays you add\n            rayNormal = (\n                cos(angularOffset)\n                * rayNormal\n                + sin(angularOffset)\n                * cross(direction, rayNormal)\n            );\n\n            direction = radialOffset * rayNormal + rayDirection;\n\n            angularOffset = 90 * (1 - 0.5 * ((rayNum % 4) == 0));\n            radialOffset += rayOffset * ((rayNum % 8) == 0);\n        \}\n\n        // Normalize the output after multiple rays\n        resultColour /= numRays;\n    \}\n\n\n    /**\n     * Compute a raymarched pixel value\n     */\n    void process(int2 pos)\n    \{\n        float4 resultPixel(0, 0, 0, 0);\n\n        float2 pixelLocation = float2(pos.x, pos.y);\n\n        float2 pixelOffset;\n        for (\n            pixelOffset.x = 0.0f;\n            pixelOffset.x < 1.0f;\n            pixelOffset.x += subdividedPixelSize\n        ) \{\n            for (\n                pixelOffset.y = 0.0f;\n                pixelOffset.y < 1.0f;\n                pixelOffset.y += subdividedPixelSize\n            ) \{\n                // Generate a ray from the camera\n                float3 rayOrigin;\n                float3 rayDirection;\n                createCameraRay(pixelLocation + pixelOffset, rayOrigin, rayDirection);\n\n                marchRays(\n                    rayOrigin,\n                    rayDirection,\n                    raysPerPixel,\n                    bouncesPerRay,\n                    maxRayDistance,\n                    resultPixel\n                );\n            \}\n        \}\n\n        dst() = resultPixel / numSubPixels;\n    \}\n\};\n"
  rebuild ""
  "RayMarchKernel_Focal Length" {{parent.DummyCam.focal}}
  "RayMarchKernel_Horizontal Aperture" {{parent.DummyCam.haperture}}
  "RayMarchKernel_Near Plane" {{parent.DummyCam.near}}
  "RayMarchKernel_Far Plane" {{parent.DummyCam.far}}
  "RayMarchKernel_Camera World Matrix" {
      {{parent.DummyCam.world_matrix.0} {parent.DummyCam.world_matrix.1} {parent.DummyCam.world_matrix.2} {parent.DummyCam.world_matrix.3}}
      {{parent.DummyCam.world_matrix.4} {parent.DummyCam.world_matrix.5} {parent.DummyCam.world_matrix.6} {parent.DummyCam.world_matrix.7}}
      {{parent.DummyCam.world_matrix.8} {parent.DummyCam.world_matrix.9} {parent.DummyCam.world_matrix.10} {parent.DummyCam.world_matrix.11}}
      {{parent.DummyCam.world_matrix.12} {parent.DummyCam.world_matrix.13} {parent.DummyCam.world_matrix.14} {parent.DummyCam.world_matrix.15}}
    }
  "RayMarchKernel_Screen Width" {{input0.width}}
  "RayMarchKernel_Screen Height" {{input0.height}}
  "RayMarchKernel_SkyBox Width" {{input1.width}}
  "RayMarchKernel_SkyBox Height" {{input1.height}}
  "RayMarchKernel_Pixel Subdivisions" 1
  "RayMarchKernel_Max Bounces" 6
  "RayMarchKernel_Max Ray Distance" 100
  "RayMarchKernel_Hit Tolerance" 0.0001
  "RayMarchKernel_Intensity in Shadows" 0
  "RayMarchKernel_Object Texture Height" {{input2.height}}
  "RayMarchKernel_Object Texture Width" {{input2.width}}
  "RayMarchKernel_Directional Light Texture Height" {{input8.height}}
  "RayMarchKernel_Directional Light Texture Width" {{input8.width}}
  format "2048 1024 0 0 2048 1024 1 2K_LatLong"
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos 1792
  ypos 294
 }
 Output {
  name Output1
  xpos 1792
  ypos 625
 }
 Input {
  inputs 0
  name cam
  xpos -293
  ypos 137
  number 1
 }
 Camera {
  projection_mode {{"\[expression \[value the_cam]projection_mode(\[value the_frame])]"}}
  focal {{"\[expression \[value the_cam]focal(\[value the_frame])]"}}
  haperture {{"\[expression \[value the_cam]haperture(\[value the_frame])]"}}
  vaperture {{"\[expression \[value the_cam]vaperture(\[value the_frame])]"}}
  near {{"\[expression \[value the_cam]near(\[value the_frame])]"}}
  far {{"\[expression \[value the_cam]far(\[value the_frame])]"}}
  win_translate {{"\[expression \[value the_cam]win_translate.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_translate.v(\[value the_frame])]"}}
  win_scale {{"\[expression \[value the_cam]win_scale.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_scale.v(\[value the_frame])]"}}
  winroll {{"\[expression \[value the_cam]winroll(\[value the_frame])]"}}
  focal_point {{"\[expression \[value the_cam]focal_point(\[value the_frame])]"}}
  fstop {{"\[expression \[value the_cam]fstop(\[value the_frame])]"}}
  name DummyCam
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if no Camera connected. Can also be used inside of groups and gizmos, as many levels deep as you want :D All using live and super fast TCL.\n\nUpdated v1.1: Now grabs the correct frame too (thanks Erwan Leroy for the idea).\n\nUpdated v1.3: Now accepts Nuke13's Camera3\n\nadrianpueyo.com, 2019-2021"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  xpos -283
  ypos 245
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\n#DummyCam v1.3 - Updated 5 May 2021.\nset starting_point \"this.input0\"\nset default \"this.d_\"\n\n# If cam has no inputs, return the default.\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera3\" && \[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera3\"||\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{ \[class \$x]==\"Input\" \} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{ \[exists \$inp] \} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {43 the_frame +INVISIBLE}
  the_frame "\[\nset the_camera \[string trimright \[value the_cam] .]\nif \{\[exists \$the_camera]\} \{\n    return \[value \$the_camera.frame]\n\} \{ \n    return \[frame]\n\}\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l "focal length" R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {30 d_win_translate l "window translate"}
  addUserKnob {30 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 version l " " t "Updated 5 May 2021" T "<span style=\"color:#666\"><br/><b>DummyCam v1.3</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019-2021</span>"}
 }
end_group
Viewer {
 frame_range 1-100
 name Viewer1
 xpos 15693
 ypos 1430
}
