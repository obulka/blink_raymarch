#! /usr/local/Nuke13.0v2/libnuke-13.0.2.so -nx
version 13.0 v2
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="1976" y="188" w="2504" h="1376" maximized="1" screen="0">
        <splitter orientation="1">
            <split size="40"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="1841" stretch="1"/>
            <splitter orientation="2">
                <split size="783"/>
                <dock id="" activePageId="Viewer.1">
                    <page id="Viewer.1"/>
                </dock>
                <split size="550"/>
                <dock id="" activePageId="DAG.1" focus="true">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                    <page id="DAG.2"/>
                </dock>
            </splitter>
            <split size="615"/>
            <dock id="" activePageId="Properties.1">
                <page id="Properties.1"/>
                <page id="uk.co.thefoundry.backgroundrenderview.1"/>
            </dock>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name /home/ob1/software/nuke/dev/raymarch/nuke_scripts/raymarch_test.nk
 frame 50
 format "2048 1556 0 0 2048 1556 1 2K_Super_35(full-ap)"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement Nuke
 workingSpaceLUT linear
 monitorLut sRGB
 monitorOutLUT rec709
 int8Lut sRGB
 int16Lut sRGB
 logLut Cineon
 floatLut linear
}
BackdropNode {
 inputs 0
 name Cylinders
 xpos 15330
 ypos 713
 bdwidth 256
 bdheight 388
}
BackdropNode {
 inputs 0
 name Rectangular_Prisms
 xpos 14420
 ypos 718
 bdwidth 256
 bdheight 388
}
BackdropNode {
 inputs 0
 name Shapes
 xpos 14008
 ypos 646
 appearance Border
 bdwidth 1636
 bdheight 508
}
BackdropNode {
 inputs 0
 name Spheres
 xpos 14110
 ypos 716
 bdwidth 256
 bdheight 388
}
BackdropNode {
 inputs 0
 name Tori
 xpos 14723
 ypos 717
 bdwidth 256
 bdheight 388
}
BackdropNode {
 inputs 0
 name Triangular_Prisms
 xpos 15034
 ypos 717
 bdwidth 256
 bdheight 388
}
Constant {
 inputs 0
 color {-2 2 3 1}
 format "1 1 0 0 1 1 1 empty"
 name Constant5
 xpos 15414
 ypos 769
}
Dot {
 name Dot1
 xpos 15448
 ypos 1071
}
Constant {
 inputs 0
 color {-7 0 0 2}
 format "1 1 0 0 1 1 1 empty"
 name Constant4
 xpos 15118
 ypos 769
}
Dot {
 name Dot3
 xpos 15152
 ypos 1075
}
Constant {
 inputs 0
 color {0 3 0 1}
 format "1 1 0 0 1 1 1 empty"
 name Constant2
 xpos 14807
 ypos 772
}
Dot {
 name Dot4
 xpos 14841
 ypos 1080
}
Constant {
 inputs 0
 color {5 0 0 1}
 format "1 1 0 0 1 1 1 empty"
 name Constant3
 xpos 14504
 ypos 774
}
Dot {
 name Dot5
 xpos 14538
 ypos 1079
}
Constant {
 inputs 0
 color {0 0 0 1}
 format "1 1 0 0 1 1 1 empty"
 name Constant1
 xpos 14194
 ypos 772
}
Dot {
 name Dot6
 xpos 14228
 ypos 1077
}
Camera3 {
 inputs 0
 translate {-1 8 7}
 rotate {-40 0 0}
 focal 13.8
 name Camera1
 xpos 13887
 ypos 788
}
Dot {
 name Dot2
 xpos 13911
 ypos 1256
}
Read {
 inputs 0
 file_type exr
 file /home/ob1/software/nuke/dev/raymarch/images/ninomaru_teien_4k.exr
 format "4096 2048 0 0 4096 2048 1 4K_LatLong"
 origset true
 name Read1
 xpos 15693
 ypos 763
}
Group {
 inputs 7
 name RayMarcher
 xpos 15693
 ypos 1252
}
 BackdropNode {
  inputs 0
  name Cylinders
  xpos 1344
  ypos -316
  bdwidth 250
  bdheight 240
 }
 BackdropNode {
  inputs 0
  name Objects
  note_font_color 0x590000ff
  xpos 201
  ypos -375
  appearance Border
  bdwidth 1435
  bdheight 357
 }
 BackdropNode {
  inputs 0
  name Rectangular_Prisms
  xpos 507
  ypos -318
  bdwidth 251
  bdheight 242
 }
 BackdropNode {
  inputs 0
  name Spheres
  xpos 260
  ypos -318
  bdwidth 225
  bdheight 240
 }
 BackdropNode {
  inputs 0
  name Tori
  xpos 784
  ypos -317
  bdwidth 252
  bdheight 240
 }
 BackdropNode {
  inputs 0
  name Triangular_Prisms
  xpos 1065
  ypos -316
  bdwidth 248
  bdheight 240
 }
 Input {
  inputs 0
  name cam
  xpos 776
  ypos 211
  number 1
 }
 Camera {
  projection_mode {{"\[expression \[value the_cam]projection_mode(\[value the_frame])]"}}
  focal {{"\[expression \[value the_cam]focal(\[value the_frame])]"}}
  haperture {{"\[expression \[value the_cam]haperture(\[value the_frame])]"}}
  vaperture {{"\[expression \[value the_cam]vaperture(\[value the_frame])]"}}
  near {{"\[expression \[value the_cam]near(\[value the_frame])]"}}
  far {{"\[expression \[value the_cam]far(\[value the_frame])]"}}
  win_translate {{"\[expression \[value the_cam]win_translate.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_translate.v(\[value the_frame])]"}}
  win_scale {{"\[expression \[value the_cam]win_scale.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_scale.v(\[value the_frame])]"}}
  winroll {{"\[expression \[value the_cam]winroll(\[value the_frame])]"}}
  focal_point {{"\[expression \[value the_cam]focal_point(\[value the_frame])]"}}
  fstop {{"\[expression \[value the_cam]fstop(\[value the_frame])]"}}
  name DummyCam
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if no Camera connected. Can also be used inside of groups and gizmos, as many levels deep as you want :D All using live and super fast TCL.\n\nUpdated v1.1: Now grabs the correct frame too (thanks Erwan Leroy for the idea).\n\nUpdated v1.3: Now accepts Nuke13's Camera3\n\nadrianpueyo.com, 2019-2021"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  xpos 786
  ypos 253
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\n#DummyCam v1.3 - Updated 5 May 2021.\nset starting_point \"this.input0\"\nset default \"this.d_\"\n\n# If cam has no inputs, return the default.\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera3\" && \[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera3\"||\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{ \[class \$x]==\"Input\" \} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{ \[exists \$inp] \} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {43 the_frame +INVISIBLE}
  the_frame "\[\nset the_camera \[string trimright \[value the_cam] .]\nif \{\[exists \$the_camera]\} \{\n    return \[value \$the_camera.frame]\n\} \{ \n    return \[frame]\n\}\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l "focal length" R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {30 d_win_translate l "window translate"}
  addUserKnob {30 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 version l " " t "Updated 5 May 2021" T "<span style=\"color:#666\"><br/><b>DummyCam v1.3</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019-2021</span>"}
 }
 Constant {
  inputs 0
  channels rgb
  format "1 1 0 0 1 1 1 empty"
  name Constant7
  xpos 1496
  ypos -224
 }
 Input {
  inputs 0
  name cylinders
  xpos 1359
  ypos -291
  number 6
 }
 Merge2 {
  inputs 2
  name Merge6
  xpos 1359
  ypos -201
 }
 Dot {
  name Dot6
  xpos 1393
  ypos -103
 }
 Constant {
  inputs 0
  channels rgb
  format "1 1 0 0 1 1 1 empty"
  name Constant6
  xpos 1217
  ypos -224
 }
 Input {
  inputs 0
  name prisms
  xpos 1080
  ypos -291
  number 5
 }
 Merge2 {
  inputs 2
  name Merge5
  xpos 1080
  ypos -201
 }
 Dot {
  name Dot5
  xpos 1114
  ypos -105
 }
 Constant {
  inputs 0
  channels rgb
  format "1 1 0 0 1 1 1 empty"
  name Constant5
  xpos 936
  ypos -225
 }
 Input {
  inputs 0
  name tori
  xpos 799
  ypos -292
  number 4
 }
 Merge2 {
  inputs 2
  name Merge4
  xpos 799
  ypos -202
 }
 Dot {
  name Dot4
  xpos 833
  ypos -104
 }
 Constant {
  inputs 0
  channels rgb
  format "1 1 0 0 1 1 1 empty"
  name Constant4
  xpos 659
  ypos -226
 }
 Input {
  inputs 0
  name rects
  xpos 522
  ypos -293
  number 3
 }
 Merge2 {
  inputs 2
  name Merge3
  xpos 522
  ypos -203
 }
 Dot {
  name Dot2
  xpos 556
  ypos -94
 }
 Constant {
  inputs 0
  channels rgb
  format "1 1 0 0 1 1 1 empty"
  name Constant2
  xpos 386
  ypos -227
 }
 Input {
  inputs 0
  name spheres
  xpos 276
  ypos -294
  number 2
 }
 Merge2 {
  inputs 2
  name Merge2
  xpos 276
  ypos -204
 }
 Dot {
  name Dot3
  xpos 310
  ypos -92
 }
 Constant {
  inputs 0
  channels rgb
  format "2048 1024 0 0 2048 1024 1 2K_LatLong"
  name Constant3
  xpos 1682
  ypos -230
 }
 Input {
  inputs 0
  name sky
  xpos 1792
  ypos -323
 }
 Merge2 {
  inputs 2
  name Merge1
  xpos 1792
  ypos -207
 }
 Constant {
  inputs 0
  channels rgb
  name Constant1
  xpos 2143
  ypos 200
 }
 Dot {
  name Dot1
  xpos 2177
  ypos 304
 }
 BlinkScript {
  inputs 7
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/raymarch.blink
  recompileCount 265
  ProgramGroup 1
  KernelDescription "2 \"RayMarchKernel\" iterate pixelWise b286fb6abe08850d9694c31101860762e623adc66c058f1ff4a50eb521593bca 8 \"bg\" Read Point \"skyBox\" Read Random \"spheres\" Read Random \"rectPrisms\" Read Random \"tori\" Read Random \"triangularPrisms\" Read Random \"cylinders\" Read Random \"dst\" Write Point 26 \"Focal Length\" Float 1 AABIQg== \"Horizontal Aperture\" Float 1 ppvEQQ== \"Near Plane\" Float 1 zczMPQ== \"Far Plane\" Float 1 AEAcRg== \"Camera World Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"Screen Width\" Float 1 AABwRQ== \"Screen Height\" Float 1 AAAHRQ== \"SkyBox Offset Angle\" Float 1 AAAAAA== \"SkyBox Width\" Int 1 AAgAAA== \"SkyBox Height\" Int 1 AAQAAA== \"Pixel Subdivisions\" Int 1 AAAAAA== \"Rays Per Pixel\" Int 1 AQAAAA== \"Max Bounces\" Int 1 AQAAAA== \"Max Ray Distance\" Float 1 AEAcRg== \"Hit Tolerance\" Float 1 bxKDOg== \"Ray Offset\" Float 1 F7fROA== \"Spheres Texture Width\" Int 1 AAAAAA== \"Spheres Texture Height\" Int 1 AAAAAA== \"Rectangular Prisms Texture Width\" Int 1 AAAAAA== \"Rectangular Prisms Texture Height\" Int 1 AAAAAA== \"Tori Texture Height\" Int 1 AAAAAA== \"Tori Texture Width\" Int 1 AAAAAA== \"Triangular Prisms Texture Height\" Int 1 AAAAAA== \"Triangular Prisms Texture Width\" Int 1 AAAAAA== \"Cylinders Texture Height\" Int 1 AAAAAA== \"Cylinders Texture Width\" Int 1 AAAAAA== 26 \"focalLength\" 1 1 \"horizontalAperture\" 1 1 \"nearPlane\" 1 1 \"farPlane\" 1 1 \"cameraWorldMatrix\" 16 1 \"formatWidth\" 1 1 \"formatHeight\" 1 1 \"skyBoxOffsetAngle\" 1 1 \"skyFormatWidth\" 1 1 \"skyFormatHeight\" 1 1 \"subdivisions\" 1 1 \"raysPerPixel\" 1 1 \"maxBounces\" 1 1 \"maxRayDistance\" 1 1 \"hitTolerance\" 1 1 \"rayOffset\" 1 1 \"spheresTextureWidth\" 1 1 \"spheresTextureHeight\" 1 1 \"rectPrismsTextureWidth\" 1 1 \"rectPrismsTextureHeight\" 1 1 \"toriTextureHeight\" 1 1 \"toriTextureWidth\" 1 1 \"triangularPrismsTextureHeight\" 1 1 \"triangularPrismsTextureWidth\" 1 1 \"cylindersTextureHeight\" 1 1 \"cylindersTextureWidth\" 1 1 9 \"fieldOfView\" Float 1 1 AAAAAA== \"cameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"inverseCameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraPosition\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"aspect\" Float 1 1 AAAAAA== \"numSubPixels\" Int 1 1 AAAAAA== \"subdividedPixelSize\" Float 1 1 AAAAAA== \"skyBoxPixelSize\" Float 2 1 AAAAAAAAAAA= \"skyBoxOffsetRadians\" Float 1 1 AAAAAA=="
  kernelSource "kernel RayMarchKernel : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessPoint, eEdgeNone> bg; // the input for format, process called once per pixel\n    Image<eRead, eAccessRandom, eEdgeNone> skyBox; // the skybox\n    Image<eRead, eAccessRandom, eEdgeNone> spheres; // the input spheres positions.xyz radius.w\n    Image<eRead, eAccessRandom, eEdgeNone> rectPrisms; // the input rectPrisms positions.xyz radius.w\n    Image<eRead, eAccessRandom, eEdgeNone> tori; // the input tori positions.xyz radius.w\n    Image<eRead, eAccessRandom, eEdgeNone> triangularPrisms; // the input triangularPrisms positions.xyz radius.w\n    Image<eRead, eAccessRandom, eEdgeNone> cylinders; // the input cylinders positions.xyz radius.w\n\n    Image<eWrite> dst; // the output image\n\n    param:\n        // These parameters are made available to the user.\n\n        // Camera params\n        float focalLength;\n        float horizontalAperture;\n        float nearPlane;\n        float farPlane;\n        float4x4 cameraWorldMatrix;\n\n        // Image params\n        float formatWidth;\n        float formatHeight;\n\n        float skyBoxOffsetAngle;\n        int skyFormatWidth;\n        int skyFormatHeight;\n\n        // Ray params\n        int subdivisions;\n        int raysPerPixel;\n        int maxBounces;\n        float maxRayDistance;\n        float hitTolerance;\n        float rayOffset;\n\n        // Scene params\n        int spheresTextureWidth;\n        int spheresTextureHeight;\n        int rectPrismsTextureWidth;\n        int rectPrismsTextureHeight;\n        int toriTextureHeight;\n        int toriTextureWidth;\n        int triangularPrismsTextureHeight;\n        int triangularPrismsTextureWidth;\n        int cylindersTextureHeight;\n        int cylindersTextureWidth;\n\n    local:\n        // These local variables are not exposed to the user.\n        float fieldOfView;\n        float4x4 cameraProjectionMatrix;\n        float4x4 inverseCameraProjectionMatrix;\n        float3 cameraPosition;\n        float aspect;\n\n        int numSubPixels;\n        float subdividedPixelSize;\n\n        float2 skyBoxPixelSize;\n        float skyBoxOffsetRadians;\n\n\n    // Invert a 4x4 matrix\n    bool invert4x4(const float4x4 &m, float4x4 &invOut)\n    \{\n        float4x4 inv;\n        float det;\n\n        inv\[0]\[0] =\n            m\[1]\[1]  * m\[2]\[2] * m\[3]\[3] - \n            m\[1]\[1]  * m\[2]\[3] * m\[3]\[2] - \n            m\[2]\[1]  * m\[1]\[2]  * m\[3]\[3] + \n            m\[2]\[1]  * m\[1]\[3]  * m\[3]\[2] +\n            m\[3]\[1] * m\[1]\[2]  * m\[2]\[3] - \n            m\[3]\[1] * m\[1]\[3]  * m\[2]\[2];\n\n        inv\[1]\[0] =\n            -m\[1]\[0]  * m\[2]\[2] * m\[3]\[3] + \n            m\[1]\[0]  * m\[2]\[3] * m\[3]\[2] + \n            m\[2]\[0]  * m\[1]\[2]  * m\[3]\[3] - \n            m\[2]\[0]  * m\[1]\[3]  * m\[3]\[2] - \n            m\[3]\[0] * m\[1]\[2]  * m\[2]\[3] + \n            m\[3]\[0] * m\[1]\[3]  * m\[2]\[2];\n\n        inv\[2]\[0] =\n            m\[1]\[0]  * m\[2]\[1] * m\[3]\[3] - \n            m\[1]\[0]  * m\[2]\[3] * m\[3]\[1] - \n            m\[2]\[0]  * m\[1]\[1] * m\[3]\[3] + \n            m\[2]\[0]  * m\[1]\[3] * m\[3]\[1] + \n            m\[3]\[0] * m\[1]\[1] * m\[2]\[3] - \n            m\[3]\[0] * m\[1]\[3] * m\[2]\[1];\n\n        inv\[3]\[0] =\n            -m\[1]\[0]  * m\[2]\[1] * m\[3]\[2] + \n            m\[1]\[0]  * m\[2]\[2] * m\[3]\[1] +\n            m\[2]\[0]  * m\[1]\[1] * m\[3]\[2] - \n            m\[2]\[0]  * m\[1]\[2] * m\[3]\[1] - \n            m\[3]\[0] * m\[1]\[1] * m\[2]\[2] + \n            m\[3]\[0] * m\[1]\[2] * m\[2]\[1];\n\n        inv\[0]\[1] =\n            -m\[0]\[1]  * m\[2]\[2] * m\[3]\[3] + \n            m\[0]\[1]  * m\[2]\[3] * m\[3]\[2] + \n            m\[2]\[1]  * m\[0]\[2] * m\[3]\[3] - \n            m\[2]\[1]  * m\[0]\[3] * m\[3]\[2] - \n            m\[3]\[1] * m\[0]\[2] * m\[2]\[3] + \n            m\[3]\[1] * m\[0]\[3] * m\[2]\[2];\n\n        inv\[1]\[1] =\n            m\[0]\[0]  * m\[2]\[2] * m\[3]\[3] - \n            m\[0]\[0]  * m\[2]\[3] * m\[3]\[2] - \n            m\[2]\[0]  * m\[0]\[2] * m\[3]\[3] + \n            m\[2]\[0]  * m\[0]\[3] * m\[3]\[2] + \n            m\[3]\[0] * m\[0]\[2] * m\[2]\[3] - \n            m\[3]\[0] * m\[0]\[3] * m\[2]\[2];\n\n        inv\[2]\[1] = \n            m\[0]\[0]  * m\[2]\[1] * m\[3]\[3] + \n            m\[0]\[0]  * m\[2]\[3] * m\[3]\[1] + \n            m\[2]\[0]  * m\[0]\[1] * m\[3]\[3] - \n            m\[2]\[0]  * m\[0]\[3] * m\[3]\[1] - \n            m\[3]\[0] * m\[0]\[1] * m\[2]\[3] + \n            m\[3]\[0] * m\[0]\[3] * m\[2]\[1];\n\n        inv\[3]\[1] =\n            m\[0]\[0]  * m\[2]\[1] * m\[3]\[2] - \n            m\[0]\[0]  * m\[2]\[2] * m\[3]\[1] - \n            m\[2]\[0]  * m\[0]\[1] * m\[3]\[2] + \n            m\[2]\[0]  * m\[0]\[2] * m\[3]\[1] + \n            m\[3]\[0] * m\[0]\[1] * m\[2]\[2] - \n            m\[3]\[0] * m\[0]\[2] * m\[2]\[1];\n\n        inv\[0]\[2] =\n            m\[0]\[1]  * m\[1]\[2] * m\[3]\[3] - \n            m\[0]\[1]  * m\[1]\[3] * m\[3]\[2] - \n            m\[1]\[1]  * m\[0]\[2] * m\[3]\[3] + \n            m\[1]\[1]  * m\[0]\[3] * m\[3]\[2] + \n            m\[3]\[1] * m\[0]\[2] * m\[1]\[3] - \n            m\[3]\[1] * m\[0]\[3] * m\[1]\[2];\n\n        inv\[1]\[2] =\n            -m\[0]\[0]  * m\[1]\[2] * m\[3]\[3] + \n            m\[0]\[0]  * m\[1]\[3] * m\[3]\[2] + \n            m\[1]\[0]  * m\[0]\[2] * m\[3]\[3] - \n            m\[1]\[0]  * m\[0]\[3] * m\[3]\[2] - \n            m\[3]\[0] * m\[0]\[2] * m\[1]\[3] + \n            m\[3]\[0] * m\[0]\[3] * m\[1]\[2];\n\n        inv\[2]\[2] =\n            m\[0]\[0]  * m\[1]\[1] * m\[3]\[3] - \n            m\[0]\[0]  * m\[1]\[3] * m\[3]\[1] - \n            m\[1]\[0]  * m\[0]\[1] * m\[3]\[3] + \n            m\[1]\[0]  * m\[0]\[3] * m\[3]\[1] + \n            m\[3]\[0] * m\[0]\[1] * m\[1]\[3] - \n            m\[3]\[0] * m\[0]\[3] * m\[1]\[1];\n\n        inv\[3]\[2] =\n            -m\[0]\[0]  * m\[1]\[1] * m\[3]\[2] + \n            m\[0]\[0]  * m\[1]\[2] * m\[3]\[1] + \n            m\[1]\[0]  * m\[0]\[1] * m\[3]\[2] - \n            m\[1]\[0]  * m\[0]\[2] * m\[3]\[1] - \n            m\[3]\[0] * m\[0]\[1] * m\[1]\[2] + \n            m\[3]\[0] * m\[0]\[2] * m\[1]\[1];\n\n        inv\[0]\[3] =\n            -m\[0]\[1] * m\[1]\[2] * m\[2]\[3] + \n            m\[0]\[1] * m\[1]\[3] * m\[2]\[2] + \n            m\[1]\[1] * m\[0]\[2] * m\[2]\[3] - \n            m\[1]\[1] * m\[0]\[3] * m\[2]\[2] - \n            m\[2]\[1] * m\[0]\[2] * m\[1]\[3] + \n            m\[2]\[1] * m\[0]\[3] * m\[1]\[2];\n\n        inv\[1]\[3] =\n            m\[0]\[0] * m\[1]\[2] * m\[2]\[3] - \n            m\[0]\[0] * m\[1]\[3] * m\[2]\[2] - \n            m\[1]\[0] * m\[0]\[2] * m\[2]\[3] + \n            m\[1]\[0] * m\[0]\[3] * m\[2]\[2] + \n            m\[2]\[0] * m\[0]\[2] * m\[1]\[3] - \n            m\[2]\[0] * m\[0]\[3] * m\[1]\[2];\n\n        inv\[2]\[3] =\n            -m\[0]\[0] * m\[1]\[1] * m\[2]\[3] + \n            m\[0]\[0] * m\[1]\[3] * m\[2]\[1] + \n            m\[1]\[0] * m\[0]\[1] * m\[2]\[3] - \n            m\[1]\[0] * m\[0]\[3] * m\[2]\[1] - \n            m\[2]\[0] * m\[0]\[1] * m\[1]\[3] + \n            m\[2]\[0] * m\[0]\[3] * m\[1]\[1];\n\n        inv\[3]\[3] =\n            m\[0]\[0] * m\[1]\[1] * m\[2]\[2] - \n            m\[0]\[0] * m\[1]\[2] * m\[2]\[1] - \n            m\[1]\[0] * m\[0]\[1] * m\[2]\[2] + \n            m\[1]\[0] * m\[0]\[2] * m\[2]\[1] + \n            m\[2]\[0] * m\[0]\[1] * m\[1]\[2] - \n            m\[2]\[0] * m\[0]\[2] * m\[1]\[1];\n\n        det = m\[0]\[0] * inv\[0]\[0] + m\[0]\[1] * inv\[1]\[0] + m\[0]\[2] * inv\[2]\[0] + m\[0]\[3] * inv\[3]\[0];\n\n        if (det == 0)\n            return false;\n\n        det = 1.0 / det;\n\n        for (int i=0; i < 4; i++)\n        \{\n            for (int j=0; j < 4; j++)\n            \{\n                invOut\[i]\[j] = inv\[i]\[j] * det;\n            \}\n        \}\n\n        return true;\n    \}\n\n    void matmul(float4x4 m, float4 v, float4 &out)\n    \{\n        for (int i=0; i < 4; i++)\n        \{\n            out\[i] = 0;\n\n            for (int j=0; j < 4; j++)\n            \{\n                out\[i] += m\[i]\[j] * v\[j];\n            \}\n        \}\n    \}\n\n    void positionFromWorldMatrix(float4x4 worldMatrix, float3 &position)\n    \{\n        position = float3(\n            worldMatrix\[0]\[3],\n            worldMatrix\[1]\[3],\n            worldMatrix\[2]\[3]\n        );\n    \}\n\n    // In define(), parameters can be given labels and default values.\n    void define()\n    \{\n        // Camera params\n        defineParam(focalLength, \"Focal Length\", 50.0f);\n        defineParam(horizontalAperture, \"Horizontal Aperture\", 24.576f);\n        defineParam(nearPlane, \"Near Plane\", 0.1f);\n        defineParam(farPlane, \"Far Plane\", 10000.0f);\n        defineParam(\n            cameraWorldMatrix,\n            \"Camera World Matrix\",\n            float4x4(\n                1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1\n            )\n        );\n\n        // Image params\n        defineParam(formatHeight, \"Screen Height\", 2160.0f);\n        defineParam(formatWidth, \"Screen Width\", 3840.0f);\n        defineParam(skyBoxOffsetAngle, \"SkyBox Offset Angle\", 0.0f);\n        defineParam(skyFormatHeight, \"SkyBox Height\", 1024);\n        defineParam(skyFormatWidth, \"SkyBox Width\", 2048);\n\n        // Ray params\n        defineParam(subdivisions, \"Pixel Subdivisions\", 0);\n        defineParam(maxRayDistance, \"Max Ray Distance\", 10000.0f);\n        defineParam(maxBounces, \"Max Bounces\", 1);\n        defineParam(hitTolerance, \"Hit Tolerance\", 0.001f);\n\n        // Shader params TODO make these surface spawn rays\n        defineParam(raysPerPixel, \"Rays Per Pixel\", 1);\n        defineParam(rayOffset, \"Ray Offset\", 0.0001f);\n\n        // Scene params\n        defineParam(spheresTextureHeight, \"Spheres Texture Height\", 0);\n        defineParam(spheresTextureWidth, \"Spheres Texture Width\", 0);\n        defineParam(rectPrismsTextureHeight, \"Rectangular Prisms Texture Height\", 0);\n        defineParam(rectPrismsTextureWidth, \"Rectangular Prisms Texture Width\", 0);\n        defineParam(toriTextureHeight, \"Tori Texture Height\", 0);\n        defineParam(toriTextureWidth, \"Tori Texture Width\", 0);\n        defineParam(triangularPrismsTextureHeight, \"Triangular Prisms Texture Height\", 0);\n        defineParam(triangularPrismsTextureWidth, \"Triangular Prisms Texture Width\", 0);\n        defineParam(cylindersTextureHeight, \"Cylinders Texture Height\", 0);\n        defineParam(cylindersTextureWidth, \"Cylinders Texture Width\", 0);\n    \}\n\n\n    // The init() function is run before any calls to process().\n    // Local variables can be initialized here.\n    void init()\n    \{\n        //formatWidth = formatWidth == 0 ? 1 : formatWidth;\n        //focalLength = focalLength == 0 ? 1 : focalLength;\n        //aspect = aspect == 0 ? 1 : aspect;\n        //horizontalAperture = horizontalAperture == 0 ? 1 : horizontalAperture;\n        //rayOffset = rayOffset == 0 ? 0.000001 : rayOffset;\n        float farMinusNear = farPlane - nearPlane;\n\n        // TODO use angles to allow -ve focal length like for latlongs\n        aspect = formatHeight / formatWidth;\n        fieldOfView = 2 * atan(1 / focalLength);\n        cameraProjectionMatrix = float4x4(\n            2 * focalLength / horizontalAperture, 0, 0, 0,\n            0, 2 * focalLength / horizontalAperture / aspect, 0, 0,\n            0, 0, -(farPlane + nearPlane) / farMinusNear, -2 * (farPlane * nearPlane) / farMinusNear,\n            0, 0, -1, 0\n        );\n        invert4x4(cameraProjectionMatrix, inverseCameraProjectionMatrix);\n        positionFromWorldMatrix(cameraWorldMatrix, cameraPosition);\n\n        numSubPixels = pow(2, abs(subdivisions));\n        subdividedPixelSize = 1.0f / (float) numSubPixels;\n\n        skyBoxPixelSize = float2(skyFormatWidth / (2 * PI), skyFormatHeight / PI);\n        skyBoxOffsetRadians = skyBoxOffsetAngle * PI / 180.0f;\n    \}\n\n    /**\n     * Get the value of sky the ray would hit at infinite distance\n     */\n    float4 readSkyValue(float3 rayDirection)\n    \{\n        float rayAnglePhi = fmod(acos(rayDirection.y), PI);\n        if (rayAnglePhi < 0)\n        \{\n            rayAnglePhi += PI;\n        \}\n\n        float rayAngleTheta = fmod(\n            atan2(rayDirection.z, rayDirection.x) + skyBoxOffsetRadians,\n            2 * PI\n        );\n        if (rayAngleTheta < 0)\n        \{\n            rayAngleTheta += 2 * PI;\n        \}\n\n        SampleType(skyBox) skyBoxPixel = bilinear(\n            skyBox,\n            skyBoxPixelSize.x * rayAngleTheta,\n            skyFormatHeight - (skyBoxPixelSize.y * rayAnglePhi)\n        );\n\n        return skyBoxPixel;\n    \}\n\n\n    /**\n     * Generate a ray out of the camera\n     */\n    void createCameraRay(float2 pixelLocation, float3 &rayOrigin, float3 &rayDirection)\n    \{\n        float2 uvPosition = float2(\n            2 * pixelLocation.x / formatWidth - 1,\n            2 * pixelLocation.y / formatHeight - 1\n        );\n        rayOrigin = cameraPosition;\n        float4 direction;\n        matmul(\n            inverseCameraProjectionMatrix,\n            float4(uvPosition.x, uvPosition.y, 0, 1),\n            direction\n        );\n        matmul(\n            cameraWorldMatrix,\n            float4(direction.x, direction.y, direction.z, 0),\n            direction\n        );\n        rayDirection = normalize(float3(direction.x, direction.y, direction.z));\n    \}\n\n    //\n    // Signed Distance Functions\n    //\n\n    /**\n     * Compute the signed distance from a point to a sphere\n     *\n     * @arg distanceTo: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg radius: The radius of the sphere\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToSphere(float3 distanceTo, float3 centre, float radius) \{\n        return length(centre - distanceTo) - radius;\n    \}\n\n    /**\n     * Compute the signed distance from a point to a rectangular prism\n     *\n     * @arg distanceTo: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg size: The length, width, and depth of the prism\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToRectangularPrism(float3 distanceTo, float3 centre, float3 size) \{\n        float3 boundingSphereVector = fabs(distanceTo - centre) - size;\n        float ud = length(max(boundingSphereVector, float3(0, 0, 0)));\n        float n = max(\n            max(min(boundingSphereVector.x, 0.0f), min(boundingSphereVector.y, 0.0f)),\n            min(boundingSphereVector.z, 0.0f)\n        );\n\n        return ud + n;\n    \}\n\n    /**\n     * Compute the signed distance from a point to a torus\n     *\n     * @arg distanceTo: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg radii: The inner and outer radius of the torus\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToTorus(float3 distanceTo, float3 centre, float2 radii)\n    \{\n        float3 centreVector = distanceTo - centre;\n        float2 centreXZ = float2(centreVector.x, centreVector.z);\n        float2 inner = float2(\n            length(centreXZ) - radii.y,\n            distanceTo.y - centre.y\n        );\n\n        return length(inner) - radii.x;\n    \}\n\n    /**\n     * Compute the signed distance from a point to a triangular prism\n     *\n     * @arg distanceTo: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg size: The height and depth of the prism\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToTriangularPrism(float3 distanceTo, float3 centre, float2 size) \{\n        float3 centreVector = fabs(distanceTo - centre);\n\n        return max(\n            centreVector.z - size.y,\n            max(\n                centreVector.x * 0.866025f + distanceTo.y * 0.5f,\n                -distanceTo.y\n            ) - size.x * 0.5f\n        );\n    \}\n\n    /**\n     * Compute the signed distance from a point to a cylinder\n     *\n     * @arg distanceTo: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg size: The height and radius of the cylinder\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToCylinder(float3 distanceTo, float3 centre, float2 size) \{\n        float3 centreVector = fabs(distanceTo - centre);\n\n        float2 distanceToXZ = float2(centreVector.x, centreVector.z);\n\n        float2 d = fabs(float2(length(distanceToXZ), centreVector.y)) - size;\n\n        return length(max(d, float2(0, 0))) + min(max(d.x, d.y), 0.0f);\n    \}\n\n\n    //\n    // Render Engine\n    //\n\n    /**\n     * Compute the minimum distance to an object in the scene\n     */\n    float getMinDistanceToObjectInScene(float3 rayOrigin)\n    \{\n        float distance = maxRayDistance;\n\n        for (int i=0; i < spheresTextureHeight; i++)\n        \{\n            for (int j=0; j < spheresTextureWidth; j++)\n            \{\n                SampleType(spheres) sphere = spheres(j, i);\n                distance = min(\n                    distance,\n                    distanceToSphere(\n                        rayOrigin,\n                        float3(sphere.x, sphere.y, sphere.z),\n                        sphere.w\n                    )\n                );\n            \}\n        \}\n\n        for (int i=0; i < rectPrismsTextureHeight; i++)\n        \{\n            for (int j=0; j < rectPrismsTextureWidth; j++)\n            \{\n                SampleType(rectPrisms) rectPrism = rectPrisms(j, i);\n                distance = min(\n                    distance,\n                    distanceToRectangularPrism(\n                        rayOrigin,\n                        float3(rectPrism.x, rectPrism.y, rectPrism.z),\n                        float3(rectPrism.w, rectPrism.w / 2.0f, rectPrism.w / 3.0f)\n                    )\n                );\n            \}\n        \}\n\n        for (int i=0; i < toriTextureHeight; i++)\n        \{\n            for (int j=0; j < toriTextureWidth; j++)\n            \{\n                SampleType(tori) torus = tori(j, i);\n                distance = min(\n                    distance,\n                    distanceToTorus(\n                        rayOrigin,\n                        float3(torus.x, torus.y, torus.z),\n                        float2(torus.w / 2.0f, torus.w)\n                    )\n                );\n            \}\n        \}\n\n        for (int i=0; i < triangularPrismsTextureHeight; i++)\n        \{\n            for (int j=0; j < triangularPrismsTextureWidth; j++)\n            \{\n                SampleType(triangularPrisms) triangularPrism = triangularPrisms(j, i);\n                distance = min(\n                    distance,\n                    distanceToTriangularPrism(\n                        rayOrigin,\n                        float3(triangularPrism.x, triangularPrism.y, triangularPrism.z),\n                        float2(triangularPrism.w, triangularPrism.w / 2.0f)\n                    )\n                );\n            \}\n        \}\n\n        for (int i=0; i < cylindersTextureHeight; i++)\n        \{\n            for (int j=0; j < cylindersTextureWidth; j++)\n            \{\n                SampleType(cylinders) cylinder = cylinders(j, i);\n                distance = min(\n                    distance,\n                    distanceToCylinder(\n                        rayOrigin,\n                        float3(cylinder.x, cylinder.y, cylinder.z),\n                        float2(cylinder.w / 2.0f, cylinder.w)\n                    )\n                );\n            \}\n        \}\n\n        return distance;\n    \}\n\n\n    /**\n     * March a ray through the scene\n     */\n    void marchRay(\n            float3 rayOrigin,\n            float3 rayDirection,\n            int numRays,\n            int numBounces,\n            float rayDistance,\n            float4 &resultColour\n        )\n    \{\n        float3 origin = rayOrigin;\n        float3 direction = rayDirection;\n\n        float3 rayNormal = normalize(float3(direction.y, -direction.x, 0));\n        float radialOffset = rayOffset;\n        float angularOffset = 0;\n\n\n        for (int rayNum=0; rayNum < numRays; rayNum++)\n        \{\n            int bounces = 0;\n            float distanceTravelled = 0;\n\n            while (distanceTravelled < rayDistance)\n            \{\n                float stepDistance = getMinDistanceToObjectInScene(origin);\n                distanceTravelled += stepDistance;\n\n                if (stepDistance <= hitTolerance)\n                \{\n                    bounces++;\n\n                    resultColour += float4(1, 0, 0, 1);\n\n                    break;\n                    // if (bounces == numBounces)\n                    // \{\n                    //    break;\n                    //\}\n                \}\n\n                origin += direction * stepDistance;\n            \}\n            resultColour += bounces == 0 ? readSkyValue(direction) : float4(0, 0, 0, 0);\n\n            origin = rayOrigin;\n\n            rayNormal = (\n                cos(angularOffset)\n                * rayNormal\n                + sin(angularOffset)\n                * cross(direction, rayNormal)\n            );\n\n            direction = radialOffset * rayNormal + rayDirection;\n\n            angularOffset = 90 * (1 - 0.5 * ((rayNum % 4) == 0));\n            radialOffset += rayOffset * ((rayNum % 8) == 0);\n        \}\n\n        resultColour /= raysPerPixel; // Normalize the output after multiple rays\n    \}\n\n\n    /**\n     * Compute a raymarched pixel value\n     */\n    void process(int2 pos)\n    \{\n        // Read the input to pass through\n        float4 resultPixel(0, 0, 0, 0);\n\n        float2 pixelLocation = float2((float) pos.x, (float) pos.y);\n\n        float2 pixelOffset;\n        for (\n            pixelOffset.x = 0.0f;\n            pixelOffset.x < 1.0f;\n            pixelOffset.x += subdividedPixelSize\n        ) \{\n            for (\n                pixelOffset.y = 0.0f;\n                pixelOffset.y < 1.0f;\n                pixelOffset.y += subdividedPixelSize\n            ) \{\n                // Generate a ray from the camera\n                float3 rayOrigin;\n                float3 rayDirection;\n                createCameraRay(pixelLocation + pixelOffset, rayOrigin, rayDirection);\n\n                marchRay(\n                    rayOrigin,\n                    rayDirection,\n                    raysPerPixel,\n                    maxBounces,\n                    maxRayDistance,\n                    resultPixel\n                );\n            \}\n        \}\n\n        dst() = resultPixel / numSubPixels / numSubPixels;\n    \}\n\};\n"
  rebuild ""
  "RayMarchKernel_Focal Length" {{parent.DummyCam.focal}}
  "RayMarchKernel_Horizontal Aperture" {{parent.DummyCam.haperture}}
  "RayMarchKernel_Near Plane" {{parent.DummyCam.near}}
  "RayMarchKernel_Far Plane" {{parent.DummyCam.far}}
  "RayMarchKernel_Camera World Matrix" {
      {{parent.DummyCam.world_matrix.0} {parent.DummyCam.world_matrix.1} {parent.DummyCam.world_matrix.2} {parent.DummyCam.world_matrix.3}}
      {{parent.DummyCam.world_matrix.4} {parent.DummyCam.world_matrix.5} {parent.DummyCam.world_matrix.6} {parent.DummyCam.world_matrix.7}}
      {{parent.DummyCam.world_matrix.8} {parent.DummyCam.world_matrix.9} {parent.DummyCam.world_matrix.10} {parent.DummyCam.world_matrix.11}}
      {{parent.DummyCam.world_matrix.12} {parent.DummyCam.world_matrix.13} {parent.DummyCam.world_matrix.14} {parent.DummyCam.world_matrix.15}}
    }
  "RayMarchKernel_Screen Width" {{input0.width}}
  "RayMarchKernel_Screen Height" {{input0.height}}
  "RayMarchKernel_SkyBox Width" {{input1.width}}
  "RayMarchKernel_SkyBox Height" {{input1.height}}
  "RayMarchKernel_Max Bounces" 3
  "RayMarchKernel_Spheres Texture Width" {{input2.width}}
  "RayMarchKernel_Spheres Texture Height" {{input2.height}}
  "RayMarchKernel_Rectangular Prisms Texture Width" {{input3.width}}
  "RayMarchKernel_Rectangular Prisms Texture Height" {{input3.height}}
  "RayMarchKernel_Tori Texture Height" {{input4.height}}
  "RayMarchKernel_Tori Texture Width" {{input4.width}}
  "RayMarchKernel_Triangular Prisms Texture Height" {{input5.height}}
  "RayMarchKernel_Triangular Prisms Texture Width" {{input5.width}}
  "RayMarchKernel_Cylinders Texture Height" {{input6.height}}
  "RayMarchKernel_Cylinders Texture Width" {{input6.width}}
  format "2048 1024 0 0 2048 1024 1 2K_LatLong"
  rebuild_finalise ""
  name BlinkScript1
  xpos 1792
  ypos 294
 }
 Output {
  name Output1
  xpos 1792
  ypos 625
 }
end_group
Viewer {
 frame_range 1-100
 name Viewer1
 xpos 15693
 ypos 1356
}
