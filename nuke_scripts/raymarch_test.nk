#! /usr/local/Nuke13.0v2/libnuke-13.0.2.so -nx
version 13.0 v2
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="1976" y="188" w="2504" h="1376" maximized="1" screen="0">
        <splitter orientation="1">
            <split size="40"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="1771" stretch="1"/>
            <splitter orientation="2">
                <split size="739"/>
                <dock id="" activePageId="Viewer.1">
                    <page id="Viewer.1"/>
                </dock>
                <split size="594"/>
                <dock id="" activePageId="DAG.1">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                    <page id="DAG.2"/>
                    <page id="DAG.3"/>
                    <page id="DAG.4"/>
                </dock>
            </splitter>
            <split size="685"/>
            <dock id="" activePageId="Properties.1" focus="true">
                <page id="Properties.1"/>
                <page id="uk.co.thefoundry.backgroundrenderview.1"/>
            </dock>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name /home/ob1/software/nuke/dev/raymarch/nuke_scripts/raymarch_test.nk
 frame 94
 format "2048 1556 0 0 2048 1556 1 2K_Super_35(full-ap)"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement Nuke
 workingSpaceLUT linear
 monitorLut sRGB
 monitorOutLUT rec709
 int8Lut sRGB
 int16Lut sRGB
 logLut Cineon
 floatLut linear
}
BackdropNode {
 inputs 0
 name Light
 xpos 14348
 ypos 565
 bdwidth 275
 bdheight 393
}
BackdropNode {
 inputs 0
 name Light1
 xpos 16488
 ypos 560
 bdwidth 275
 bdheight 393
}
BackdropNode {
 inputs 0
 name Lights
 xpos 14298
 ypos 517
 appearance Border
 bdwidth 369
 bdheight 506
}
BackdropNode {
 inputs 0
 name Lights1
 xpos 16438
 ypos 512
 appearance Border
 bdwidth 369
 bdheight 506
}
BackdropNode {
 inputs 0
 name Object_Properties
 xpos 15163
 ypos 567
 bdwidth 421
 bdheight 389
}
BackdropNode {
 inputs 0
 name Object_Properties1
 xpos 17303
 ypos 562
 bdwidth 421
 bdheight 389
}
BackdropNode {
 inputs 0
 name Objects
 xpos 14728
 ypos 566
 bdwidth 413
 bdheight 386
}
BackdropNode {
 inputs 0
 name Objects1
 xpos 16868
 ypos 561
 bdwidth 413
 bdheight 386
}
BackdropNode {
 inputs 0
 name Shapes
 xpos 14700
 ypos 515
 appearance Border
 bdwidth 926
 bdheight 507
}
BackdropNode {
 inputs 0
 name Shapes1
 xpos 16840
 ypos 510
 appearance Border
 bdwidth 926
 bdheight 507
}
Camera3 {
 inputs 0
 translate {0 0.5 1.5}
 rotate {-20 10 0}
 focal 8.7
 name Camera2
 xpos 16266
 ypos 600
}
Read {
 inputs 0
 file_type tiff
 file /home/ob1/software/nuke/dev/raymarch/images/light_properties.tif
 format "2 1 0 0 2 1 1 lights"
 origset true
 name Read8
 xpos 16643
 ypos 593
}
Dot {
 name Dot6
 xpos 16677
 ypos 921
}
set N8252b00 [stack 0]
Grade {
 multiply 0
 black_clamp false
 name Grade4
 xpos 16643
 ypos 1065
 disable true
}
Read {
 inputs 0
 file_type tiff
 file /home/ob1/software/nuke/dev/raymarch/images/lights.tif
 format "2 1 0 0 2 1 1 lights"
 origset true
 name Read9
 xpos 16520
 ypos 592
}
Add {
 value {5 -3 2 0}
 name Add2
 xpos 16520
 ypos 711
 disable true
}
Multiply {
 channels alpha
 value -0.5
 name Multiply5
 xpos 16520
 ypos 770
 disable true
}
Dot {
 name Dot9
 xpos 16554
 ypos 918
}
set N8234100 [stack 0]
Grade {
 multiply 0
 black_clamp false
 name Grade5
 xpos 16520
 ypos 1107
 disable true
}
Constant {
 inputs 0
 channels rgb
 format "1 1 0 0 1 1 1 empty"
 name Constant3
 xpos 17464
 ypos 612
}
Add {
 value 5
 name Add5
 xpos 17464
 ypos 731
}
Dot {
 name Dot10
 xpos 17498
 ypos 914
}
set Nf5ef6400 [stack 0]
Constant {
 inputs 0
 channels rgb
 color 0.5
 format "1 1 0 0 1 1 1 empty"
 name Constant5
 xpos 17593
 ypos 612
}
Dot {
 name Dot11
 xpos 17627
 ypos 915
}
set Nf5ef4f00 [stack 0]
Constant {
 inputs 0
 channels rgb
 color {0.5 0 0.1 0}
 format "1 1 0 0 1 1 1 empty"
 name Constant4
 xpos 17327
 ypos 608
}
Dot {
 name Dot14
 xpos 17361
 ypos 913
}
set Nf5ee3900 [stack 0]
Grade {
 multiply 0
 name Grade2
 xpos 18275
 ypos 1151
}
Constant {
 inputs 0
 channels rgb
 format "1 1 0 0 1 1 1 empty"
 name Constant2
 xpos 17155
 ypos 609
}
Add {
 value 5
 name Add3
 xpos 17155
 ypos 681
}
Dot {
 name Dot15
 xpos 17189
 ypos 916
}
set Nf5ecdd00 [stack 0]
Dot {
 inputs 0
 name Dot16
 xpos 17052
 ypos 917
}
set Nf5ecd600 [stack 0]
Constant {
 inputs 0
 channels rgb
 format "1 1 0 0 1 1 1 empty"
 name Constant1
 xpos 16895
 ypos 607
}
Dot {
 name Dot17
 xpos 16929
 ypos 916
}
set Nf5ecc100 [stack 0]
Axis3 {
 inputs 0
 rotate {-45 60 0}
 name Axis1
 xpos 16129
 ypos 562
}
Camera3 {
 translate {0 0 {curve l x17 1.6 k x100 3}}
 rotate {0 -10 {curve l x17 0 k x100 80}}
 focal 36
 name Camera3
 xpos 16129
 ypos 684
}
Dot {
 name Dot18
 xpos 16290
 ypos 1251
}
set Nf5eae400 [stack 0]
Read {
 inputs 0
 file_type exr
 file /home/ob1/software/nuke/dev/raymarch/images/ninomaru_teien_4k.exr
 format "4096 2048 0 0 4096 2048 1 4K_LatLong"
 origset true
 name Read14
 xpos 17833
 ypos 597
}
Reformat {
 type scale
 scale 0.5
 name Reformat1
 xpos 17833
 ypos 739
}
Dot {
 name Dot19
 xpos 17867
 ypos 949
}
set Nf5da5d00 [stack 0]
Group {
 inputs 10
 name RayMarcher3
 xpos 18275
 ypos 1222
}
 BackdropNode {
  inputs 0
  name Light
  xpos -498
  ypos -377
  appearance Border
  bdwidth 544
  bdheight 336
 }
 BackdropNode {
  inputs 0
  name Lights
  xpos -466
  ypos -333
  bdwidth 479
  bdheight 250
 }
 BackdropNode {
  inputs 0
  name Objects
  note_font_color 0x590000ff
  xpos 79
  ypos -376
  appearance Border
  bdwidth 1563
  bdheight 336
 }
 BackdropNode {
  inputs 0
  name Surface_Characteristics
  xpos 109
  ypos -329
  bdwidth 750
  bdheight 251
 }
 BackdropNode {
  inputs 0
  name Transform
  xpos 891
  ypos -329
  bdwidth 720
  bdheight 251
 }
 Constant {
  inputs 0
  channels rgb
  format "1 1 0 0 1 1 1 empty"
  name Constant9
  xpos -450
  ypos -246
 }
 Input {
  inputs 0
  name light_props
  xpos -340
  ypos -296
  number 9
 }
 Merge2 {
  inputs 2
  name Merge8
  xpos -340
  ypos -223
 }
 Dot {
  name Dot8
  xpos -306
  ypos -123
 }
 Constant {
  inputs 0
  channels rgb
  format {{{Constant9.format}}}
  name Constant8
  xpos -225
  ypos -244
 }
 Input {
  inputs 0
  name light
  xpos -115
  ypos -300
  number 8
 }
 Merge2 {
  inputs 2
  name Merge7
  xpos -115
  ypos -221
 }
 Dot {
  name Dot7
  xpos -81
  ypos -109
 }
 Constant {
  inputs 0
  channels rgb
  format {{{DefaultPos.format}}}
  name Constant4
  xpos 356
  ypos -236
 }
 Input {
  inputs 0
  name surface
  xpos 488
  ypos -287
  number 6
 }
 Merge2 {
  inputs 2
  name Merge3
  xpos 488
  ypos -213
 }
 Dot {
  name Dot2
  xpos 522
  ypos -104
 }
 Constant {
  inputs 0
  channels rgb
  format {{{DefaultPos.format}}}
  name Constant5
  xpos 590
  ypos -232
 }
 Input {
  inputs 0
  name shape
  xpos 744
  ypos -288
  number 7
 }
 Merge2 {
  inputs 2
  name Merge4
  xpos 744
  ypos -209
 }
 Dot {
  name Dot4
  xpos 778
  ypos -109
 }
 Constant {
  inputs 0
  channels rgb
  format {{{DefaultPos.format}}}
  name Constant6
  xpos 124
  ypos -237
 }
 Input {
  inputs 0
  name colour
  xpos 253
  ypos -292
  number 5
 }
 Merge2 {
  inputs 2
  name Merge5
  xpos 253
  ypos -214
 }
 Dot {
  name Dot5
  xpos 287
  ypos -118
 }
 Constant {
  inputs 0
  channels rgb
  format {{{DefaultPos.format}}}
  name Constant11
  xpos 1382
  ypos -236
 }
 Input {
  inputs 0
  name scale
  xpos 1511
  ypos -286
  number 4
 }
 Merge2 {
  inputs 2
  name Merge10
  xpos 1511
  ypos -213
 }
 Dot {
  name Dot10
  xpos 1545
  ypos -117
 }
 Constant {
  inputs 0
  channels rgb
  format {{{DefaultPos.format}}}
  name Constant10
  xpos 1153
  ypos -236
 }
 Input {
  inputs 0
  name rot
  xpos 1280
  ypos -287
  number 3
 }
 Merge2 {
  inputs 2
  name Merge9
  xpos 1280
  ypos -213
 }
 Dot {
  name Dot9
  xpos 1314
  ypos -115
 }
 Constant {
  inputs 0
  channels rgb
  format "1 1 0 0 1 1 1 empty"
  name DefaultPos
  xpos 916
  ypos -241
 }
 Input {
  inputs 0
  name pos
  xpos 1043
  ypos -287
  number 2
 }
 Merge2 {
  inputs 2
  name Merge6
  xpos 1043
  ypos -218
 }
 Dot {
  name Dot6
  xpos 1077
  ypos -120
 }
 Constant {
  inputs 0
  channels rgb
  format "2 1 0 0 2 1 1 lights"
  name Constant3
  xpos 1682
  ypos -230
 }
 Input {
  inputs 0
  name sky
  xpos 1792
  ypos -335
 }
 Merge2 {
  inputs 2
  name Merge1
  xpos 1792
  ypos -207
 }
 Constant {
  inputs 0
  channels rgb
  format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  name Constant1
  xpos 1971
  ypos 200
 }
 Dot {
  name Dot1
  xpos 2005
  ypos 304
 }
 BlinkScript {
  inputs 10
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/raymarch.blink
  recompileCount 468
  ProgramGroup 1
  KernelDescription "2 \"RayMarchKernel\" iterate pixelWise becf55ea7e09b14c52aa40f012574578f761937c0ddb19097a3ffe1f5c800028 11 \"bg\" Read Point \"skyBox\" Read Random \"positions\" Read Random \"rotations\" Read Random \"scales\" Read Random \"colours\" Read Random \"shapeProperties\" Read Random \"surfaceProperties\" Read Random \"lights\" Read Random \"lightProperties\" Read Random \"dst\" Write Point 28 \"Focal Length\" Float 1 AABIQg== \"Horizontal Aperture\" Float 1 ppvEQQ== \"Near Plane\" Float 1 zczMPQ== \"Far Plane\" Float 1 AEAcRg== \"Camera World Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"Screen Width\" Float 1 AABwRQ== \"Screen Height\" Float 1 AAAHRQ== \"SkyBox Offset Angle\" Float 1 AAAAAA== \"SkyBox Width\" Int 1 AAgAAA== \"SkyBox Height\" Int 1 AAQAAA== \"Pixel Subdivisions\" Int 1 AAAAAA== \"Max Bounces\" Int 1 AQAAAA== \"Max Ray Distance\" Float 1 AAB6RA== \"Hit Tolerance\" Float 1 bxKDOg== \"Shadow Bias\" Float 1 AACAPw== \"Intensity in Shadows\" Float 1 AACAPw== \"Rays Per Pixel\" Int 1 AQAAAA== \"Ray Offset\" Float 1 F7fROA== \"Object Texture Height\" Int 1 AAAAAA== \"Object Texture Width\" Int 1 AAAAAA== \"Directional Light Texture Height\" Int 1 AAAAAA== \"Directional Light Texture Width\" Int 1 AAAAAA== \"Haze Amount\" Float 1 AAAAAA== \"Haze Start\" Float 1 AAAAAA== \"Haze Distance\" Float 1 AAB6RA== \"Haze Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"Iter Glow Amount\" Float 1 AAAAAA== \"Iter Glow Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== 28 \"focalLength\" 1 1 \"horizontalAperture\" 1 1 \"nearPlane\" 1 1 \"farPlane\" 1 1 \"cameraWorldMatrix\" 16 1 \"formatWidth\" 1 1 \"formatHeight\" 1 1 \"skyBoxOffsetAngle\" 1 1 \"skyFormatWidth\" 1 1 \"skyFormatHeight\" 1 1 \"subdivisions\" 1 1 \"maxBounces\" 1 1 \"maxRayDistance\" 1 1 \"hitTolerance\" 1 1 \"shadowBias\" 1 1 \"intensityInShadow\" 1 1 \"raysPerPixel\" 1 1 \"rayOffset\" 1 1 \"objectTextureHeight\" 1 1 \"objectTextureWidth\" 1 1 \"lightTextureHeight\" 1 1 \"lightTextureWidth\" 1 1 \"hazeAmount\" 1 1 \"hazeStart\" 1 1 \"hazeDistance\" 1 1 \"hazeColour\" 4 1 \"iterGlowAmount\" 1 1 \"iterGlowColour\" 4 1 10 \"fieldOfView\" Float 1 1 AAAAAA== \"cameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"inverseCameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraPosition\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"aspect\" Float 1 1 AAAAAA== \"bouncesPerRay\" Int 1 1 AAAAAA== \"numSubPixels\" Int 1 1 AAAAAA== \"subdividedPixelSize\" Float 1 1 AAAAAA== \"skyBoxPixelSize\" Float 2 1 AAAAAAAAAAA= \"skyBoxOffsetRadians\" Float 1 1 AAAAAA=="
  kernelSource "//#include \"colour.h\"\n//#include \"mmath.h\"\n//#include \"sdfs.h\"\n\n\nkernel RayMarchKernel : ImageComputationKernel<ePixelWise>\n\{\n    // the input for format, process called once per pixel\n    Image<eRead, eAccessPoint, eEdgeNone> bg;\n\n    // the skybox in latlong format\n    Image<eRead, eAccessRandom, eEdgeNone> skyBox;\n\n\n    // the shape positons.xyz\n    Image<eRead, eAccessRandom, eEdgeNone> positions;\n\n    // the shape rotations (TODO)\n    Image<eRead, eAccessRandom, eEdgeNone> rotations;\n\n    // the shape scales.xyz (some shapes may not use all channels)\n    Image<eRead, eAccessRandom, eEdgeNone> scales;\n\n    // the shape colours.xyz\n    Image<eRead, eAccessRandom, eEdgeNone> colours;\n\n\n    // shape type.x, operation.y, numChildren.z, blend strength.w\n    // x in \[0, 1) sphere\n    // x in \[1, 2) rectangular prism\n    // x in \[2, 3) cylinder\n    // x in \[3, 4) triangular prism\n    // x in \[4, inf) torus\n    Image<eRead, eAccessRandom, eEdgeNone> shapeProperties;\n\n    // reflection.x, transmission.y, emission.z, roughness.w (TODO)\n    Image<eRead, eAccessRandom, eEdgeNone> surfaceProperties;\n\n\n    // the input directional lights direction.xyz intensity.w\n    Image<eRead, eAccessRandom, eEdgeNone> lights;\n\n    // colour.xyz, type.w\n    // w in \[0, 1) = directional, \[1, inf) = point\n    Image<eRead, eAccessRandom, eEdgeNone> lightProperties;\n\n    // the output image\n    Image<eWrite> dst;\n\n\n    param:\n        // These parameters are made available to the user.\n\n        // Camera params\n        float focalLength;\n        float horizontalAperture;\n        float nearPlane;\n        float farPlane;\n        float4x4 cameraWorldMatrix;\n\n        // Image params\n        float formatWidth;\n        float formatHeight;\n\n        float skyBoxOffsetAngle;\n        int skyFormatWidth;\n        int skyFormatHeight;\n\n        // Ray params\n        int subdivisions;\n        int maxBounces;\n        float maxRayDistance;\n        float hitTolerance;\n        float shadowBias;\n\n        // Shader params\n        float intensityInShadow;\n        int raysPerPixel;\n        float rayOffset;\n\n        // Scene params\n        // Shape Textures\n        int objectTextureHeight;\n        int objectTextureWidth;\n\n        // Light textures\n        int lightTextureHeight;\n        int lightTextureWidth;\n\n        float hazeAmount;\n        float hazeStart;\n        float hazeDistance;\n        float4 hazeColour;\n\n        float iterGlowAmount;\n        float4 iterGlowColour;\n\n    local:\n        // These local variables are not exposed to the user.\n\n        float fieldOfView;\n        float4x4 cameraProjectionMatrix;\n        float4x4 inverseCameraProjectionMatrix;\n        float3 cameraPosition;\n        float aspect;\n\n        int bouncesPerRay;\n\n        int numSubPixels;\n        float subdividedPixelSize;\n\n        float2 skyBoxPixelSize;\n        float skyBoxOffsetRadians;\n\n\n\n    // In define(), parameters can be given labels and default values.\n    void define()\n    \{\n        // Camera params\n        defineParam(focalLength, \"Focal Length\", 50.0f);\n        defineParam(horizontalAperture, \"Horizontal Aperture\", 24.576f);\n        defineParam(nearPlane, \"Near Plane\", 0.1f);\n        defineParam(farPlane, \"Far Plane\", 10000.0f);\n        defineParam(\n            cameraWorldMatrix,\n            \"Camera World Matrix\",\n            float4x4(\n                1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1\n            )\n        );\n\n        // Image params\n        defineParam(formatHeight, \"Screen Height\", 2160.0f);\n        defineParam(formatWidth, \"Screen Width\", 3840.0f);\n        defineParam(skyBoxOffsetAngle, \"SkyBox Offset Angle\", 0.0f);\n        defineParam(skyFormatHeight, \"SkyBox Height\", 1024);\n        defineParam(skyFormatWidth, \"SkyBox Width\", 2048);\n\n        // Ray params\n        defineParam(subdivisions, \"Pixel Subdivisions\", 0);\n        defineParam(maxRayDistance, \"Max Ray Distance\", 1000.0f);\n        defineParam(maxBounces, \"Max Bounces\", 1);\n        defineParam(hitTolerance, \"Hit Tolerance\", 0.001f);\n        defineParam(shadowBias, \"Shadow Bias\", 1.0f);\n\n        // Shader params TODO make these surface spawn rays\n        defineParam(intensityInShadow, \"Intensity in Shadows\", 1.0f);\n        defineParam(raysPerPixel, \"Rays Per Pixel\", 1);\n        defineParam(rayOffset, \"Ray Offset\", 0.0001f);\n\n        // Scene params\n\n        // Shape Counts\n        defineParam(objectTextureHeight, \"Object Texture Height\", 0);\n        defineParam(objectTextureWidth, \"Object Texture Width\", 0);\n\n        // Light Counts\n        defineParam(lightTextureHeight, \"Directional Light Texture Height\", 0);\n        defineParam(lightTextureWidth, \"Directional Light Texture Width\", 0);\n\n        defineParam(hazeAmount, \"Haze Amount\", 0.0f);\n        defineParam(hazeStart, \"Haze Start\", 0.0f);\n        defineParam(hazeDistance, \"Haze Distance\", 1000.0f);\n        defineParam(hazeColour, \"Haze Colour\", float4(1, 1, 1, 1));\n\n        defineParam(iterGlowAmount, \"Iter Glow Amount\", 0.0f);\n        defineParam(iterGlowColour, \"Iter Glow Colour\", float4(1, 1, 1, 1));\n    \}\n\n\n    // The init() function is run before any calls to process().\n    // Local variables can be initialized here.\n    void init()\n    \{\n        //formatWidth = formatWidth == 0 ? 1 : formatWidth;\n        //focalLength = focalLength == 0 ? 1 : focalLength;\n        //aspect = aspect == 0 ? 1 : aspect;\n        //horizontalAperture = horizontalAperture == 0 ? 1 : horizontalAperture;\n        //rayOffset = rayOffset == 0 ? 0.000001 : rayOffset;\n\n        bouncesPerRay = maxBounces <= 0 ? 1 : maxBounces;\n\n        float farMinusNear = farPlane - nearPlane;\n\n        // TODO use angles to allow -ve focal length like for latlongs\n        aspect = formatHeight / formatWidth;\n        fieldOfView = 2 * atan(1 / focalLength);\n        cameraProjectionMatrix = float4x4(\n            2 * focalLength / horizontalAperture, 0, 0, 0,\n            0, 2 * focalLength / horizontalAperture / aspect, 0, 0,\n            0, 0, -(farPlane + nearPlane) / farMinusNear, -2 * (farPlane * nearPlane) / farMinusNear,\n            0, 0, -1, 0\n        );\n        inverseCameraProjectionMatrix = cameraProjectionMatrix.invert();\n        positionFromWorldMatrix(cameraWorldMatrix, cameraPosition);\n\n        int subPixelDivisions = pow(2, abs(subdivisions));\n        subdividedPixelSize = 1.0f / (float) subPixelDivisions;\n        numSubPixels = pow(subPixelDivisions, 2);\n\n        skyBoxPixelSize = float2(skyFormatWidth / (2 * PI), skyFormatHeight / PI);\n        skyBoxOffsetRadians = skyBoxOffsetAngle * PI / 180.0f;\n    \}\n\n    /**\n     * Get the value of sky the ray would hit at infinite distance\n     */\n    float4 readSkyValue(float3 rayDirection)\n    \{\n        float rayAnglePhi = fmod(acos(rayDirection.y), PI);\n        rayAnglePhi += PI * (rayAnglePhi < 0);\n\n        float rayAngleTheta = fmod(\n            atan2(rayDirection.z, rayDirection.x) + skyBoxOffsetRadians,\n            2 * PI\n        );\n        rayAngleTheta += 2 * PI * (rayAngleTheta < 0);\n\n        SampleType(skyBox) skyBoxPixel = bilinear(\n            skyBox,\n            skyBoxPixelSize.x * rayAngleTheta,\n            skyFormatHeight - (skyBoxPixelSize.y * rayAnglePhi)\n        );\n\n        return skyBoxPixel;\n    \}\n\n\n    //\n    // Signed Distance Functions\n    //\n\n\n    /**\n     * Compute the signed distance from a point to a sphere\n     *\n     * @arg position: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg radius: The radius of the sphere\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToSphere(\n            const float3 &position,\n            const float3 &centre,\n            const float radius)\n    \{\n        return length(centre - position) - radius;\n    \}\n\n    /**\n     * Compute the signed distance from a point to a rectangular prism\n     *\n     * @arg position: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg size: The length, width, and depth of the prism\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToRectangularPrism(\n            const float3 &position,\n            const float3 &centre,\n            const float3 &size)\n    \{\n        float3 boundingSphereVector = fabs(position - centre) - size;\n        float ud = length(max(boundingSphereVector, float3(0, 0, 0)));\n        float n = max(\n            max(min(boundingSphereVector.x, 0.0f), min(boundingSphereVector.y, 0.0f)),\n            min(boundingSphereVector.z, 0.0f)\n        );\n\n        return ud + n;\n    \}\n\n    /**\n     * Compute the signed distance from a point to a torus\n     *\n     * @arg position: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg radii: The inner and outer radii of the torus\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToTorus(\n            const float3 &position,\n            const float3 &centre,\n            const float2 &radii)\n    \{\n        float3 centreVector = position - centre;\n        float2 centreXZ = float2(centreVector.x, centreVector.z);\n        float2 inner = float2(\n            length(centreXZ) - radii.y,\n            position.y - centre.y\n        );\n\n        return length(inner) - radii.x;\n    \}\n\n    /**\n     * Compute the signed distance from a point to a triangular prism\n     *\n     * @arg position: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg size: The height and depth of the prism\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToTriangularPrism(\n            const float3 &position,\n            const float3 &centre,\n            const float2 &size)\n    \{\n        float3 centreVector = fabs(position - centre);\n\n        return max(\n            centreVector.z - size.y,\n            max(\n                centreVector.x * 0.866025f + position.y * 0.5f,\n                -position.y\n            ) - size.x * 0.5f\n        );\n    \}\n\n    /**\n     * Compute the signed distance from a point to a cylinder\n     *\n     * @arg position: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg size: The height and radius of the cylinder\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToCylinder(\n            const float3 &position,\n            const float3 &centre,\n            const float2 &size)\n    \{\n        float3 centreVector = fabs(position - centre);\n\n        float2 distanceToXZ = float2(centreVector.x, centreVector.z);\n\n        float2 d = fabs(float2(length(distanceToXZ), centreVector.y)) - size;\n\n        return length(max(d, float2(0, 0))) + min(max(d.x, d.y), 0.0f);\n    \}\n\n\n    /**\n     * Compute the signed distance from a point to a mandelbulb\n     *\n     * @arg position: The point to get the distance to from the object\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToMandelbulb(\n            const float3 &position,\n            const float3 &centre,\n            const float power)\n    \{\n        float3 centreVector = position - centre;\n        float3 currentPosition = centreVector;\n        float dradius = 1;\n        float radius = 0;\n\n        for (int i = 0; i < 15; i++) \{\n            radius = length(currentPosition);\n\n            if (radius > 2) \{\n                break;\n            \}\n\n            float theta = acos(currentPosition.z / radius);\n            float phi = atan2(currentPosition.y, currentPosition.x);\n            dradius = pow(radius, power - 1.0f) * power * dradius + 1.0f;\n\n            theta = theta * power;\n            phi = phi * power;\n\n            currentPosition = pow(radius, power) * float3(\n                sin(theta) * cos(phi),\n                sin(phi) * sin(theta),\n                cos(theta)\n            );\n            currentPosition += centreVector;\n        \}\n\n        return 0.5f * log(radius) * radius / dradius;\n    \}\n\n\n    float3 positionToInfiniteRepetition(const float3 &position, const float3 &spacing)\n    \{\n        return fmod(position + 0.5f * spacing, spacing) - 0.5f * spacing;\n    \}\n\n\n    //\n    // Matrix and vector math operations\n    //\n\n\n    /**\n     * Saturate a value ie. clamp between 0 and 1\n     *\n     * @args value: The value to saturate\n     *\n     * @returns: The clamped value\n     */\n    float saturate(float value)\n    \{\n        return clamp(value, 0.0f, 1.0f);\n    \}\n\n\n    /**\n     * Get the position component of a world matrix.\n     *\n     * @arg worldMatrix: The world matrix\n     * @arg position: The location to store the position\n     */\n    void positionFromWorldMatrix(const float4x4 &worldMatrix, float3 &position)\n    \{\n        position = float3(\n            worldMatrix\[0]\[3],\n            worldMatrix\[1]\[3],\n            worldMatrix\[2]\[3]\n        );\n    \}\n\n\n    /**\n     * Multiply a 4d vector by a 4x4 matrix.\n     *\n     * @arg m: The matrix that will transform the vector\n     * @arg v: The vector to transform\n     * @arg out: The location to store the resulting vector\n     */\n    void matmul(const float4x4 &m, const float4 &v, float4 &out)\n    \{\n        for (int i=0; i < 4; i++)\n        \{\n            out\[i] = 0;\n\n            for (int j=0; j < 4; j++)\n            \{\n                out\[i] += m\[i]\[j] * v\[j];\n            \}\n        \}\n    \}\n\n\n    //\n    // Colour functions\n    //\n\n\n    float2 smoothMinN(float colour0, float colour1, float blendSize, float exponent)\n    \{\n        float m = 0.5f * pow(\n            max(blendSize - fabs(colour0 - colour1), 0.0f) / blendSize,\n            exponent\n        );\n\n        float s = m * blendSize / exponent;\n\n        return (colour0 < colour1) ? float2(colour0 - s, m) : float2(colour1 - s, m - 1.0f);\n    \}\n\n\n    /**\n     * Generate a ray out of the camera\n     */\n    void createCameraRay(float2 pixelLocation, float3 &rayOrigin, float3 &rayDirection)\n    \{\n        float2 uvPosition = float2(\n            2 * pixelLocation.x / formatWidth - 1,\n            2 * pixelLocation.y / formatHeight - 1\n        );\n        rayOrigin = cameraPosition;\n        float4 direction;\n        matmul(\n            inverseCameraProjectionMatrix,\n            float4(uvPosition.x, uvPosition.y, 0, 1),\n            direction\n        );\n        matmul(\n            cameraWorldMatrix,\n            float4(direction.x, direction.y, direction.z, 0),\n            direction\n        );\n        rayDirection = normalize(float3(direction.x, direction.y, direction.z));\n    \}\n\n\n    //\n    // Render Engine\n    //\n\n\n    float distanceToObject(\n            const float3 &position,\n            const int shapeType,\n            const float3 &objectPosition,\n            const float3 &scale)\n    \{\n        if (shapeType == 0)\n        \{\n            return distanceToSphere(position, objectPosition, scale.x);\n        \}\n        if (shapeType == 1)\n        \{\n            return distanceToRectangularPrism(position, objectPosition, scale);\n        \}\n\n        float2 size = float2(scale.x, scale.y);\n        if (shapeType == 2)\n        \{\n            return distanceToCylinder(position, objectPosition, size);\n        \}\n        if (shapeType == 3)\n        \{\n            return distanceToTriangularPrism(position, objectPosition, size);\n        \}\n        if (shapeType == 4)\n        \{\n            return distanceToTorus(position, objectPosition, size);\n        \}\n        return distanceToMandelbulb(position, objectPosition, size.x);\n    \}\n\n\n    /**\n     * Compute the minimum distance to an object in the scene\n     */\n    float getMinDistanceToObjectInScene(\n            const float3 rayOrigin,\n            float4 &colour,\n            float4 &surface)\n    \{\n        float distance = maxRayDistance;\n\n        for (int i=0; i < objectTextureHeight; i++)\n        \{\n            for (int j=0; j < objectTextureWidth; j++)\n            \{\n                SampleType(positions) position = positions(j, i);\n                //SampleType(spheres) rotation = spheres(j, i);\n                SampleType(scales) scale = scales(j, i);\n                SampleType(shapeProperties) shapeProperty = shapeProperties(j, i);\n\n                float nextDistance = distanceToObject(\n                    rayOrigin,\n                    (int) shapeProperty.x,\n                    float3(position.x, position.y, position.z),\n                    float3(scale.x, scale.y, scale.z)\n                );\n\n                if (nextDistance < distance)\n                \{\n                    distance = nextDistance;\n\n                    SampleType(colours) surfaceColour = colours(j, i);\n                    SampleType(surfaceProperties) surfaceProperty = surfaceProperties(j, i);\n\n                    colour = float4(surfaceColour);\n                    surface = float4(surfaceProperty);\n                \}\n            \}\n        \}\n\n        return distance;\n    \}\n\n\n    /**\n     * Estimate the surface normal at the closest point on the closest\n     * object to a point\n     *\n     * @arg point: The point near which to get the surface normal\n     *\n     * @returns: The normalized surface normal\n     */\n    float3 estimateSurfaceNormal(const float3 &point) \{\n        float4 colour;\n        float4 surface;\n        return normalize(\n            float3(\n                getMinDistanceToObjectInScene(\n                    float3(\n                        point.x + hitTolerance,\n                        point.y,\n                        point.z\n                    ),\n                    colour,\n                    surface\n                ) - getMinDistanceToObjectInScene(\n                    float3(\n                        point.x - hitTolerance,\n                        point.y,\n                        point.z\n                    ),\n                    colour,\n                    surface\n                ),\n                getMinDistanceToObjectInScene(\n                    float3(\n                        point.x,\n                        point.y + hitTolerance,\n                        point.z\n                    ),\n                    colour,\n                    surface\n                ) - getMinDistanceToObjectInScene(\n                    float3(\n                        point.x,\n                        point.y - hitTolerance,\n                        point.z\n                    ),\n                    colour,\n                    surface\n                ),\n                getMinDistanceToObjectInScene(\n                    float3(\n                        point.x,\n                        point.y,\n                        point.z+hitTolerance\n                    ),\n                    colour,\n                    surface\n                ) - getMinDistanceToObjectInScene(\n                    float3(\n                        point.x,\n                        point.y,\n                        point.z - hitTolerance\n                    ),\n                    colour,\n                    surface\n                )\n        ));\n    \}\n\n\n    float computeShadow(float3 rayOrigin, float3 rayDirection, float distanceToShadePoint)\n    \{\n        float distanceTravelled = 0;\n        float4 colour;\n        float4 surface;\n        while (distanceTravelled < distanceToShadePoint)\n        \{\n            float stepDistance = getMinDistanceToObjectInScene(rayOrigin, colour, surface);\n\n            if (stepDistance < hitTolerance)\n            \{\n                return intensityInShadow;\n            \}\n\n            rayOrigin += rayDirection * stepDistance;\n            distanceTravelled += stepDistance;\n        \}\n\n        return 1;\n    \}\n\n\n    static float3 offsetPoint(\n            const float3 &point,\n            const float3 &direction,\n            const float offset)\n    \{\n        return offset * direction + point;\n    \}\n\n\n    void computeDirectionalLightShadow(\n        const float3 &pointOnSurface,\n        const float3 &surfaceNormal,\n        const float3 &light,\n        float3 &lightDirection,\n        float3 &surfaceOffset,\n        float3 &shadowOffsetLightDirection,\n        float &distanceToLight)\n    \{\n        lightDirection = -light;\n        surfaceOffset = offsetPoint(\n            pointOnSurface,\n            shadowBias * (lightDirection + surfaceNormal),\n            hitTolerance\n        );\n        shadowOffsetLightDirection = lightDirection;\n\n        distanceToLight = maxRayDistance;\n    \}\n\n\n    void computePointLightShadow(\n        const float3 &pointOnSurface,\n        const float3 &surfaceNormal,\n        const float3 &light,\n        float3 &lightDirection,\n        float3 &surfaceOffset,\n        float3 &shadowOffsetLightDirection,\n        float &distanceToLight)\n    \{\n        lightDirection = light - pointOnSurface;\n        surfaceOffset = offsetPoint(\n            pointOnSurface,\n            shadowBias * (lightDirection + surfaceNormal),\n            hitTolerance\n        );\n        shadowOffsetLightDirection = light - surfaceOffset;\n\n        distanceToLight = length(shadowOffsetLightDirection);\n    \}\n\n\n    float2 lightIntensityOnSurface(\n            const float3 &pointOnSurface,\n            const float3 &surfaceNormal,\n            const float3 &light,\n            const int lightType,\n            const float intensity)\n    \{\n        float3 surfaceOffset;\n\n        float distanceToLight;\n        float3 lightDirection;\n        float3 shadowOffsetLightDirection;\n        if (lightType == 0)\n        \{\n            // directional\n            computeDirectionalLightShadow(\n                pointOnSurface,\n                surfaceNormal,\n                light,\n                lightDirection,\n                surfaceOffset,\n                shadowOffsetLightDirection,\n                distanceToLight\n            );\n        \}\n        else\n        \{\n            // point\n            computePointLightShadow(\n                pointOnSurface,\n                surfaceNormal,\n                light,\n                lightDirection,\n                surfaceOffset,\n                shadowOffsetLightDirection,\n                distanceToLight\n            );\n        \}\n\n        return float2(\n            saturate(dot(surfaceNormal, normalize(lightDirection)) * intensity),\n            computeShadow(\n                surfaceOffset,\n                normalize(shadowOffsetLightDirection),\n                distanceToLight\n            )\n        );\n    \}\n\n\n    /**\n     * Get the intensity of the light on the surface of an object\n     *\n     *\n     */\n    float computeLightIntensityOnSurface(const float3 &pointOnSurface, const float3 &surfaceNormal)\n    \{\n        float2 lightIntensity = float2(0, 0);\n\n        for (int i=0; i < lightTextureHeight; i++)\n        \{\n            for (int j=0; j < lightTextureWidth; j++)\n            \{\n                SampleType(lights) light = lights(j, i);\n                SampleType(lightProperties) lightProperty = lightProperties(j, i);\n\n                lightIntensity += lightIntensityOnSurface(\n                    pointOnSurface,\n                    surfaceNormal,\n                    float3(light.x, light.y, light.z),\n                    (int) lightProperty.w,\n                    light.w\n                );\n            \}\n        \}\n\n        return saturate(lightIntensity.x * lightIntensity.y);\n    \}\n\n\n    float3 reflectRayOffSurface(\n        const float3 &incidentRayDirection,\n        const float3 &surfaceNormalDirection)\n    \{\n        return (\n            incidentRayDirection\n            - 2 * dot(incidentRayDirection, surfaceNormalDirection) * surfaceNormalDirection\n        );\n    \}\n\n\n    float4 blend(const float4 &colour0, const float4 &colour1, const float weight)\n    \{\n        return weight * colour0 + (1 - weight) * colour1;\n    \}\n\n    float getHazeAmount(const float distance)\n    \{\n        return saturate(hazeAmount * (distance - hazeStart) / hazeDistance);\n    \}\n\n\n    /**\n     * March a ray through the scene\n     *\n     * @returns: The ray colour\n     */\n    float4 marchRay(\n            const float3 &rayOrigin,\n            const float3 &rayDirection,\n            const int numBounces,\n            const float rayDistance)\n    \{\n        float3 origin = rayOrigin;\n        float3 direction = rayDirection;\n        float4 colour;\n        float4 surface;\n\n        int bounces = 0;\n        float distanceTravelled = 0;\n\n        float lightIntensity = 1;\n\n        float4 rayColour = float4(0, 0, 0, 0);\n\n        float rayStrength = 1;\n\n        int iterations = 1;\n        while (distanceTravelled < rayDistance && rayStrength > 0)\n        \{\n            float stepDistance = getMinDistanceToObjectInScene(origin, colour, surface);\n            distanceTravelled += stepDistance;\n            origin += direction * stepDistance;\n\n            if (stepDistance < hitTolerance)\n            \{\n                bounces++;\n\n                float3 surfaceNormal = estimateSurfaceNormal(\n                    origin - direction * hitTolerance\n                );\n\n                lightIntensity = computeLightIntensityOnSurface(\n                    origin,\n                    surfaceNormal\n                );\n\n                rayColour = blend(\n                    iterGlowColour,\n                    blend(\n                        hazeColour,\n                        blend(\n                            colour,\n                            rayColour,\n                            rayStrength * (1 - surface.x) * lightIntensity\n                        ),\n                        getHazeAmount(distanceTravelled)\n                    ),\n                    iterGlowAmount * iterations\n                );\n\n                if (bounces >= numBounces)\n                \{\n                    return rayColour;\n                \}\n\n                rayStrength *= surface.x * lightIntensity;\n\n                direction = reflectRayOffSurface(\n                    direction,\n                    surfaceNormal\n                );\n                origin = offsetPoint(\n                    origin,\n                    direction + surfaceNormal,\n                    hitTolerance\n                );\n            \}\n            iterations++;\n        \}\n\n        return blend(\n            blend(\n                iterGlowColour,\n                blend(\n                    hazeColour,\n                    readSkyValue(direction),\n                    getHazeAmount(distanceTravelled)\n                ),\n                iterGlowAmount * iterations\n            ),\n            rayColour,\n            rayStrength * lightIntensity\n        );\n    \}\n\n\n    /**\n     * March rays through the scene\n     */\n    void marchRays(\n            const float3 &rayOrigin,\n            const float3 &rayDirection,\n            const int numRays,\n            const int numBounces,\n            const float rayDistance,\n            float4 &resultColour)\n    \{\n        float3 direction = rayDirection;\n\n        float3 rayNormal = normalize(float3(direction.y, -direction.x, 0));\n        float radialOffset = rayOffset;\n        float angularOffset = 0;\n\n        float4 colour;\n\n        for (int rayNum=0; rayNum < numRays; rayNum++)\n        \{\n            resultColour += marchRay(\n                rayOrigin,\n                direction,\n                numBounces,\n                rayDistance\n            );\n\n            // Update the ray direction to send a scattered cluster of rays\n            // TODO these shouldnt diverge more and more the more rays you add\n            rayNormal = (\n                cos(angularOffset)\n                * rayNormal\n                + sin(angularOffset)\n                * cross(direction, rayNormal)\n            );\n\n            direction = radialOffset * rayNormal + rayDirection;\n\n            angularOffset = 90 * (1 - 0.5 * ((rayNum % 4) == 0));\n            radialOffset += rayOffset * ((rayNum % 8) == 0);\n        \}\n\n        // Normalize the output after multiple rays\n        resultColour /= numRays;\n    \}\n\n\n    /**\n     * Compute a raymarched pixel value\n     */\n    void process(int2 pos)\n    \{\n        float4 resultPixel(0, 0, 0, 0);\n\n        float2 pixelLocation = float2(pos.x, pos.y);\n\n        float2 pixelOffset;\n        for (\n            pixelOffset.x = 0.0f;\n            pixelOffset.x < 1.0f;\n            pixelOffset.x += subdividedPixelSize\n        ) \{\n            for (\n                pixelOffset.y = 0.0f;\n                pixelOffset.y < 1.0f;\n                pixelOffset.y += subdividedPixelSize\n            ) \{\n                // Generate a ray from the camera\n                float3 rayOrigin;\n                float3 rayDirection;\n                createCameraRay(pixelLocation + pixelOffset, rayOrigin, rayDirection);\n\n                marchRays(\n                    rayOrigin,\n                    rayDirection,\n                    raysPerPixel,\n                    bouncesPerRay,\n                    maxRayDistance,\n                    resultPixel\n                );\n            \}\n        \}\n\n        dst() = resultPixel / numSubPixels;\n    \}\n\};\n"
  rebuild ""
  "RayMarchKernel_Focal Length" {{parent.DummyCam.focal}}
  "RayMarchKernel_Horizontal Aperture" {{parent.DummyCam.haperture}}
  "RayMarchKernel_Near Plane" {{parent.DummyCam.near}}
  "RayMarchKernel_Far Plane" {{parent.DummyCam.far}}
  "RayMarchKernel_Camera World Matrix" {
      {{parent.DummyCam.world_matrix.0} {parent.DummyCam.world_matrix.1} {parent.DummyCam.world_matrix.2} {parent.DummyCam.world_matrix.3}}
      {{parent.DummyCam.world_matrix.4} {parent.DummyCam.world_matrix.5} {parent.DummyCam.world_matrix.6} {parent.DummyCam.world_matrix.7}}
      {{parent.DummyCam.world_matrix.8} {parent.DummyCam.world_matrix.9} {parent.DummyCam.world_matrix.10} {parent.DummyCam.world_matrix.11}}
      {{parent.DummyCam.world_matrix.12} {parent.DummyCam.world_matrix.13} {parent.DummyCam.world_matrix.14} {parent.DummyCam.world_matrix.15}}
    }
  "RayMarchKernel_Screen Width" {{input0.width}}
  "RayMarchKernel_Screen Height" {{input0.height}}
  "RayMarchKernel_SkyBox Offset Angle" 45
  "RayMarchKernel_SkyBox Width" {{input1.width}}
  "RayMarchKernel_SkyBox Height" {{input1.height}}
  "RayMarchKernel_Pixel Subdivisions" 1
  "RayMarchKernel_Max Ray Distance" 30
  "RayMarchKernel_Hit Tolerance" 0.0001
  "RayMarchKernel_Intensity in Shadows" 0
  "RayMarchKernel_Object Texture Height" {{input2.height}}
  "RayMarchKernel_Object Texture Width" {{input2.width}}
  "RayMarchKernel_Directional Light Texture Height" {{input8.height}}
  "RayMarchKernel_Directional Light Texture Width" {{input8.width}}
  "RayMarchKernel_Haze Amount" 0.2
  "RayMarchKernel_Haze Start" 1.7
  "RayMarchKernel_Haze Distance" 0.8
  format "2048 1024 0 0 2048 1024 1 2K_LatLong"
  rebuild_finalise ""
  name BlinkScript1
  xpos 1792
  ypos 294
 }
 Output {
  name Output1
  xpos 1792
  ypos 625
 }
 Input {
  inputs 0
  name cam
  xpos -293
  ypos 137
  number 1
 }
 Camera {
  projection_mode {{"\[expression \[value the_cam]projection_mode(\[value the_frame])]"}}
  focal {{"\[expression \[value the_cam]focal(\[value the_frame])]"}}
  haperture {{"\[expression \[value the_cam]haperture(\[value the_frame])]"}}
  vaperture {{"\[expression \[value the_cam]vaperture(\[value the_frame])]"}}
  near {{"\[expression \[value the_cam]near(\[value the_frame])]"}}
  far {{"\[expression \[value the_cam]far(\[value the_frame])]"}}
  win_translate {{"\[expression \[value the_cam]win_translate.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_translate.v(\[value the_frame])]"}}
  win_scale {{"\[expression \[value the_cam]win_scale.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_scale.v(\[value the_frame])]"}}
  winroll {{"\[expression \[value the_cam]winroll(\[value the_frame])]"}}
  focal_point {{"\[expression \[value the_cam]focal_point(\[value the_frame])]"}}
  fstop {{"\[expression \[value the_cam]fstop(\[value the_frame])]"}}
  name DummyCam
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if no Camera connected. Can also be used inside of groups and gizmos, as many levels deep as you want :D All using live and super fast TCL.\n\nUpdated v1.1: Now grabs the correct frame too (thanks Erwan Leroy for the idea).\n\nUpdated v1.3: Now accepts Nuke13's Camera3\n\nadrianpueyo.com, 2019-2021"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  xpos -283
  ypos 245
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\n#DummyCam v1.3 - Updated 5 May 2021.\nset starting_point \"this.input0\"\nset default \"this.d_\"\n\n# If cam has no inputs, return the default.\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera3\" && \[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera3\"||\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{ \[class \$x]==\"Input\" \} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{ \[exists \$inp] \} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {43 the_frame +INVISIBLE}
  the_frame "\[\nset the_camera \[string trimright \[value the_cam] .]\nif \{\[exists \$the_camera]\} \{\n    return \[value \$the_camera.frame]\n\} \{ \n    return \[frame]\n\}\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l "focal length" R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {30 d_win_translate l "window translate"}
  addUserKnob {30 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 version l " " t "Updated 5 May 2021" T "<span style=\"color:#666\"><br/><b>DummyCam v1.3</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019-2021</span>"}
 }
end_group
Grade {
 blackpoint 0.015905
 whitepoint 0.033321
 white_clamp true
 name Grade3
 xpos 18275
 ypos 1258
 disable true
}
Add {
 value 0.5
 name Add7
 xpos 18275
 ypos 1301
 disable true
}
push $N8252b00
push $N8234100
push $Nf5ef6400
push $Nf5ef4f00
push $Nf5ee3900
push $Nf5ecdd00
push $Nf5ecd600
push $Nf5ecc100
push $Nf5eae400
push $Nf5da5d00
Group {
 inputs 10
 name RayMarcher2
 xpos 17833
 ypos 1247
}
 BackdropNode {
  inputs 0
  name Light
  xpos -498
  ypos -377
  appearance Border
  bdwidth 544
  bdheight 336
 }
 BackdropNode {
  inputs 0
  name Lights
  xpos -466
  ypos -333
  bdwidth 479
  bdheight 250
 }
 BackdropNode {
  inputs 0
  name Objects
  note_font_color 0x590000ff
  xpos 79
  ypos -376
  appearance Border
  bdwidth 1563
  bdheight 336
 }
 BackdropNode {
  inputs 0
  name Surface_Characteristics
  xpos 109
  ypos -329
  bdwidth 750
  bdheight 251
 }
 BackdropNode {
  inputs 0
  name Transform
  xpos 891
  ypos -329
  bdwidth 720
  bdheight 251
 }
 Constant {
  inputs 0
  channels rgb
  format "1 1 0 0 1 1 1 empty"
  name Constant9
  xpos -450
  ypos -246
 }
 Input {
  inputs 0
  name light_props
  xpos -340
  ypos -296
  number 9
 }
 Merge2 {
  inputs 2
  name Merge8
  xpos -340
  ypos -223
 }
 Dot {
  name Dot8
  xpos -306
  ypos -123
 }
 Constant {
  inputs 0
  channels rgb
  format {{{Constant9.format}}}
  name Constant8
  xpos -225
  ypos -244
 }
 Input {
  inputs 0
  name light
  xpos -115
  ypos -300
  number 8
 }
 Merge2 {
  inputs 2
  name Merge7
  xpos -115
  ypos -221
 }
 Dot {
  name Dot7
  xpos -81
  ypos -109
 }
 Constant {
  inputs 0
  channels rgb
  format {{{DefaultPos.format}}}
  name Constant4
  xpos 356
  ypos -236
 }
 Input {
  inputs 0
  name surface
  xpos 488
  ypos -287
  number 6
 }
 Merge2 {
  inputs 2
  name Merge3
  xpos 488
  ypos -213
 }
 Dot {
  name Dot2
  xpos 522
  ypos -104
 }
 Constant {
  inputs 0
  channels rgb
  format {{{DefaultPos.format}}}
  name Constant5
  xpos 590
  ypos -232
 }
 Input {
  inputs 0
  name shape
  xpos 744
  ypos -288
  number 7
 }
 Merge2 {
  inputs 2
  name Merge4
  xpos 744
  ypos -209
 }
 Dot {
  name Dot4
  xpos 778
  ypos -109
 }
 Constant {
  inputs 0
  channels rgb
  format {{{DefaultPos.format}}}
  name Constant6
  xpos 124
  ypos -237
 }
 Input {
  inputs 0
  name colour
  xpos 253
  ypos -292
  number 5
 }
 Merge2 {
  inputs 2
  name Merge5
  xpos 253
  ypos -214
 }
 Dot {
  name Dot5
  xpos 287
  ypos -118
 }
 Constant {
  inputs 0
  channels rgb
  format {{{DefaultPos.format}}}
  name Constant11
  xpos 1382
  ypos -236
 }
 Input {
  inputs 0
  name scale
  xpos 1511
  ypos -286
  number 4
 }
 Merge2 {
  inputs 2
  name Merge10
  xpos 1511
  ypos -213
 }
 Dot {
  name Dot10
  xpos 1545
  ypos -117
 }
 Constant {
  inputs 0
  channels rgb
  format {{{DefaultPos.format}}}
  name Constant10
  xpos 1153
  ypos -236
 }
 Input {
  inputs 0
  name rot
  xpos 1280
  ypos -287
  number 3
 }
 Merge2 {
  inputs 2
  name Merge9
  xpos 1280
  ypos -213
 }
 Dot {
  name Dot9
  xpos 1314
  ypos -115
 }
 Constant {
  inputs 0
  channels rgb
  format "1 1 0 0 1 1 1 empty"
  name DefaultPos
  xpos 916
  ypos -241
 }
 Input {
  inputs 0
  name pos
  xpos 1043
  ypos -287
  number 2
 }
 Merge2 {
  inputs 2
  name Merge6
  xpos 1043
  ypos -218
 }
 Dot {
  name Dot6
  xpos 1077
  ypos -120
 }
 Constant {
  inputs 0
  channels rgb
  format "2048 1024 0 0 2048 1024 1 2K_LatLong"
  name Constant3
  xpos 1682
  ypos -230
 }
 Input {
  inputs 0
  name sky
  xpos 1792
  ypos -335
 }
 Merge2 {
  inputs 2
  name Merge1
  xpos 1792
  ypos -207
 }
 Constant {
  inputs 0
  channels rgb
  format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  name Constant1
  xpos 1971
  ypos 200
 }
 Dot {
  name Dot1
  xpos 2005
  ypos 304
 }
 BlinkScript {
  inputs 10
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/raymarch.blink
  recompileCount 472
  ProgramGroup 1
  KernelDescription "2 \"RayMarchKernel\" iterate pixelWise becf55ea7e09b14c52aa40f012574578f761937c0ddb19097a3ffe1f5c800028 11 \"bg\" Read Point \"skyBox\" Read Random \"positions\" Read Random \"rotations\" Read Random \"scales\" Read Random \"colours\" Read Random \"shapeProperties\" Read Random \"surfaceProperties\" Read Random \"lights\" Read Random \"lightProperties\" Read Random \"dst\" Write Point 28 \"Focal Length\" Float 1 AABIQg== \"Horizontal Aperture\" Float 1 ppvEQQ== \"Near Plane\" Float 1 zczMPQ== \"Far Plane\" Float 1 AEAcRg== \"Camera World Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"Screen Width\" Float 1 AABwRQ== \"Screen Height\" Float 1 AAAHRQ== \"SkyBox Offset Angle\" Float 1 AAAAAA== \"SkyBox Width\" Int 1 AAgAAA== \"SkyBox Height\" Int 1 AAQAAA== \"Pixel Subdivisions\" Int 1 AAAAAA== \"Max Bounces\" Int 1 AQAAAA== \"Max Ray Distance\" Float 1 AAB6RA== \"Hit Tolerance\" Float 1 bxKDOg== \"Shadow Bias\" Float 1 AACAPw== \"Intensity in Shadows\" Float 1 AACAPw== \"Rays Per Pixel\" Int 1 AQAAAA== \"Ray Offset\" Float 1 F7fROA== \"Object Texture Height\" Int 1 AAAAAA== \"Object Texture Width\" Int 1 AAAAAA== \"Directional Light Texture Height\" Int 1 AAAAAA== \"Directional Light Texture Width\" Int 1 AAAAAA== \"Haze Amount\" Float 1 AAAAAA== \"Haze Start\" Float 1 AAAAAA== \"Haze Distance\" Float 1 AAB6RA== \"Haze Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"Iter Glow Amount\" Float 1 AAAAAA== \"Iter Glow Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== 28 \"focalLength\" 1 1 \"horizontalAperture\" 1 1 \"nearPlane\" 1 1 \"farPlane\" 1 1 \"cameraWorldMatrix\" 16 1 \"formatWidth\" 1 1 \"formatHeight\" 1 1 \"skyBoxOffsetAngle\" 1 1 \"skyFormatWidth\" 1 1 \"skyFormatHeight\" 1 1 \"subdivisions\" 1 1 \"maxBounces\" 1 1 \"maxRayDistance\" 1 1 \"hitTolerance\" 1 1 \"shadowBias\" 1 1 \"intensityInShadow\" 1 1 \"raysPerPixel\" 1 1 \"rayOffset\" 1 1 \"objectTextureHeight\" 1 1 \"objectTextureWidth\" 1 1 \"lightTextureHeight\" 1 1 \"lightTextureWidth\" 1 1 \"hazeAmount\" 1 1 \"hazeStart\" 1 1 \"hazeDistance\" 1 1 \"hazeColour\" 4 1 \"iterGlowAmount\" 1 1 \"iterGlowColour\" 4 1 10 \"fieldOfView\" Float 1 1 AAAAAA== \"cameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"inverseCameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraPosition\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"aspect\" Float 1 1 AAAAAA== \"bouncesPerRay\" Int 1 1 AAAAAA== \"numSubPixels\" Int 1 1 AAAAAA== \"subdividedPixelSize\" Float 1 1 AAAAAA== \"skyBoxPixelSize\" Float 2 1 AAAAAAAAAAA= \"skyBoxOffsetRadians\" Float 1 1 AAAAAA=="
  kernelSource "//#include \"colour.h\"\n//#include \"mmath.h\"\n//#include \"sdfs.h\"\n\n\nkernel RayMarchKernel : ImageComputationKernel<ePixelWise>\n\{\n    // the input for format, process called once per pixel\n    Image<eRead, eAccessPoint, eEdgeNone> bg;\n\n    // the skybox in latlong format\n    Image<eRead, eAccessRandom, eEdgeNone> skyBox;\n\n\n    // the shape positons.xyz\n    Image<eRead, eAccessRandom, eEdgeNone> positions;\n\n    // the shape rotations (TODO)\n    Image<eRead, eAccessRandom, eEdgeNone> rotations;\n\n    // the shape scales.xyz (some shapes may not use all channels)\n    Image<eRead, eAccessRandom, eEdgeNone> scales;\n\n    // the shape colours.xyz\n    Image<eRead, eAccessRandom, eEdgeNone> colours;\n\n\n    // shape type.x, operation.y, numChildren.z, blend strength.w\n    // x in \[0, 1) sphere\n    // x in \[1, 2) rectangular prism\n    // x in \[2, 3) cylinder\n    // x in \[3, 4) triangular prism\n    // x in \[4, inf) torus\n    Image<eRead, eAccessRandom, eEdgeNone> shapeProperties;\n\n    // reflection.x, transmission.y, emission.z, roughness.w (TODO)\n    Image<eRead, eAccessRandom, eEdgeNone> surfaceProperties;\n\n\n    // the input directional lights direction.xyz intensity.w\n    Image<eRead, eAccessRandom, eEdgeNone> lights;\n\n    // colour.xyz, type.w\n    // w in \[0, 1) = directional, \[1, inf) = point\n    Image<eRead, eAccessRandom, eEdgeNone> lightProperties;\n\n    // the output image\n    Image<eWrite> dst;\n\n\n    param:\n        // These parameters are made available to the user.\n\n        // Camera params\n        float focalLength;\n        float horizontalAperture;\n        float nearPlane;\n        float farPlane;\n        float4x4 cameraWorldMatrix;\n\n        // Image params\n        float formatWidth;\n        float formatHeight;\n\n        float skyBoxOffsetAngle;\n        int skyFormatWidth;\n        int skyFormatHeight;\n\n        // Ray params\n        int subdivisions;\n        int maxBounces;\n        float maxRayDistance;\n        float hitTolerance;\n        float shadowBias;\n\n        // Shader params\n        float intensityInShadow;\n        int raysPerPixel;\n        float rayOffset;\n\n        // Scene params\n        // Shape Textures\n        int objectTextureHeight;\n        int objectTextureWidth;\n\n        // Light textures\n        int lightTextureHeight;\n        int lightTextureWidth;\n\n        float hazeAmount;\n        float hazeStart;\n        float hazeDistance;\n        float4 hazeColour;\n\n        float iterGlowAmount;\n        float4 iterGlowColour;\n\n    local:\n        // These local variables are not exposed to the user.\n\n        float fieldOfView;\n        float4x4 cameraProjectionMatrix;\n        float4x4 inverseCameraProjectionMatrix;\n        float3 cameraPosition;\n        float aspect;\n\n        int bouncesPerRay;\n\n        int numSubPixels;\n        float subdividedPixelSize;\n\n        float2 skyBoxPixelSize;\n        float skyBoxOffsetRadians;\n\n\n\n    // In define(), parameters can be given labels and default values.\n    void define()\n    \{\n        // Camera params\n        defineParam(focalLength, \"Focal Length\", 50.0f);\n        defineParam(horizontalAperture, \"Horizontal Aperture\", 24.576f);\n        defineParam(nearPlane, \"Near Plane\", 0.1f);\n        defineParam(farPlane, \"Far Plane\", 10000.0f);\n        defineParam(\n            cameraWorldMatrix,\n            \"Camera World Matrix\",\n            float4x4(\n                1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1\n            )\n        );\n\n        // Image params\n        defineParam(formatHeight, \"Screen Height\", 2160.0f);\n        defineParam(formatWidth, \"Screen Width\", 3840.0f);\n        defineParam(skyBoxOffsetAngle, \"SkyBox Offset Angle\", 0.0f);\n        defineParam(skyFormatHeight, \"SkyBox Height\", 1024);\n        defineParam(skyFormatWidth, \"SkyBox Width\", 2048);\n\n        // Ray params\n        defineParam(subdivisions, \"Pixel Subdivisions\", 0);\n        defineParam(maxRayDistance, \"Max Ray Distance\", 1000.0f);\n        defineParam(maxBounces, \"Max Bounces\", 1);\n        defineParam(hitTolerance, \"Hit Tolerance\", 0.001f);\n        defineParam(shadowBias, \"Shadow Bias\", 1.0f);\n\n        // Shader params TODO make these surface spawn rays\n        defineParam(intensityInShadow, \"Intensity in Shadows\", 1.0f);\n        defineParam(raysPerPixel, \"Rays Per Pixel\", 1);\n        defineParam(rayOffset, \"Ray Offset\", 0.0001f);\n\n        // Scene params\n\n        // Shape Counts\n        defineParam(objectTextureHeight, \"Object Texture Height\", 0);\n        defineParam(objectTextureWidth, \"Object Texture Width\", 0);\n\n        // Light Counts\n        defineParam(lightTextureHeight, \"Directional Light Texture Height\", 0);\n        defineParam(lightTextureWidth, \"Directional Light Texture Width\", 0);\n\n        defineParam(hazeAmount, \"Haze Amount\", 0.0f);\n        defineParam(hazeStart, \"Haze Start\", 0.0f);\n        defineParam(hazeDistance, \"Haze Distance\", 1000.0f);\n        defineParam(hazeColour, \"Haze Colour\", float4(1, 1, 1, 1));\n\n        defineParam(iterGlowAmount, \"Iter Glow Amount\", 0.0f);\n        defineParam(iterGlowColour, \"Iter Glow Colour\", float4(1, 1, 1, 1));\n    \}\n\n\n    // The init() function is run before any calls to process().\n    // Local variables can be initialized here.\n    void init()\n    \{\n        //formatWidth = formatWidth == 0 ? 1 : formatWidth;\n        //focalLength = focalLength == 0 ? 1 : focalLength;\n        //aspect = aspect == 0 ? 1 : aspect;\n        //horizontalAperture = horizontalAperture == 0 ? 1 : horizontalAperture;\n        //rayOffset = rayOffset == 0 ? 0.000001 : rayOffset;\n\n        bouncesPerRay = maxBounces <= 0 ? 1 : maxBounces;\n\n        float farMinusNear = farPlane - nearPlane;\n\n        // TODO use angles to allow -ve focal length like for latlongs\n        aspect = formatHeight / formatWidth;\n        fieldOfView = 2 * atan(1 / focalLength);\n        cameraProjectionMatrix = float4x4(\n            2 * focalLength / horizontalAperture, 0, 0, 0,\n            0, 2 * focalLength / horizontalAperture / aspect, 0, 0,\n            0, 0, -(farPlane + nearPlane) / farMinusNear, -2 * (farPlane * nearPlane) / farMinusNear,\n            0, 0, -1, 0\n        );\n        inverseCameraProjectionMatrix = cameraProjectionMatrix.invert();\n        positionFromWorldMatrix(cameraWorldMatrix, cameraPosition);\n\n        int subPixelDivisions = pow(2, abs(subdivisions));\n        subdividedPixelSize = 1.0f / (float) subPixelDivisions;\n        numSubPixels = pow(subPixelDivisions, 2);\n\n        skyBoxPixelSize = float2(skyFormatWidth / (2 * PI), skyFormatHeight / PI);\n        skyBoxOffsetRadians = skyBoxOffsetAngle * PI / 180.0f;\n    \}\n\n    /**\n     * Get the value of sky the ray would hit at infinite distance\n     */\n    float4 readSkyValue(float3 rayDirection)\n    \{\n        float rayAnglePhi = fmod(acos(rayDirection.y), PI);\n        rayAnglePhi += PI * (rayAnglePhi < 0);\n\n        float rayAngleTheta = fmod(\n            atan2(rayDirection.z, rayDirection.x) + skyBoxOffsetRadians,\n            2 * PI\n        );\n        rayAngleTheta += 2 * PI * (rayAngleTheta < 0);\n\n        SampleType(skyBox) skyBoxPixel = bilinear(\n            skyBox,\n            skyBoxPixelSize.x * rayAngleTheta,\n            skyFormatHeight - (skyBoxPixelSize.y * rayAnglePhi)\n        );\n\n        return skyBoxPixel;\n    \}\n\n\n    //\n    // Signed Distance Functions\n    //\n\n\n    /**\n     * Compute the signed distance from a point to a sphere\n     *\n     * @arg position: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg radius: The radius of the sphere\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToSphere(\n            const float3 &position,\n            const float3 &centre,\n            const float radius)\n    \{\n        return length(centre - position) - radius;\n    \}\n\n    /**\n     * Compute the signed distance from a point to a rectangular prism\n     *\n     * @arg position: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg size: The length, width, and depth of the prism\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToRectangularPrism(\n            const float3 &position,\n            const float3 &centre,\n            const float3 &size)\n    \{\n        float3 boundingSphereVector = fabs(position - centre) - size;\n        float ud = length(max(boundingSphereVector, float3(0, 0, 0)));\n        float n = max(\n            max(min(boundingSphereVector.x, 0.0f), min(boundingSphereVector.y, 0.0f)),\n            min(boundingSphereVector.z, 0.0f)\n        );\n\n        return ud + n;\n    \}\n\n    /**\n     * Compute the signed distance from a point to a torus\n     *\n     * @arg position: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg radii: The inner and outer radii of the torus\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToTorus(\n            const float3 &position,\n            const float3 &centre,\n            const float2 &radii)\n    \{\n        float3 centreVector = position - centre;\n        float2 centreXZ = float2(centreVector.x, centreVector.z);\n        float2 inner = float2(\n            length(centreXZ) - radii.y,\n            position.y - centre.y\n        );\n\n        return length(inner) - radii.x;\n    \}\n\n    /**\n     * Compute the signed distance from a point to a triangular prism\n     *\n     * @arg position: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg size: The height and depth of the prism\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToTriangularPrism(\n            const float3 &position,\n            const float3 &centre,\n            const float2 &size)\n    \{\n        float3 centreVector = fabs(position - centre);\n\n        return max(\n            centreVector.z - size.y,\n            max(\n                centreVector.x * 0.866025f + position.y * 0.5f,\n                -position.y\n            ) - size.x * 0.5f\n        );\n    \}\n\n    /**\n     * Compute the signed distance from a point to a cylinder\n     *\n     * @arg position: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg size: The height and radius of the cylinder\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToCylinder(\n            const float3 &position,\n            const float3 &centre,\n            const float2 &size)\n    \{\n        float3 centreVector = fabs(position - centre);\n\n        float2 distanceToXZ = float2(centreVector.x, centreVector.z);\n\n        float2 d = fabs(float2(length(distanceToXZ), centreVector.y)) - size;\n\n        return length(max(d, float2(0, 0))) + min(max(d.x, d.y), 0.0f);\n    \}\n\n\n    /**\n     * Compute the signed distance from a point to a mandelbulb\n     *\n     * @arg position: The point to get the distance to from the object\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToMandelbulb(\n            const float3 &position,\n            const float3 &centre,\n            const float power)\n    \{\n        float3 centreVector = position - centre;\n        float3 currentPosition = centreVector;\n        float dradius = 1;\n        float radius = 0;\n\n        for (int i = 0; i < 15; i++) \{\n            radius = length(currentPosition);\n\n            if (radius > 2) \{\n                break;\n            \}\n\n            float theta = acos(currentPosition.z / radius);\n            float phi = atan2(currentPosition.y, currentPosition.x);\n            dradius = pow(radius, power - 1.0f) * power * dradius + 1.0f;\n\n            theta = theta * power;\n            phi = phi * power;\n\n            currentPosition = pow(radius, power) * float3(\n                sin(theta) * cos(phi),\n                sin(phi) * sin(theta),\n                cos(theta)\n            );\n            currentPosition += centreVector;\n        \}\n\n        return 0.5f * log(radius) * radius / dradius;\n    \}\n\n\n    float3 positionToInfiniteRepetition(const float3 &position, const float3 &spacing)\n    \{\n        return fmod(position + 0.5f * spacing, spacing) - 0.5f * spacing;\n    \}\n\n\n    //\n    // Matrix and vector math operations\n    //\n\n\n    /**\n     * Saturate a value ie. clamp between 0 and 1\n     *\n     * @args value: The value to saturate\n     *\n     * @returns: The clamped value\n     */\n    float saturate(float value)\n    \{\n        return clamp(value, 0.0f, 1.0f);\n    \}\n\n\n    /**\n     * Get the position component of a world matrix.\n     *\n     * @arg worldMatrix: The world matrix\n     * @arg position: The location to store the position\n     */\n    void positionFromWorldMatrix(const float4x4 &worldMatrix, float3 &position)\n    \{\n        position = float3(\n            worldMatrix\[0]\[3],\n            worldMatrix\[1]\[3],\n            worldMatrix\[2]\[3]\n        );\n    \}\n\n\n    /**\n     * Multiply a 4d vector by a 4x4 matrix.\n     *\n     * @arg m: The matrix that will transform the vector\n     * @arg v: The vector to transform\n     * @arg out: The location to store the resulting vector\n     */\n    void matmul(const float4x4 &m, const float4 &v, float4 &out)\n    \{\n        for (int i=0; i < 4; i++)\n        \{\n            out\[i] = 0;\n\n            for (int j=0; j < 4; j++)\n            \{\n                out\[i] += m\[i]\[j] * v\[j];\n            \}\n        \}\n    \}\n\n\n    //\n    // Colour functions\n    //\n\n\n    float2 smoothMinN(float colour0, float colour1, float blendSize, float exponent)\n    \{\n        float m = 0.5f * pow(\n            max(blendSize - fabs(colour0 - colour1), 0.0f) / blendSize,\n            exponent\n        );\n\n        float s = m * blendSize / exponent;\n\n        return (colour0 < colour1) ? float2(colour0 - s, m) : float2(colour1 - s, m - 1.0f);\n    \}\n\n\n    /**\n     * Generate a ray out of the camera\n     */\n    void createCameraRay(float2 pixelLocation, float3 &rayOrigin, float3 &rayDirection)\n    \{\n        float2 uvPosition = float2(\n            2 * pixelLocation.x / formatWidth - 1,\n            2 * pixelLocation.y / formatHeight - 1\n        );\n        rayOrigin = cameraPosition;\n        float4 direction;\n        matmul(\n            inverseCameraProjectionMatrix,\n            float4(uvPosition.x, uvPosition.y, 0, 1),\n            direction\n        );\n        matmul(\n            cameraWorldMatrix,\n            float4(direction.x, direction.y, direction.z, 0),\n            direction\n        );\n        rayDirection = normalize(float3(direction.x, direction.y, direction.z));\n    \}\n\n\n    //\n    // Render Engine\n    //\n\n\n    float distanceToObject(\n            const float3 &position,\n            const int shapeType,\n            const float3 &objectPosition,\n            const float3 &scale)\n    \{\n        if (shapeType == 0)\n        \{\n            return distanceToSphere(position, objectPosition, scale.x);\n        \}\n        if (shapeType == 1)\n        \{\n            return distanceToRectangularPrism(position, objectPosition, scale);\n        \}\n\n        float2 size = float2(scale.x, scale.y);\n        if (shapeType == 2)\n        \{\n            return distanceToCylinder(position, objectPosition, size);\n        \}\n        if (shapeType == 3)\n        \{\n            return distanceToTriangularPrism(position, objectPosition, size);\n        \}\n        if (shapeType == 4)\n        \{\n            return distanceToTorus(position, objectPosition, size);\n        \}\n        return distanceToMandelbulb(position, objectPosition, size.x);\n    \}\n\n\n    /**\n     * Compute the minimum distance to an object in the scene\n     */\n    float getMinDistanceToObjectInScene(\n            const float3 rayOrigin,\n            float4 &colour,\n            float4 &surface)\n    \{\n        float distance = maxRayDistance;\n\n        for (int i=0; i < objectTextureHeight; i++)\n        \{\n            for (int j=0; j < objectTextureWidth; j++)\n            \{\n                SampleType(positions) position = positions(j, i);\n                //SampleType(spheres) rotation = spheres(j, i);\n                SampleType(scales) scale = scales(j, i);\n                SampleType(shapeProperties) shapeProperty = shapeProperties(j, i);\n\n                float nextDistance = distanceToObject(\n                    rayOrigin,\n                    (int) shapeProperty.x,\n                    float3(position.x, position.y, position.z),\n                    float3(scale.x, scale.y, scale.z)\n                );\n\n                if (nextDistance < distance)\n                \{\n                    distance = nextDistance;\n\n                    SampleType(colours) surfaceColour = colours(j, i);\n                    SampleType(surfaceProperties) surfaceProperty = surfaceProperties(j, i);\n\n                    colour = float4(surfaceColour);\n                    surface = float4(surfaceProperty);\n                \}\n            \}\n        \}\n\n        return distance;\n    \}\n\n\n    /**\n     * Estimate the surface normal at the closest point on the closest\n     * object to a point\n     *\n     * @arg point: The point near which to get the surface normal\n     *\n     * @returns: The normalized surface normal\n     */\n    float3 estimateSurfaceNormal(const float3 &point) \{\n        float4 colour;\n        float4 surface;\n        return normalize(\n            float3(\n                getMinDistanceToObjectInScene(\n                    float3(\n                        point.x + hitTolerance,\n                        point.y,\n                        point.z\n                    ),\n                    colour,\n                    surface\n                ) - getMinDistanceToObjectInScene(\n                    float3(\n                        point.x - hitTolerance,\n                        point.y,\n                        point.z\n                    ),\n                    colour,\n                    surface\n                ),\n                getMinDistanceToObjectInScene(\n                    float3(\n                        point.x,\n                        point.y + hitTolerance,\n                        point.z\n                    ),\n                    colour,\n                    surface\n                ) - getMinDistanceToObjectInScene(\n                    float3(\n                        point.x,\n                        point.y - hitTolerance,\n                        point.z\n                    ),\n                    colour,\n                    surface\n                ),\n                getMinDistanceToObjectInScene(\n                    float3(\n                        point.x,\n                        point.y,\n                        point.z+hitTolerance\n                    ),\n                    colour,\n                    surface\n                ) - getMinDistanceToObjectInScene(\n                    float3(\n                        point.x,\n                        point.y,\n                        point.z - hitTolerance\n                    ),\n                    colour,\n                    surface\n                )\n        ));\n    \}\n\n\n    float computeShadow(float3 rayOrigin, float3 rayDirection, float distanceToShadePoint)\n    \{\n        float distanceTravelled = 0;\n        float4 colour;\n        float4 surface;\n        while (distanceTravelled < distanceToShadePoint)\n        \{\n            float stepDistance = getMinDistanceToObjectInScene(rayOrigin, colour, surface);\n\n            if (stepDistance < hitTolerance)\n            \{\n                return intensityInShadow;\n            \}\n\n            rayOrigin += rayDirection * stepDistance;\n            distanceTravelled += stepDistance;\n        \}\n\n        return 1;\n    \}\n\n\n    static float3 offsetPoint(\n            const float3 &point,\n            const float3 &direction,\n            const float offset)\n    \{\n        return offset * direction + point;\n    \}\n\n\n    void computeDirectionalLightShadow(\n        const float3 &pointOnSurface,\n        const float3 &surfaceNormal,\n        const float3 &light,\n        float3 &lightDirection,\n        float3 &surfaceOffset,\n        float3 &shadowOffsetLightDirection,\n        float &distanceToLight)\n    \{\n        lightDirection = -light;\n        surfaceOffset = offsetPoint(\n            pointOnSurface,\n            shadowBias * (lightDirection + surfaceNormal),\n            hitTolerance\n        );\n        shadowOffsetLightDirection = lightDirection;\n\n        distanceToLight = maxRayDistance;\n    \}\n\n\n    void computePointLightShadow(\n        const float3 &pointOnSurface,\n        const float3 &surfaceNormal,\n        const float3 &light,\n        float3 &lightDirection,\n        float3 &surfaceOffset,\n        float3 &shadowOffsetLightDirection,\n        float &distanceToLight)\n    \{\n        lightDirection = light - pointOnSurface;\n        surfaceOffset = offsetPoint(\n            pointOnSurface,\n            shadowBias * (lightDirection + surfaceNormal),\n            hitTolerance\n        );\n        shadowOffsetLightDirection = light - surfaceOffset;\n\n        distanceToLight = length(shadowOffsetLightDirection);\n    \}\n\n\n    float2 lightIntensityOnSurface(\n            const float3 &pointOnSurface,\n            const float3 &surfaceNormal,\n            const float3 &light,\n            const int lightType,\n            const float intensity)\n    \{\n        float3 surfaceOffset;\n\n        float distanceToLight;\n        float3 lightDirection;\n        float3 shadowOffsetLightDirection;\n        if (lightType == 0)\n        \{\n            // directional\n            computeDirectionalLightShadow(\n                pointOnSurface,\n                surfaceNormal,\n                light,\n                lightDirection,\n                surfaceOffset,\n                shadowOffsetLightDirection,\n                distanceToLight\n            );\n        \}\n        else\n        \{\n            // point\n            computePointLightShadow(\n                pointOnSurface,\n                surfaceNormal,\n                light,\n                lightDirection,\n                surfaceOffset,\n                shadowOffsetLightDirection,\n                distanceToLight\n            );\n        \}\n\n        return float2(\n            saturate(dot(surfaceNormal, normalize(lightDirection)) * intensity),\n            computeShadow(\n                surfaceOffset,\n                normalize(shadowOffsetLightDirection),\n                distanceToLight\n            )\n        );\n    \}\n\n\n    /**\n     * Get the intensity of the light on the surface of an object\n     *\n     *\n     */\n    float computeLightIntensityOnSurface(const float3 &pointOnSurface, const float3 &surfaceNormal)\n    \{\n        float2 lightIntensity = float2(0, 0);\n\n        for (int i=0; i < lightTextureHeight; i++)\n        \{\n            for (int j=0; j < lightTextureWidth; j++)\n            \{\n                SampleType(lights) light = lights(j, i);\n                SampleType(lightProperties) lightProperty = lightProperties(j, i);\n\n                lightIntensity += lightIntensityOnSurface(\n                    pointOnSurface,\n                    surfaceNormal,\n                    float3(light.x, light.y, light.z),\n                    (int) lightProperty.w,\n                    light.w\n                );\n            \}\n        \}\n\n        return saturate(lightIntensity.x * lightIntensity.y);\n    \}\n\n\n    float3 reflectRayOffSurface(\n        const float3 &incidentRayDirection,\n        const float3 &surfaceNormalDirection)\n    \{\n        return (\n            incidentRayDirection\n            - 2 * dot(incidentRayDirection, surfaceNormalDirection) * surfaceNormalDirection\n        );\n    \}\n\n\n    float4 blend(const float4 &colour0, const float4 &colour1, const float weight)\n    \{\n        return weight * colour0 + (1 - weight) * colour1;\n    \}\n\n    float getHazeAmount(const float distance)\n    \{\n        return saturate(hazeAmount * (distance - hazeStart) / hazeDistance);\n    \}\n\n\n    /**\n     * March a ray through the scene\n     *\n     * @returns: The ray colour\n     */\n    float4 marchRay(\n            const float3 &rayOrigin,\n            const float3 &rayDirection,\n            const int numBounces,\n            const float rayDistance)\n    \{\n        float3 origin = rayOrigin;\n        float3 direction = rayDirection;\n        float4 colour;\n        float4 surface;\n\n        int bounces = 0;\n        float distanceTravelled = 0;\n\n        float lightIntensity = 1;\n\n        float4 rayColour = float4(0, 0, 0, 0);\n\n        float rayStrength = 1;\n\n        int iterations = 1;\n        while (distanceTravelled < rayDistance && rayStrength > 0)\n        \{\n            float stepDistance = getMinDistanceToObjectInScene(origin, colour, surface);\n            distanceTravelled += stepDistance;\n            origin += direction * stepDistance;\n\n            if (stepDistance < hitTolerance)\n            \{\n                bounces++;\n\n                float3 surfaceNormal = estimateSurfaceNormal(\n                    origin - direction * hitTolerance\n                );\n\n                lightIntensity = computeLightIntensityOnSurface(\n                    origin,\n                    surfaceNormal\n                );\n\n                rayColour = blend(\n                    iterGlowColour,\n                    blend(\n                        hazeColour,\n                        blend(\n                            colour,\n                            rayColour,\n                            rayStrength * (1 - surface.x) * lightIntensity\n                        ),\n                        getHazeAmount(distanceTravelled)\n                    ),\n                    iterGlowAmount * iterations\n                );\n\n                if (bounces >= numBounces)\n                \{\n                    return rayColour;\n                \}\n\n                rayStrength *= surface.x * lightIntensity;\n\n                direction = reflectRayOffSurface(\n                    direction,\n                    surfaceNormal\n                );\n                origin = offsetPoint(\n                    origin,\n                    direction + surfaceNormal,\n                    hitTolerance\n                );\n            \}\n            iterations++;\n        \}\n\n        return blend(\n            blend(\n                iterGlowColour,\n                blend(\n                    hazeColour,\n                    readSkyValue(direction),\n                    getHazeAmount(distanceTravelled)\n                ),\n                iterGlowAmount * iterations\n            ),\n            rayColour,\n            rayStrength * lightIntensity\n        );\n    \}\n\n\n    /**\n     * March rays through the scene\n     */\n    void marchRays(\n            const float3 &rayOrigin,\n            const float3 &rayDirection,\n            const int numRays,\n            const int numBounces,\n            const float rayDistance,\n            float4 &resultColour)\n    \{\n        float3 direction = rayDirection;\n\n        float3 rayNormal = normalize(float3(direction.y, -direction.x, 0));\n        float radialOffset = rayOffset;\n        float angularOffset = 0;\n\n        float4 colour;\n\n        for (int rayNum=0; rayNum < numRays; rayNum++)\n        \{\n            resultColour += marchRay(\n                rayOrigin,\n                direction,\n                numBounces,\n                rayDistance\n            );\n\n            // Update the ray direction to send a scattered cluster of rays\n            // TODO these shouldnt diverge more and more the more rays you add\n            rayNormal = (\n                cos(angularOffset)\n                * rayNormal\n                + sin(angularOffset)\n                * cross(direction, rayNormal)\n            );\n\n            direction = radialOffset * rayNormal + rayDirection;\n\n            angularOffset = 90 * (1 - 0.5 * ((rayNum % 4) == 0));\n            radialOffset += rayOffset * ((rayNum % 8) == 0);\n        \}\n\n        // Normalize the output after multiple rays\n        resultColour /= numRays;\n    \}\n\n\n    /**\n     * Compute a raymarched pixel value\n     */\n    void process(int2 pos)\n    \{\n        float4 resultPixel(0, 0, 0, 0);\n\n        float2 pixelLocation = float2(pos.x, pos.y);\n\n        float2 pixelOffset;\n        for (\n            pixelOffset.x = 0.0f;\n            pixelOffset.x < 1.0f;\n            pixelOffset.x += subdividedPixelSize\n        ) \{\n            for (\n                pixelOffset.y = 0.0f;\n                pixelOffset.y < 1.0f;\n                pixelOffset.y += subdividedPixelSize\n            ) \{\n                // Generate a ray from the camera\n                float3 rayOrigin;\n                float3 rayDirection;\n                createCameraRay(pixelLocation + pixelOffset, rayOrigin, rayDirection);\n\n                marchRays(\n                    rayOrigin,\n                    rayDirection,\n                    raysPerPixel,\n                    bouncesPerRay,\n                    maxRayDistance,\n                    resultPixel\n                );\n            \}\n        \}\n\n        dst() = resultPixel / numSubPixels;\n    \}\n\};\n"
  rebuild ""
  "RayMarchKernel_Focal Length" {{parent.DummyCam.focal}}
  "RayMarchKernel_Horizontal Aperture" {{parent.DummyCam.haperture}}
  "RayMarchKernel_Near Plane" {{parent.DummyCam.near}}
  "RayMarchKernel_Far Plane" {{parent.DummyCam.far}}
  "RayMarchKernel_Camera World Matrix" {
      {{parent.DummyCam.world_matrix.0} {parent.DummyCam.world_matrix.1} {parent.DummyCam.world_matrix.2} {parent.DummyCam.world_matrix.3}}
      {{parent.DummyCam.world_matrix.4} {parent.DummyCam.world_matrix.5} {parent.DummyCam.world_matrix.6} {parent.DummyCam.world_matrix.7}}
      {{parent.DummyCam.world_matrix.8} {parent.DummyCam.world_matrix.9} {parent.DummyCam.world_matrix.10} {parent.DummyCam.world_matrix.11}}
      {{parent.DummyCam.world_matrix.12} {parent.DummyCam.world_matrix.13} {parent.DummyCam.world_matrix.14} {parent.DummyCam.world_matrix.15}}
    }
  "RayMarchKernel_Screen Width" {{input0.width}}
  "RayMarchKernel_Screen Height" {{input0.height}}
  "RayMarchKernel_SkyBox Width" {{input1.width}}
  "RayMarchKernel_SkyBox Height" {{input1.height}}
  "RayMarchKernel_Max Ray Distance" 30
  "RayMarchKernel_Hit Tolerance" 0.01
  "RayMarchKernel_Intensity in Shadows" 0
  "RayMarchKernel_Object Texture Height" {{input2.height}}
  "RayMarchKernel_Object Texture Width" {{input2.width}}
  "RayMarchKernel_Directional Light Texture Height" {{input8.height}}
  "RayMarchKernel_Directional Light Texture Width" {{input8.width}}
  "RayMarchKernel_Haze Start" 1.7
  "RayMarchKernel_Haze Distance" 0.8
  "RayMarchKernel_Iter Glow Amount" 0.007
  "RayMarchKernel_Iter Glow Colour" {0.5 0 0.4 1}
  format "2048 1024 0 0 2048 1024 1 2K_LatLong"
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos 1792
  ypos 294
 }
 Output {
  name Output1
  xpos 1792
  ypos 625
 }
 Input {
  inputs 0
  name cam
  xpos -293
  ypos 137
  number 1
 }
 Camera {
  projection_mode {{"\[expression \[value the_cam]projection_mode(\[value the_frame])]"}}
  focal {{"\[expression \[value the_cam]focal(\[value the_frame])]"}}
  haperture {{"\[expression \[value the_cam]haperture(\[value the_frame])]"}}
  vaperture {{"\[expression \[value the_cam]vaperture(\[value the_frame])]"}}
  near {{"\[expression \[value the_cam]near(\[value the_frame])]"}}
  far {{"\[expression \[value the_cam]far(\[value the_frame])]"}}
  win_translate {{"\[expression \[value the_cam]win_translate.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_translate.v(\[value the_frame])]"}}
  win_scale {{"\[expression \[value the_cam]win_scale.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_scale.v(\[value the_frame])]"}}
  winroll {{"\[expression \[value the_cam]winroll(\[value the_frame])]"}}
  focal_point {{"\[expression \[value the_cam]focal_point(\[value the_frame])]"}}
  fstop {{"\[expression \[value the_cam]fstop(\[value the_frame])]"}}
  name DummyCam
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if no Camera connected. Can also be used inside of groups and gizmos, as many levels deep as you want :D All using live and super fast TCL.\n\nUpdated v1.1: Now grabs the correct frame too (thanks Erwan Leroy for the idea).\n\nUpdated v1.3: Now accepts Nuke13's Camera3\n\nadrianpueyo.com, 2019-2021"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  xpos -283
  ypos 245
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\n#DummyCam v1.3 - Updated 5 May 2021.\nset starting_point \"this.input0\"\nset default \"this.d_\"\n\n# If cam has no inputs, return the default.\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera3\" && \[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera3\"||\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{ \[class \$x]==\"Input\" \} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{ \[exists \$inp] \} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {43 the_frame +INVISIBLE}
  the_frame "\[\nset the_camera \[string trimright \[value the_cam] .]\nif \{\[exists \$the_camera]\} \{\n    return \[value \$the_camera.frame]\n\} \{ \n    return \[frame]\n\}\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l "focal length" R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {30 d_win_translate l "window translate"}
  addUserKnob {30 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 version l " " t "Updated 5 May 2021" T "<span style=\"color:#666\"><br/><b>DummyCam v1.3</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019-2021</span>"}
 }
end_group
Copy {
 inputs 2
 from0 rgba.red
 to0 depth.Z
 name Copy1
 xpos 18275
 ypos 1355
}
ZDefocus2 {
 math depth
 center 0.045270551
 focal_point {577 378.5}
 dof 0.5
 max_size 15
 legacy_resize_mode false
 show_legacy_resize_mode false
 name ZDefocus1
 xpos 18275
 ypos 1414
}
Camera3 {
 inputs 0
 translate {1 2 0.5}
 rotate {-40 120 0}
 focal 5.7
 name Camera1
 xpos 14126
 ypos 601
}
Read {
 inputs 0
 file_type tiff
 file /home/ob1/software/nuke/dev/raymarch/images/light_properties.tif
 format "2 1 0 0 2 1 1 lights"
 origset true
 name Read5
 xpos 14503
 ypos 598
}
Dot {
 name Dot7
 xpos 14537
 ypos 926
}
Read {
 inputs 0
 file_type tiff
 file /home/ob1/software/nuke/dev/raymarch/images/lights.tif
 format "2 1 0 0 2 1 1 lights"
 origset true
 name Read4
 xpos 14380
 ypos 597
}
Add {
 value {5 -3 2 0}
 name Add1
 xpos 14380
 ypos 716
 disable true
}
Multiply {
 channels alpha
 value 0.5
 name Multiply3
 xpos 14380
 ypos 775
}
Dot {
 name Dot8
 xpos 14414
 ypos 923
}
Read {
 inputs 0
 file_type tiff
 file /home/ob1/software/nuke/dev/raymarch/images/shape.tif
 format "3 2 0 0 3 2 1 "
 origset true
 name Read2
 xpos 15324
 ypos 600
}
Add {
 value -0.1
 name Add4
 xpos 15324
 ypos 712
 disable true
}
Dot {
 name Dot1
 xpos 15358
 ypos 919
}
Read {
 inputs 0
 file_type tiff
 file /home/ob1/software/nuke/dev/raymarch/images/surfaces.tif
 format "3 2 0 0 3 2 1 "
 origset true
 name Read7
 xpos 15453
 ypos 600
}
Multiply {
 value 1.25
 name Multiply4
 xpos 15453
 ypos 711
}
Dot {
 name Dot5
 xpos 15487
 ypos 920
}
Read {
 inputs 0
 file_type tiff
 file /home/ob1/software/nuke/dev/raymarch/images/colours.tif
 format "3 2 0 0 3 2 1 "
 origset true
 name Read6
 xpos 15187
 ypos 599
}
Multiply {
 value 0.5
 name Multiply6
 xpos 15187
 ypos 724
}
Dot {
 name Dot13
 xpos 15221
 ypos 918
}
Read {
 inputs 0
 file_type tiff
 file /home/ob1/software/nuke/dev/raymarch/images/sizes_power8.tif
 format "3 2 0 0 3 2 1 "
 origset true
 name Read3
 xpos 15015
 ypos 602
}
Multiply {
 value 0.09
 name Multiply1
 xpos 15015
 ypos 731
 disable true
}
Dot {
 name Dot4
 xpos 15049
 ypos 921
}
Dot {
 inputs 0
 name Dot12
 xpos 14912
 ypos 922
}
Read {
 inputs 0
 file_type tiff
 file /home/ob1/software/nuke/dev/raymarch/images/pos.tif
 format "3 2 0 0 3 2 1 "
 origset true
 name positions
 xpos 14757
 ypos 599
}
Add {
 value {0 1 -0.1 0}
 name Add6
 xpos 14757
 ypos 718
}
Multiply {
 value 0.9
 name Multiply2
 xpos 14757
 ypos 782
}
Dot {
 name Dot3
 xpos 14789
 ypos 921
}
Axis3 {
 inputs 0
 rotate {-30 105 0}
 name Axis2
 xpos 14052
 ypos 630
}
Camera3 {
 translate {0 0 10}
 focal 41.5
 name Camera4
 xpos 14052
 ypos 752
}
Dot {
 name Dot2
 xpos 14150
 ypos 1256
}
Read {
 inputs 0
 file_type exr
 file /home/ob1/software/nuke/dev/raymarch/images/ninomaru_teien_4k.exr
 format "4096 2048 0 0 4096 2048 1 4K_LatLong"
 origset true
 name Read1
 xpos 15693
 ypos 602
}
BlinkScript {
 kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/normalize.blink
 recompileCount 1
 ProgramGroup 1
 KernelDescription "2 \"NormalizationKernel\" iterate pixelWise 5a94524fe024530fd840a25e40148131a7846c2668fed058a4f2953a27b82de4 2 \"src\" Read Point \"dst\" Write Point 0 0 0"
 kernelSource "\nkernel NormalizationKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeNone> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  void process() \{\n    // Read the input image\n    SampleType(src) input = src();\n\n    // Isolate the RGB components\n    float3 dstRGBPixel = float3(input.x, input.y, input.z);\n    dstRGBPixel = dstRGBPixel / length(dstRGBPixel);\n\n    // Write the result to the output image\n    dst() = float4(dstRGBPixel.x, dstRGBPixel.y, dstRGBPixel.z, input.w);\n  \}\n\};\n"
 rebuild ""
 rebuild_finalise ""
 name BlinkScript1
 xpos 15693
 ypos 748
 disable true
}
Grade {
 whitepoint 1.34
 black -0.003
 gamma 0.83
 name Grade1
 xpos 15693
 ypos 815
 disable true
}
Group {
 inputs 10
 name RayMarcher1
 xpos 15693
 ypos 1252
}
 BackdropNode {
  inputs 0
  name Light
  xpos -498
  ypos -377
  appearance Border
  bdwidth 544
  bdheight 336
 }
 BackdropNode {
  inputs 0
  name Lights
  xpos -466
  ypos -333
  bdwidth 479
  bdheight 250
 }
 BackdropNode {
  inputs 0
  name Objects
  note_font_color 0x590000ff
  xpos 79
  ypos -376
  appearance Border
  bdwidth 1563
  bdheight 336
 }
 BackdropNode {
  inputs 0
  name Surface_Characteristics
  xpos 109
  ypos -329
  bdwidth 750
  bdheight 251
 }
 BackdropNode {
  inputs 0
  name Transform
  xpos 891
  ypos -329
  bdwidth 720
  bdheight 251
 }
 Constant {
  inputs 0
  channels rgb
  format "1 1 0 0 1 1 1 empty"
  name Constant9
  xpos -450
  ypos -246
 }
 Input {
  inputs 0
  name light_props
  xpos -340
  ypos -296
  number 9
 }
 Merge2 {
  inputs 2
  name Merge8
  xpos -340
  ypos -223
 }
 Dot {
  name Dot8
  xpos -306
  ypos -123
 }
 Constant {
  inputs 0
  channels rgb
  format {{{Constant9.format}}}
  name Constant8
  xpos -225
  ypos -244
 }
 Input {
  inputs 0
  name light
  xpos -115
  ypos -300
  number 8
 }
 Merge2 {
  inputs 2
  name Merge7
  xpos -115
  ypos -221
 }
 Dot {
  name Dot7
  xpos -81
  ypos -109
 }
 Constant {
  inputs 0
  channels rgb
  format {{{DefaultPos.format}}}
  name Constant4
  xpos 356
  ypos -236
 }
 Input {
  inputs 0
  name surface
  xpos 488
  ypos -287
  number 6
 }
 Merge2 {
  inputs 2
  name Merge3
  xpos 488
  ypos -213
 }
 Dot {
  name Dot2
  xpos 522
  ypos -104
 }
 Constant {
  inputs 0
  channels rgb
  format {{{DefaultPos.format}}}
  name Constant5
  xpos 590
  ypos -232
 }
 Input {
  inputs 0
  name shape
  xpos 744
  ypos -288
  number 7
 }
 Merge2 {
  inputs 2
  name Merge4
  xpos 744
  ypos -209
 }
 Dot {
  name Dot4
  xpos 778
  ypos -109
 }
 Constant {
  inputs 0
  channels rgb
  format {{{DefaultPos.format}}}
  name Constant6
  xpos 124
  ypos -237
 }
 Input {
  inputs 0
  name colour
  xpos 253
  ypos -292
  number 5
 }
 Merge2 {
  inputs 2
  name Merge5
  xpos 253
  ypos -214
 }
 Dot {
  name Dot5
  xpos 287
  ypos -118
 }
 Constant {
  inputs 0
  channels rgb
  format {{{DefaultPos.format}}}
  name Constant11
  xpos 1382
  ypos -236
 }
 Input {
  inputs 0
  name scale
  xpos 1511
  ypos -286
  number 4
 }
 Merge2 {
  inputs 2
  name Merge10
  xpos 1511
  ypos -213
 }
 Dot {
  name Dot10
  xpos 1545
  ypos -117
 }
 Constant {
  inputs 0
  channels rgb
  format {{{DefaultPos.format}}}
  name Constant10
  xpos 1153
  ypos -236
 }
 Input {
  inputs 0
  name rot
  xpos 1280
  ypos -287
  number 3
 }
 Merge2 {
  inputs 2
  name Merge9
  xpos 1280
  ypos -213
 }
 Dot {
  name Dot9
  xpos 1314
  ypos -115
 }
 Constant {
  inputs 0
  channels rgb
  format "1 1 0 0 1 1 1 empty"
  name DefaultPos
  xpos 916
  ypos -241
 }
 Input {
  inputs 0
  name pos
  xpos 1043
  ypos -287
  number 2
 }
 Merge2 {
  inputs 2
  name Merge6
  xpos 1043
  ypos -218
 }
 Dot {
  name Dot6
  xpos 1077
  ypos -120
 }
 Constant {
  inputs 0
  channels rgb
  format "2048 1024 0 0 2048 1024 1 2K_LatLong"
  name Constant3
  xpos 1682
  ypos -230
 }
 Input {
  inputs 0
  name sky
  xpos 1792
  ypos -335
 }
 Merge2 {
  inputs 2
  name Merge1
  xpos 1792
  ypos -207
 }
 Constant {
  inputs 0
  channels rgb
  name Constant1
  xpos 1971
  ypos 200
 }
 Dot {
  name Dot1
  xpos 2005
  ypos 304
 }
 BlinkScript {
  inputs 10
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/raymarch.blink
  recompileCount 524
  ProgramGroup 1
  KernelDescription "2 \"RayMarchKernel\" iterate pixelWise becf55ea7e09b14c52aa40f012574578f761937c0ddb19097a3ffe1f5c800028 11 \"bg\" Read Point \"skyBox\" Read Random \"positions\" Read Random \"rotations\" Read Random \"scales\" Read Random \"colours\" Read Random \"shapeProperties\" Read Random \"surfaceProperties\" Read Random \"lights\" Read Random \"lightProperties\" Read Random \"dst\" Write Point 28 \"Focal Length\" Float 1 AABIQg== \"Horizontal Aperture\" Float 1 ppvEQQ== \"Near Plane\" Float 1 zczMPQ== \"Far Plane\" Float 1 AEAcRg== \"Camera World Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"Screen Width\" Float 1 AABwRQ== \"Screen Height\" Float 1 AAAHRQ== \"SkyBox Offset Angle\" Float 1 AAAAAA== \"SkyBox Width\" Int 1 AAgAAA== \"SkyBox Height\" Int 1 AAQAAA== \"Pixel Subdivisions\" Int 1 AAAAAA== \"Max Bounces\" Int 1 AQAAAA== \"Max Ray Distance\" Float 1 AAB6RA== \"Hit Tolerance\" Float 1 bxKDOg== \"Shadow Bias\" Float 1 AACAPw== \"Intensity in Shadows\" Float 1 AACAPw== \"Rays Per Pixel\" Int 1 AQAAAA== \"Ray Offset\" Float 1 F7fROA== \"Object Texture Height\" Int 1 AAAAAA== \"Object Texture Width\" Int 1 AAAAAA== \"Directional Light Texture Height\" Int 1 AAAAAA== \"Directional Light Texture Width\" Int 1 AAAAAA== \"Haze Amount\" Float 1 AAAAAA== \"Haze Start\" Float 1 AAAAAA== \"Haze Distance\" Float 1 AAB6RA== \"Haze Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"Iter Glow Amount\" Float 1 AAAAAA== \"Iter Glow Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== 28 \"focalLength\" 1 1 \"horizontalAperture\" 1 1 \"nearPlane\" 1 1 \"farPlane\" 1 1 \"cameraWorldMatrix\" 16 1 \"formatWidth\" 1 1 \"formatHeight\" 1 1 \"skyBoxOffsetAngle\" 1 1 \"skyFormatWidth\" 1 1 \"skyFormatHeight\" 1 1 \"subdivisions\" 1 1 \"maxBounces\" 1 1 \"maxRayDistance\" 1 1 \"hitTolerance\" 1 1 \"shadowBias\" 1 1 \"intensityInShadow\" 1 1 \"raysPerPixel\" 1 1 \"rayOffset\" 1 1 \"objectTextureHeight\" 1 1 \"objectTextureWidth\" 1 1 \"lightTextureHeight\" 1 1 \"lightTextureWidth\" 1 1 \"hazeAmount\" 1 1 \"hazeStart\" 1 1 \"hazeDistance\" 1 1 \"hazeColour\" 4 1 \"iterGlowAmount\" 1 1 \"iterGlowColour\" 4 1 10 \"fieldOfView\" Float 1 1 AAAAAA== \"cameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"inverseCameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraPosition\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"aspect\" Float 1 1 AAAAAA== \"bouncesPerRay\" Int 1 1 AAAAAA== \"numSubPixels\" Int 1 1 AAAAAA== \"subdividedPixelSize\" Float 1 1 AAAAAA== \"skyBoxPixelSize\" Float 2 1 AAAAAAAAAAA= \"skyBoxOffsetRadians\" Float 1 1 AAAAAA=="
  kernelSource "//#include \"colour.h\"\n//#include \"mmath.h\"\n//#include \"sdfs.h\"\n\n\nkernel RayMarchKernel : ImageComputationKernel<ePixelWise>\n\{\n    // the input for format, process called once per pixel\n    Image<eRead, eAccessPoint, eEdgeNone> bg;\n\n    // the skybox in latlong format\n    Image<eRead, eAccessRandom, eEdgeNone> skyBox;\n\n\n    // the shape positons.xyz\n    Image<eRead, eAccessRandom, eEdgeNone> positions;\n\n    // the shape rotations (TODO)\n    Image<eRead, eAccessRandom, eEdgeNone> rotations;\n\n    // the shape scales.xyz (some shapes may not use all channels)\n    Image<eRead, eAccessRandom, eEdgeNone> scales;\n\n    // the shape colours.xyz\n    Image<eRead, eAccessRandom, eEdgeNone> colours;\n\n\n    // shape type.x, operation.y, numChildren.z, blend strength.w\n    // x in \[0, 1) sphere\n    // x in \[1, 2) rectangular prism\n    // x in \[2, 3) cylinder\n    // x in \[3, 4) triangular prism\n    // x in \[4, inf) torus\n    Image<eRead, eAccessRandom, eEdgeNone> shapeProperties;\n\n    // reflection.x, transmission.y, emission.z, roughness.w (TODO)\n    Image<eRead, eAccessRandom, eEdgeNone> surfaceProperties;\n\n\n    // the input directional lights direction.xyz intensity.w\n    Image<eRead, eAccessRandom, eEdgeNone> lights;\n\n    // colour.xyz, type.w\n    // w in \[0, 1) = directional, \[1, inf) = point\n    Image<eRead, eAccessRandom, eEdgeNone> lightProperties;\n\n    // the output image\n    Image<eWrite> dst;\n\n\n    param:\n        // These parameters are made available to the user.\n\n        // Camera params\n        float focalLength;\n        float horizontalAperture;\n        float nearPlane;\n        float farPlane;\n        float4x4 cameraWorldMatrix;\n\n        // Image params\n        float formatWidth;\n        float formatHeight;\n\n        float skyBoxOffsetAngle;\n        int skyFormatWidth;\n        int skyFormatHeight;\n\n        // Ray params\n        int subdivisions;\n        int maxBounces;\n        float maxRayDistance;\n        float hitTolerance;\n        float shadowBias;\n\n        // Shader params\n        float intensityInShadow;\n        int raysPerPixel;\n        float rayOffset;\n\n        // Scene params\n        // Shape Textures\n        int objectTextureHeight;\n        int objectTextureWidth;\n\n        // Light textures\n        int lightTextureHeight;\n        int lightTextureWidth;\n\n        float hazeAmount;\n        float hazeStart;\n        float hazeDistance;\n        float4 hazeColour;\n\n        float iterGlowAmount;\n        float4 iterGlowColour;\n\n    local:\n        // These local variables are not exposed to the user.\n\n        float fieldOfView;\n        float4x4 cameraProjectionMatrix;\n        float4x4 inverseCameraProjectionMatrix;\n        float3 cameraPosition;\n        float aspect;\n\n        int bouncesPerRay;\n\n        int numSubPixels;\n        float subdividedPixelSize;\n\n        float2 skyBoxPixelSize;\n        float skyBoxOffsetRadians;\n\n\n\n    // In define(), parameters can be given labels and default values.\n    void define()\n    \{\n        // Camera params\n        defineParam(focalLength, \"Focal Length\", 50.0f);\n        defineParam(horizontalAperture, \"Horizontal Aperture\", 24.576f);\n        defineParam(nearPlane, \"Near Plane\", 0.1f);\n        defineParam(farPlane, \"Far Plane\", 10000.0f);\n        defineParam(\n            cameraWorldMatrix,\n            \"Camera World Matrix\",\n            float4x4(\n                1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1\n            )\n        );\n\n        // Image params\n        defineParam(formatHeight, \"Screen Height\", 2160.0f);\n        defineParam(formatWidth, \"Screen Width\", 3840.0f);\n        defineParam(skyBoxOffsetAngle, \"SkyBox Offset Angle\", 0.0f);\n        defineParam(skyFormatHeight, \"SkyBox Height\", 1024);\n        defineParam(skyFormatWidth, \"SkyBox Width\", 2048);\n\n        // Ray params\n        defineParam(subdivisions, \"Pixel Subdivisions\", 0);\n        defineParam(maxRayDistance, \"Max Ray Distance\", 1000.0f);\n        defineParam(maxBounces, \"Max Bounces\", 1);\n        defineParam(hitTolerance, \"Hit Tolerance\", 0.001f);\n        defineParam(shadowBias, \"Shadow Bias\", 1.0f);\n\n        // Shader params TODO make these surface spawn rays\n        defineParam(intensityInShadow, \"Intensity in Shadows\", 1.0f);\n        defineParam(raysPerPixel, \"Rays Per Pixel\", 1);\n        defineParam(rayOffset, \"Ray Offset\", 0.0001f);\n\n        // Scene params\n\n        // Shape Counts\n        defineParam(objectTextureHeight, \"Object Texture Height\", 0);\n        defineParam(objectTextureWidth, \"Object Texture Width\", 0);\n\n        // Light Counts\n        defineParam(lightTextureHeight, \"Directional Light Texture Height\", 0);\n        defineParam(lightTextureWidth, \"Directional Light Texture Width\", 0);\n\n        defineParam(hazeAmount, \"Haze Amount\", 0.0f);\n        defineParam(hazeStart, \"Haze Start\", 0.0f);\n        defineParam(hazeDistance, \"Haze Distance\", 1000.0f);\n        defineParam(hazeColour, \"Haze Colour\", float4(1, 1, 1, 1));\n\n        defineParam(iterGlowAmount, \"Iter Glow Amount\", 0.0f);\n        defineParam(iterGlowColour, \"Iter Glow Colour\", float4(1, 1, 1, 1));\n    \}\n\n\n    // The init() function is run before any calls to process().\n    // Local variables can be initialized here.\n    void init()\n    \{\n        //formatWidth = formatWidth == 0 ? 1 : formatWidth;\n        //focalLength = focalLength == 0 ? 1 : focalLength;\n        //aspect = aspect == 0 ? 1 : aspect;\n        //horizontalAperture = horizontalAperture == 0 ? 1 : horizontalAperture;\n        //rayOffset = rayOffset == 0 ? 0.000001 : rayOffset;\n\n        bouncesPerRay = maxBounces <= 0 ? 1 : maxBounces;\n\n        float farMinusNear = farPlane - nearPlane;\n\n        // TODO use angles to allow -ve focal length like for latlongs\n        aspect = formatHeight / formatWidth;\n        fieldOfView = 2 * atan(1 / focalLength);\n        cameraProjectionMatrix = float4x4(\n            2 * focalLength / horizontalAperture, 0, 0, 0,\n            0, 2 * focalLength / horizontalAperture / aspect, 0, 0,\n            0, 0, -(farPlane + nearPlane) / farMinusNear, -2 * (farPlane * nearPlane) / farMinusNear,\n            0, 0, -1, 0\n        );\n        inverseCameraProjectionMatrix = cameraProjectionMatrix.invert();\n        positionFromWorldMatrix(cameraWorldMatrix, cameraPosition);\n\n        int subPixelDivisions = pow(2, abs(subdivisions));\n        subdividedPixelSize = 1.0f / (float) subPixelDivisions;\n        numSubPixels = pow(subPixelDivisions, 2);\n\n        skyBoxPixelSize = float2(skyFormatWidth / (2 * PI), skyFormatHeight / PI);\n        skyBoxOffsetRadians = skyBoxOffsetAngle * PI / 180.0f;\n    \}\n\n    /**\n     * Get the value of sky the ray would hit at infinite distance\n     */\n    float4 readSkyValue(float3 rayDirection)\n    \{\n        float rayAnglePhi = fmod(acos(rayDirection.y), PI);\n        rayAnglePhi += PI * (rayAnglePhi < 0);\n\n        float rayAngleTheta = fmod(\n            atan2(rayDirection.z, rayDirection.x) + skyBoxOffsetRadians,\n            2 * PI\n        );\n        rayAngleTheta += 2 * PI * (rayAngleTheta < 0);\n\n        SampleType(skyBox) skyBoxPixel = bilinear(\n            skyBox,\n            skyBoxPixelSize.x * rayAngleTheta,\n            skyFormatHeight - (skyBoxPixelSize.y * rayAnglePhi)\n        );\n\n        return skyBoxPixel;\n    \}\n\n\n    //\n    // Signed Distance Functions\n    //\n\n\n    /**\n     * Compute the signed distance from a point to a sphere\n     *\n     * @arg position: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg radius: The radius of the sphere\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToSphere(\n            const float3 &position,\n            const float3 &centre,\n            const float radius)\n    \{\n        return length(centre - position) - radius;\n    \}\n\n    /**\n     * Compute the signed distance from a point to a rectangular prism\n     *\n     * @arg position: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg size: The length, width, and depth of the prism\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToRectangularPrism(\n            const float3 &position,\n            const float3 &centre,\n            const float3 &size)\n    \{\n        float3 boundingSphereVector = fabs(position - centre) - size;\n        float ud = length(max(boundingSphereVector, float3(0, 0, 0)));\n        float n = max(\n            max(min(boundingSphereVector.x, 0.0f), min(boundingSphereVector.y, 0.0f)),\n            min(boundingSphereVector.z, 0.0f)\n        );\n\n        return ud + n;\n    \}\n\n    /**\n     * Compute the signed distance from a point to a torus\n     *\n     * @arg position: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg radii: The inner and outer radii of the torus\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToTorus(\n            const float3 &position,\n            const float3 &centre,\n            const float2 &radii)\n    \{\n        float3 centreVector = position - centre;\n        float2 centreXZ = float2(centreVector.x, centreVector.z);\n        float2 inner = float2(\n            length(centreXZ) - radii.y,\n            position.y - centre.y\n        );\n\n        return length(inner) - radii.x;\n    \}\n\n    /**\n     * Compute the signed distance from a point to a triangular prism\n     *\n     * @arg position: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg size: The height and depth of the prism\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToTriangularPrism(\n            const float3 &position,\n            const float3 &centre,\n            const float2 &size)\n    \{\n        float3 centreVector = fabs(position - centre);\n\n        return max(\n            centreVector.z - size.y,\n            max(\n                centreVector.x * 0.866025f + position.y * 0.5f,\n                -position.y\n            ) - size.x * 0.5f\n        );\n    \}\n\n    /**\n     * Compute the signed distance from a point to a cylinder\n     *\n     * @arg position: The point to get the distance to from the object\n     * @arg centre: The object centre\n     * @arg size: The height and radius of the cylinder\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToCylinder(\n            const float3 &position,\n            const float3 &centre,\n            const float2 &size)\n    \{\n        float3 centreVector = fabs(position - centre);\n\n        float2 distanceToXZ = float2(centreVector.x, centreVector.z);\n\n        float2 d = fabs(float2(length(distanceToXZ), centreVector.y)) - size;\n\n        return length(max(d, float2(0, 0))) + min(max(d.x, d.y), 0.0f);\n    \}\n\n\n    /**\n     * Compute the signed distance from a point to a mandelbulb\n     *\n     * @arg position: The point to get the distance to from the object\n     *\n     * @returns: The minimum distance from the point to the shape\n     */\n    float distanceToMandelbulb(\n            const float3 &position,\n            const float3 &centre,\n            const float power)\n    \{\n        float3 centreVector = position - centre;\n        float3 currentPosition = centreVector;\n        float dradius = 1;\n        float radius = 0;\n\n        for (int i = 0; i < 15; i++) \{\n            radius = length(currentPosition);\n\n            if (radius > 2) \{\n                break;\n            \}\n\n            float theta = acos(currentPosition.z / radius);\n            float phi = atan2(currentPosition.y, currentPosition.x);\n            dradius = pow(radius, power - 1.0f) * power * dradius + 1.0f;\n\n            theta = theta * power;\n            phi = phi * power;\n\n            currentPosition = pow(radius, power) * float3(\n                sin(theta) * cos(phi),\n                sin(phi) * sin(theta),\n                cos(theta)\n            );\n            currentPosition += centreVector;\n        \}\n\n        return 0.5f * log(radius) * radius / dradius;\n    \}\n\n\n    float3 positionToInfiniteRepetition(const float3 &position, const float3 &spacing)\n    \{\n        return fmod(position + 0.5f * spacing, spacing) - 0.5f * spacing;\n    \}\n\n\n    //\n    // Matrix and vector math operations\n    //\n\n\n    /**\n     * Saturate a value ie. clamp between 0 and 1\n     *\n     * @args value: The value to saturate\n     *\n     * @returns: The clamped value\n     */\n    float saturate(float value)\n    \{\n        return clamp(value, 0.0f, 1.0f);\n    \}\n\n\n    /**\n     * Get the position component of a world matrix.\n     *\n     * @arg worldMatrix: The world matrix\n     * @arg position: The location to store the position\n     */\n    void positionFromWorldMatrix(const float4x4 &worldMatrix, float3 &position)\n    \{\n        position = float3(\n            worldMatrix\[0]\[3],\n            worldMatrix\[1]\[3],\n            worldMatrix\[2]\[3]\n        );\n    \}\n\n\n    /**\n     * Multiply a 4d vector by a 4x4 matrix.\n     *\n     * @arg m: The matrix that will transform the vector\n     * @arg v: The vector to transform\n     * @arg out: The location to store the resulting vector\n     */\n    void matmul(const float4x4 &m, const float4 &v, float4 &out)\n    \{\n        for (int i=0; i < 4; i++)\n        \{\n            out\[i] = 0;\n\n            for (int j=0; j < 4; j++)\n            \{\n                out\[i] += m\[i]\[j] * v\[j];\n            \}\n        \}\n    \}\n\n\n    //\n    // Colour functions\n    //\n\n\n    float2 smoothMinN(float colour0, float colour1, float blendSize, float exponent)\n    \{\n        float m = 0.5f * pow(\n            max(blendSize - fabs(colour0 - colour1), 0.0f) / blendSize,\n            exponent\n        );\n\n        float s = m * blendSize / exponent;\n\n        return (colour0 < colour1) ? float2(colour0 - s, m) : float2(colour1 - s, m - 1.0f);\n    \}\n\n\n    /**\n     * Generate a ray out of the camera\n     */\n    void createCameraRay(float2 pixelLocation, float3 &rayOrigin, float3 &rayDirection)\n    \{\n        float2 uvPosition = float2(\n            2 * pixelLocation.x / formatWidth - 1,\n            2 * pixelLocation.y / formatHeight - 1\n        );\n        rayOrigin = cameraPosition;\n        float4 direction;\n        matmul(\n            inverseCameraProjectionMatrix,\n            float4(uvPosition.x, uvPosition.y, 0, 1),\n            direction\n        );\n        matmul(\n            cameraWorldMatrix,\n            float4(direction.x, direction.y, direction.z, 0),\n            direction\n        );\n        rayDirection = normalize(float3(direction.x, direction.y, direction.z));\n    \}\n\n\n    //\n    // Render Engine\n    //\n\n\n    float distanceToObject(\n            const float3 &position,\n            const int shapeType,\n            const float3 &objectPosition,\n            const float3 &scale)\n    \{\n        if (shapeType == 0)\n        \{\n            return distanceToSphere(position, objectPosition, scale.x);\n        \}\n        if (shapeType == 1)\n        \{\n            return distanceToRectangularPrism(position, objectPosition, scale);\n        \}\n\n        float2 size = float2(scale.x, scale.y);\n        if (shapeType == 2)\n        \{\n            return distanceToCylinder(position, objectPosition, size);\n        \}\n        if (shapeType == 3)\n        \{\n            return distanceToTriangularPrism(position, objectPosition, size);\n        \}\n        if (shapeType == 4)\n        \{\n            return distanceToTorus(position, objectPosition, size);\n        \}\n        return distanceToMandelbulb(position, objectPosition, size.x);\n    \}\n\n\n    /**\n     * Compute the minimum distance to an object in the scene\n     */\n    float getMinDistanceToObjectInScene(\n            const float3 rayOrigin,\n            float4 &colour,\n            float4 &surface)\n    \{\n        float distance = maxRayDistance;\n\n        for (int i=0; i < objectTextureHeight; i++)\n        \{\n            for (int j=0; j < objectTextureWidth; j++)\n            \{\n                SampleType(positions) position = positions(j, i);\n                //SampleType(spheres) rotation = spheres(j, i);\n                SampleType(scales) scale = scales(j, i);\n                SampleType(shapeProperties) shapeProperty = shapeProperties(j, i);\n\n                float nextDistance = distanceToObject(\n                    rayOrigin,\n                    (int) shapeProperty.x,\n                    float3(position.x, position.y, position.z),\n                    float3(scale.x, scale.y, scale.z)\n                );\n\n                if (nextDistance < distance)\n                \{\n                    distance = nextDistance;\n\n                    SampleType(colours) surfaceColour = colours(j, i);\n                    SampleType(surfaceProperties) surfaceProperty = surfaceProperties(j, i);\n\n                    colour = float4(surfaceColour);\n                    surface = float4(surfaceProperty);\n                \}\n            \}\n        \}\n\n        return distance;\n    \}\n\n\n    /**\n     * Estimate the surface normal at the closest point on the closest\n     * object to a point\n     *\n     * @arg point: The point near which to get the surface normal\n     *\n     * @returns: The normalized surface normal\n     */\n    float3 estimateSurfaceNormal(const float3 &point) \{\n        float4 colour;\n        float4 surface;\n        return normalize(\n            float3(\n                getMinDistanceToObjectInScene(\n                    float3(\n                        point.x + hitTolerance,\n                        point.y,\n                        point.z\n                    ),\n                    colour,\n                    surface\n                ) - getMinDistanceToObjectInScene(\n                    float3(\n                        point.x - hitTolerance,\n                        point.y,\n                        point.z\n                    ),\n                    colour,\n                    surface\n                ),\n                getMinDistanceToObjectInScene(\n                    float3(\n                        point.x,\n                        point.y + hitTolerance,\n                        point.z\n                    ),\n                    colour,\n                    surface\n                ) - getMinDistanceToObjectInScene(\n                    float3(\n                        point.x,\n                        point.y - hitTolerance,\n                        point.z\n                    ),\n                    colour,\n                    surface\n                ),\n                getMinDistanceToObjectInScene(\n                    float3(\n                        point.x,\n                        point.y,\n                        point.z+hitTolerance\n                    ),\n                    colour,\n                    surface\n                ) - getMinDistanceToObjectInScene(\n                    float3(\n                        point.x,\n                        point.y,\n                        point.z - hitTolerance\n                    ),\n                    colour,\n                    surface\n                )\n        ));\n    \}\n\n\n    float computeShadow(float3 rayOrigin, float3 rayDirection, float distanceToShadePoint)\n    \{\n        float distanceTravelled = 0;\n        float4 colour;\n        float4 surface;\n        while (distanceTravelled < distanceToShadePoint)\n        \{\n            float stepDistance = getMinDistanceToObjectInScene(rayOrigin, colour, surface);\n\n            if (stepDistance < hitTolerance)\n            \{\n                return intensityInShadow;\n            \}\n\n            rayOrigin += rayDirection * stepDistance;\n            distanceTravelled += stepDistance;\n        \}\n\n        return 1;\n    \}\n\n\n    static float3 offsetPoint(\n            const float3 &point,\n            const float3 &direction,\n            const float offset)\n    \{\n        return offset * direction + point;\n    \}\n\n\n    void computeDirectionalLightShadow(\n        const float3 &pointOnSurface,\n        const float3 &surfaceNormal,\n        const float3 &light,\n        float3 &lightDirection,\n        float3 &surfaceOffset,\n        float3 &shadowOffsetLightDirection,\n        float &distanceToLight)\n    \{\n        lightDirection = -light;\n        surfaceOffset = offsetPoint(\n            pointOnSurface,\n            shadowBias * (lightDirection + surfaceNormal),\n            hitTolerance\n        );\n        shadowOffsetLightDirection = lightDirection;\n\n        distanceToLight = maxRayDistance;\n    \}\n\n\n    void computePointLightShadow(\n        const float3 &pointOnSurface,\n        const float3 &surfaceNormal,\n        const float3 &light,\n        float3 &lightDirection,\n        float3 &surfaceOffset,\n        float3 &shadowOffsetLightDirection,\n        float &distanceToLight)\n    \{\n        lightDirection = light - pointOnSurface;\n        surfaceOffset = offsetPoint(\n            pointOnSurface,\n            shadowBias * (lightDirection + surfaceNormal),\n            hitTolerance\n        );\n        shadowOffsetLightDirection = light - surfaceOffset;\n\n        distanceToLight = length(shadowOffsetLightDirection);\n    \}\n\n\n    float2 lightIntensityOnSurface(\n            const float3 &pointOnSurface,\n            const float3 &surfaceNormal,\n            const float3 &light,\n            const int lightType,\n            const float intensity)\n    \{\n        float3 surfaceOffset;\n\n        float distanceToLight;\n        float3 lightDirection;\n        float3 shadowOffsetLightDirection;\n        if (lightType == 0)\n        \{\n            // directional\n            computeDirectionalLightShadow(\n                pointOnSurface,\n                surfaceNormal,\n                light,\n                lightDirection,\n                surfaceOffset,\n                shadowOffsetLightDirection,\n                distanceToLight\n            );\n        \}\n        else\n        \{\n            // point\n            computePointLightShadow(\n                pointOnSurface,\n                surfaceNormal,\n                light,\n                lightDirection,\n                surfaceOffset,\n                shadowOffsetLightDirection,\n                distanceToLight\n            );\n        \}\n\n        return float2(\n            saturate(dot(surfaceNormal, normalize(lightDirection)) * intensity),\n            computeShadow(\n                surfaceOffset,\n                normalize(shadowOffsetLightDirection),\n                distanceToLight\n            )\n        );\n    \}\n\n\n    /**\n     * Get the intensity of the light on the surface of an object\n     *\n     *\n     */\n    float computeLightIntensityOnSurface(const float3 &pointOnSurface, const float3 &surfaceNormal)\n    \{\n        float2 lightIntensity = float2(0, 0);\n\n        for (int i=0; i < lightTextureHeight; i++)\n        \{\n            for (int j=0; j < lightTextureWidth; j++)\n            \{\n                SampleType(lights) light = lights(j, i);\n                SampleType(lightProperties) lightProperty = lightProperties(j, i);\n\n                lightIntensity += lightIntensityOnSurface(\n                    pointOnSurface,\n                    surfaceNormal,\n                    float3(light.x, light.y, light.z),\n                    (int) lightProperty.w,\n                    light.w\n                );\n            \}\n        \}\n\n        return saturate(lightIntensity.x * lightIntensity.y);\n    \}\n\n\n    float3 reflectRayOffSurface(\n        const float3 &incidentRayDirection,\n        const float3 &surfaceNormalDirection)\n    \{\n        return (\n            incidentRayDirection\n            - 2 * dot(incidentRayDirection, surfaceNormalDirection) * surfaceNormalDirection\n        );\n    \}\n\n\n    float4 blend(const float4 &colour0, const float4 &colour1, const float weight)\n    \{\n        return weight * colour0 + (1 - weight) * colour1;\n    \}\n\n    float getHazeAmount(const float distance)\n    \{\n        return saturate(hazeAmount * (distance - hazeStart) / hazeDistance);\n    \}\n\n\n    /**\n     * March a ray through the scene\n     *\n     * @returns: The ray colour\n     */\n    float4 marchRay(\n            const float3 &rayOrigin,\n            const float3 &rayDirection,\n            const int numBounces,\n            const float rayDistance)\n    \{\n        float3 origin = rayOrigin;\n        float3 direction = rayDirection;\n        float4 colour;\n        float4 surface;\n\n        int bounces = 0;\n        float distanceTravelled = 0;\n\n        float lightIntensity = 1;\n\n        float4 rayColour = float4(0, 0, 0, 0);\n\n        float rayStrength = 1;\n\n        int iterations = 1;\n        while (distanceTravelled < rayDistance && rayStrength > 0)\n        \{\n            float stepDistance = getMinDistanceToObjectInScene(origin, colour, surface);\n            distanceTravelled += stepDistance;\n            origin += direction * stepDistance;\n\n            if (stepDistance < hitTolerance)\n            \{\n                bounces++;\n\n                float3 surfaceNormal = estimateSurfaceNormal(\n                    origin - direction * hitTolerance\n                );\n\n                lightIntensity = computeLightIntensityOnSurface(\n                    origin,\n                    surfaceNormal\n                );\n\n                rayColour = blend(\n                    iterGlowColour,\n                    blend(\n                        hazeColour,\n                        blend(\n                            colour,\n                            rayColour,\n                            rayStrength * (1 - surface.x) * lightIntensity\n                        ),\n                        getHazeAmount(distanceTravelled)\n                    ),\n                    iterGlowAmount * iterations\n                );\n\n                if (bounces >= numBounces)\n                \{\n                    return rayColour;\n                \}\n\n                rayStrength *= surface.x * lightIntensity;\n\n                direction = reflectRayOffSurface(\n                    direction,\n                    surfaceNormal\n                );\n                origin = offsetPoint(\n                    origin,\n                    direction + surfaceNormal,\n                    hitTolerance\n                );\n            \}\n            iterations++;\n        \}\n\n        return blend(\n            blend(\n                iterGlowColour,\n                blend(\n                    hazeColour,\n                    readSkyValue(direction),\n                    getHazeAmount(distanceTravelled)\n                ),\n                iterGlowAmount * iterations\n            ),\n            rayColour,\n            rayStrength * lightIntensity\n        );\n    \}\n\n\n    /**\n     * March rays through the scene\n     */\n    void marchRays(\n            const float3 &rayOrigin,\n            const float3 &rayDirection,\n            const int numRays,\n            const int numBounces,\n            const float rayDistance,\n            float4 &resultColour)\n    \{\n        float3 direction = rayDirection;\n\n        float3 rayNormal = normalize(float3(direction.y, -direction.x, 0));\n        float radialOffset = rayOffset;\n        float angularOffset = 0;\n\n        float4 colour;\n\n        for (int rayNum=0; rayNum < numRays; rayNum++)\n        \{\n            resultColour += marchRay(\n                rayOrigin,\n                direction,\n                numBounces,\n                rayDistance\n            );\n\n            // Update the ray direction to send a scattered cluster of rays\n            // TODO these shouldnt diverge more and more the more rays you add\n            rayNormal = (\n                cos(angularOffset)\n                * rayNormal\n                + sin(angularOffset)\n                * cross(direction, rayNormal)\n            );\n\n            direction = radialOffset * rayNormal + rayDirection;\n\n            angularOffset = 90 * (1 - 0.5 * ((rayNum % 4) == 0));\n            radialOffset += rayOffset * ((rayNum % 8) == 0);\n        \}\n\n        // Normalize the output after multiple rays\n        resultColour /= numRays;\n    \}\n\n\n    /**\n     * Compute a raymarched pixel value\n     */\n    void process(int2 pos)\n    \{\n        float4 resultPixel(0, 0, 0, 0);\n\n        float2 pixelLocation = float2(pos.x, pos.y);\n\n        float2 pixelOffset;\n        for (\n            pixelOffset.x = 0.0f;\n            pixelOffset.x < 1.0f;\n            pixelOffset.x += subdividedPixelSize\n        ) \{\n            for (\n                pixelOffset.y = 0.0f;\n                pixelOffset.y < 1.0f;\n                pixelOffset.y += subdividedPixelSize\n            ) \{\n                // Generate a ray from the camera\n                float3 rayOrigin;\n                float3 rayDirection;\n                createCameraRay(pixelLocation + pixelOffset, rayOrigin, rayDirection);\n\n                marchRays(\n                    rayOrigin,\n                    rayDirection,\n                    raysPerPixel,\n                    bouncesPerRay,\n                    maxRayDistance,\n                    resultPixel\n                );\n            \}\n        \}\n\n        dst() = resultPixel / numSubPixels;\n    \}\n\};\n"
  rebuild ""
  "RayMarchKernel_Focal Length" {{parent.DummyCam.focal}}
  "RayMarchKernel_Horizontal Aperture" {{parent.DummyCam.haperture}}
  "RayMarchKernel_Near Plane" {{parent.DummyCam.near}}
  "RayMarchKernel_Far Plane" {{parent.DummyCam.far}}
  "RayMarchKernel_Camera World Matrix" {
      {{parent.DummyCam.world_matrix.0} {parent.DummyCam.world_matrix.1} {parent.DummyCam.world_matrix.2} {parent.DummyCam.world_matrix.3}}
      {{parent.DummyCam.world_matrix.4} {parent.DummyCam.world_matrix.5} {parent.DummyCam.world_matrix.6} {parent.DummyCam.world_matrix.7}}
      {{parent.DummyCam.world_matrix.8} {parent.DummyCam.world_matrix.9} {parent.DummyCam.world_matrix.10} {parent.DummyCam.world_matrix.11}}
      {{parent.DummyCam.world_matrix.12} {parent.DummyCam.world_matrix.13} {parent.DummyCam.world_matrix.14} {parent.DummyCam.world_matrix.15}}
    }
  "RayMarchKernel_Screen Width" {{input0.width}}
  "RayMarchKernel_Screen Height" {{input0.height}}
  "RayMarchKernel_SkyBox Offset Angle" 90
  "RayMarchKernel_SkyBox Width" {{input1.width}}
  "RayMarchKernel_SkyBox Height" {{input1.height}}
  "RayMarchKernel_Pixel Subdivisions" 1
  "RayMarchKernel_Max Bounces" 2
  "RayMarchKernel_Max Ray Distance" 2000
  "RayMarchKernel_Intensity in Shadows" 0.05
  "RayMarchKernel_Object Texture Height" {{input2.height}}
  "RayMarchKernel_Object Texture Width" {{input2.width}}
  "RayMarchKernel_Directional Light Texture Height" {{input8.height}}
  "RayMarchKernel_Directional Light Texture Width" {{input8.width}}
  "RayMarchKernel_Haze Start" 0.5
  "RayMarchKernel_Haze Distance" 3
  "RayMarchKernel_Haze Colour" {0.1 1 1 1}
  "RayMarchKernel_Iter Glow Colour" {0.1 1 1 1}
  format "2048 1024 0 0 2048 1024 1 2K_LatLong"
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos 1792
  ypos 294
 }
 Output {
  name Output1
  xpos 1792
  ypos 625
 }
 Input {
  inputs 0
  name cam
  xpos -293
  ypos 137
  number 1
 }
 Camera {
  projection_mode {{"\[expression \[value the_cam]projection_mode(\[value the_frame])]"}}
  focal {{"\[expression \[value the_cam]focal(\[value the_frame])]"}}
  haperture {{"\[expression \[value the_cam]haperture(\[value the_frame])]"}}
  vaperture {{"\[expression \[value the_cam]vaperture(\[value the_frame])]"}}
  near {{"\[expression \[value the_cam]near(\[value the_frame])]"}}
  far {{"\[expression \[value the_cam]far(\[value the_frame])]"}}
  win_translate {{"\[expression \[value the_cam]win_translate.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_translate.v(\[value the_frame])]"}}
  win_scale {{"\[expression \[value the_cam]win_scale.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_scale.v(\[value the_frame])]"}}
  winroll {{"\[expression \[value the_cam]winroll(\[value the_frame])]"}}
  focal_point {{"\[expression \[value the_cam]focal_point(\[value the_frame])]"}}
  fstop {{"\[expression \[value the_cam]fstop(\[value the_frame])]"}}
  name DummyCam
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if no Camera connected. Can also be used inside of groups and gizmos, as many levels deep as you want :D All using live and super fast TCL.\n\nUpdated v1.1: Now grabs the correct frame too (thanks Erwan Leroy for the idea).\n\nUpdated v1.3: Now accepts Nuke13's Camera3\n\nadrianpueyo.com, 2019-2021"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  xpos -283
  ypos 245
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\n#DummyCam v1.3 - Updated 5 May 2021.\nset starting_point \"this.input0\"\nset default \"this.d_\"\n\n# If cam has no inputs, return the default.\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera3\" && \[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera3\"||\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{ \[class \$x]==\"Input\" \} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{ \[exists \$inp] \} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {43 the_frame +INVISIBLE}
  the_frame "\[\nset the_camera \[string trimright \[value the_cam] .]\nif \{\[exists \$the_camera]\} \{\n    return \[value \$the_camera.frame]\n\} \{ \n    return \[frame]\n\}\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l "focal length" R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {30 d_win_translate l "window translate"}
  addUserKnob {30 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 version l " " t "Updated 5 May 2021" T "<span style=\"color:#666\"><br/><b>DummyCam v1.3</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019-2021</span>"}
 }
end_group
Viewer {
 frame_range 17-100
 frame_range_lock true
 colour_sample_bbox {0.21875 -0.0625 0.220703125 -0.060546875}
 name Viewer1
 xpos 16100
 ypos 1549
}
