// Copyright 2022 by Owen Bulka.
// All rights reserved.
// This file is released under the "MIT License Agreement".
// Please see the LICENSE.md file that should have been included as part
// of this package.

//
// BlinkScript Ray Marcher
//

#include "math.h"
#include "random.h"
#include "noise.h"
#include "conversion.h"
#include "aovs.h"
#include "lights.h"
#include "material.h"
#include "camera.h"
#include "objectInteraction.h"
#include "sdfModifications.h"
#include "sdfs.h"


// Increase this if you want more than MAX_CHILD_DEPTH direct children
#define MAX_CHILD_DEPTH 32
#define MAX_MIS_EMISSIVE_SHAPES 32

// Number of parameters needed in the parent stacks
#define PARENT_STACK_PARAMS 8
#define FULL_PARENT_STACK_PARAMS 29

// Indices to store parent stack data
#define NUM_CHILDREN 0
#define TRANSFORM_X 1
#define TRANSFORM_Y 2
#define TRANSFORM_Z 3
#define SCALE 4
#define MODIFICATIONS 5
#define BLEND_STRENGTH 6
#define DISTANCE 7
#define DIFFUSE_COLOUR_R 8
#define DIFFUSE_COLOUR_G 9
#define DIFFUSE_COLOUR_B 10
#define SPECULAR_ROUGHNESS 11
#define SPECULAR_COLOUR_R 12
#define SPECULAR_COLOUR_G 13
#define SPECULAR_COLOUR_B 14
#define SPECULAR 15
#define EXTINCTION_R 16
#define EXTINCTION_G 17
#define EXTINCTION_B 18
#define TRANSMISSION 19
#define EMISSION_R 20
#define EMISSION_G 21
#define EMISSION_B 22
#define SCATTERING_R 23
#define SCATTERING_G 24
#define SCATTERING_B 25
#define TRANSMISSION_ROUGHNESS 26
#define PARENT_REFRACTIVE_INDEX 27
#define PARENT_OBJECT_ID 28

// Maximum recursion depth for ray marching
#define MAX_RAYS_PER_SUBPIXEL 100

#define IS_BOUND 4096

#define IS_NOT_UNION 3968


kernel RayMarchKernel : ImageComputationKernel<ePixelWise>
{
    // the input which specifies the format, process is called once per pixel
    // in this image, which also provides random seeds
    Image<eRead, eAccessPoint, eEdgeNone> noise;
    Image<eRead, eAccessPoint, eEdgeNone> src;
    Image<eRead, eAccessPoint, eEdgeNone> variance;

    // the hdri in latlong format
    Image<eRead, eAccessRandom, eEdgeNone> hdri;


    // the shape positons.xyz, scale.w
    Image<eRead, eAccessRandom, eEdgeNone> positions;

    // the shape rotations.xyz, wall thickness.w
    Image<eRead, eAccessRandom, eEdgeNone> rotations;

    // the shape dimensions.xyzw (some shapes may not use all channels)
    Image<eRead, eAccessRandom, eEdgeNone> dimensions;

    // the shape diffusivities.xyz, specular roughness.w
    Image<eRead, eAccessRandom, eEdgeNone> diffusivities;

    Image<eRead, eAccessRandom, eEdgeNone> specularities;

    Image<eRead, eAccessRandom, eEdgeNone> transmittances;

    Image<eRead, eAccessRandom, eEdgeNone> emittances;

    Image<eRead, eAccessRandom, eEdgeNone> scatteringCoefficients;


    // shape type.x, operation.y, numChildren.z, blend strength.w
    Image<eRead, eAccessRandom, eEdgeNone> shapeProperties;

    // repetition params.xyzw
    Image<eRead, eAccessRandom, eEdgeNone> shapeModParameters0;

    // elongation.xyz edgeRadius.w
    Image<eRead, eAccessRandom, eEdgeNone> shapeModParameters1;

    // reflection.x, transmission.y, emission.z, roughness.w
    Image<eRead, eAccessRandom, eEdgeNone> surfaceProperties;

    // noise options.x translation.yzw
    Image<eRead, eAccessRandom, eEdgeNone> noiseParams0;

    // octaves.x, lacunarity.y, gain.z, gamma.w
    Image<eRead, eAccessRandom, eEdgeNone> noiseParams1;

    // size.x
    Image<eRead, eAccessRandom, eEdgeNone> noiseParams2;

    // the input lights direction/position.xyz intensity.w
    Image<eRead, eAccessRandom, eEdgeNone> lights;

    // colour.xyz, type.w
    // w in [0, 1) = directional, [1, inf) = point
    Image<eRead, eAccessRandom, eEdgeNone> lightProperties;

    // shadow hardness.x
    Image<eRead, eAccessRandom, eEdgeNone> lightProperties1;

    // the precomputed irradiance of the hdri
    Image<eRead, eAccessRandom, eEdgeClamped> irradiance;


    // the output image
    Image<eWrite> dst;


    param:
        // These parameters are made available to the user.

        // Camera params
        float _focalLength;
        float _horizontalAperture;
        float _nearPlane;
        float _farPlane;
        float4x4 _cameraWorldMatrix;
        float _focalDistance;
        float _fStop;
        bool _depthOfFieldEnabled;

        // Image params
        float _formatWidth;
        float _formatHeight;

        float _hdriOffsetAngle;
        bool _usePrecomputedIrradiance;

        // Ray params
        int _minPathsPerPixel;
        int _maxPathsPerPixel;
        bool _roulette;
        int _maxBounces;
        int _maxLightSamplingBounces;
        bool _sampleHDRI;
        bool _sampleAllLights;
        bool _doSecondaryLightSampling;
        float _lightSamplingBias;
        float _maxRayDistance;
        int _maxRaySteps;
        bool _levelOfDetail;
        float _hitTolerance;
        float _shadowBias;
        float _maxBrightness;

        // Scene params
        float _refractiveIndex;
        float4 _scatteringCoefficient;
        float4 _extinctionCoefficient;
        int _equiangularSamples;
        bool _sampleHDRIEquiangular;

        // Shape Textures
        int _objectTextureWidth;
        int _lightTextureWidth;

        int _outputType;

        bool _latLong;


    local:
        // These local variables are not exposed to the user.

        float4x4 __inverseCameraProjectionMatrix;
        float __aperture;

        int __bouncesPerRay;
        bool __lightSamplingEnabled;
        float __lightSamplingAngle;
        bool __equiangularSamplingEnabled;

        float2 __hdriPixelSize;
        float2 __irradiancePixelSize;
        float __hdriOffsetRadians;

        float3 __offset0;
        float3 __offset1;
        float3 __offset2;
        float3 __offset3;


    /**
     * Give the parameters labels and default values.
     */
    void define()
    {
        // Camera params
        defineParam(_focalLength, "Focal Length", 50.0f);
        defineParam(_horizontalAperture, "Horizontal Aperture", 24.576f);
        defineParam(_nearPlane, "Near Plane", 0.1f);
        defineParam(_farPlane, "Far Plane", 10000.0f);
        defineParam(
            _cameraWorldMatrix,
            "Camera World Matrix",
            float4x4(
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            )
        );
        defineParam(_focalDistance, "Focal Distance", 4.0f);
        defineParam(_fStop, "fstop", 16.0f);
        defineParam(_depthOfFieldEnabled, "Enable Depth Of Field", true);

        // Image params
        defineParam(_formatHeight, "Screen Height", 2160.0f);
        defineParam(_formatWidth, "Screen Width", 3840.0f);
        defineParam(_hdriOffsetAngle, "HDRI Offset Angle", 0.0f);
        defineParam(_usePrecomputedIrradiance, "Use Precomputed Irradiance", true);

        // Ray params
        defineParam(_minPathsPerPixel, "Min Paths Per Pixel", 1);
        defineParam(_maxPathsPerPixel, "Max Paths Per Pixel", 1);
        defineParam(_roulette, "Roulette", true);
        defineParam(_maxRayDistance, "Max Ray Distance", 1000.0f);
        defineParam(_maxRaySteps, "Max Ray Steps", 128);
        defineParam(_maxBounces, "Max Bounces", 1);
        defineParam(_maxLightSamplingBounces, "Max Light Sampling Bounces", 0);
        defineParam(_sampleHDRI, "Sample HDRI", true);
        defineParam(_sampleAllLights, "Sample All Lights", false);
        defineParam(_doSecondaryLightSampling, "Secondary Light Sampling", false);
        defineParam(_lightSamplingBias, "Light Sampling Bias", 0.0f);
        defineParam(_levelOfDetail, "Level of Detail", true);
        defineParam(_hitTolerance, "Hit Tolerance", 0.001f);
        defineParam(_shadowBias, "Shadow Bias", 1.0f);
        defineParam(_maxBrightness, "Maximum Brightness", 999999.9f);

        // Scene params
        defineParam(_refractiveIndex, "Index of Refraction", 1.0f);
        defineParam(_scatteringCoefficient, "Scattering Coefficient", float4(0));
        defineParam(_extinctionCoefficient, "Extinction Coefficient", float4(1));
        defineParam(_equiangularSamples, "Equi-Angular Samples", 5);
        defineParam(_sampleHDRIEquiangular, "Sample HDRI Equi-Angular", true);

        // Shape Counts
        defineParam(_objectTextureWidth, "Object Texture Width", 0);
        defineParam(_lightTextureWidth, "Light Texture Width", 0);

        defineParam(_outputType, "Output Type", 0);

        defineParam(_latLong, "Output LatLong", false);
    }


    /**
     * Initialize the local variables.
     */
    void init()
    {
        __bouncesPerRay = max(0, _maxBounces);

        __lightSamplingEnabled = _maxLightSamplingBounces > 0;

        __lightSamplingAngle = PI * (1.0f - saturate(_lightSamplingBias));

        __equiangularSamplingEnabled = _equiangularSamples > 0;

        float aspect = aspectRatio(_formatHeight, _formatWidth);
        float4x4 cameraProjectionMatrix = projectionMatrix(
            _focalLength,
            _horizontalAperture,
            aspect,
            _nearPlane,
            _farPlane
        );
        __inverseCameraProjectionMatrix = cameraProjectionMatrix.invert();

        __aperture = fStopToAperture(_fStop, _focalLength);

        __hdriPixelSize = float2(
            hdri.bounds.width() / (2 * PI),
            hdri.bounds.height() / PI
        );
        __irradiancePixelSize = float2(
            irradiance.bounds.width() / (2 * PI),
            irradiance.bounds.height() / PI
        );
        __hdriOffsetRadians = degreesToRadians(_hdriOffsetAngle);

        __offset0 = 0.5773f * float3(1, -1, -1);
        __offset1 = 0.5773f * float3(-1, -1, 1);
        __offset2 = 0.5773f * float3(-1, 1, -1);
        __offset3 = 0.5773f * float3(1, 1, 1);
    }


    /**
     * Get the noise value at a position.
     *
     * @arg index: The index of the noise.
     * @arg position: The position at which we want the noise.
     * @arg noiseOptions: The noise modifier options.
     *
     * @returns: The noise value.
     */
    float getNoiseValue(const int index, const float3 &position, int &noiseOptions)
    {
        // Make sure there is a noise node plugged into the object.
        noiseOptions = (int) noiseParams0(index, 0, 0);
        if ((noiseOptions & NOISE_ENABLED) == 0)
        {
            return -1.0f;
        }

        // Read the noise parameters
        const float3 translation = float3(
            noiseParams0(index, 0, 1),
            noiseParams0(index, 0, 2),
            noiseParams0(index, 0, 3)
        );

        const int octaves = noiseParams1(index, 0, 0);
        const float lacunarity = noiseParams1(index, 0, 1);
        const float gain = noiseParams1(index, 0, 2);
        const float gamma = noiseParams1(index, 0, 3);
        const float size = noiseParams2(index, 0, 0);

        // Translate the noise, and convert the position to the local
        // coordinate system
        float3 noisePosition;
        if (index == _objectTextureWidth)
        {
            noisePosition = position + translation;
        }
        else
        {
            noisePosition = worldToLocal(index, position + translation);
        }

        // Get the noise value based on which type of noise we are using
        float noiseValue;
        if (noiseOptions & FBM_NOISE)
        {
            noiseValue = fractalBrownianMotionNoise(
                octaves,
                lacunarity,
                size,
                gain,
                gamma,
                noisePosition
            );
        }
        else
        {
            noiseValue = turbulenceNoise(
                octaves,
                lacunarity,
                size,
                gain,
                gamma,
                noisePosition
            );
        }

        // Modify the noise using the grade parameters
        const float whitePoint = noiseParams2(index, 0, 1);
        const float blackPoint = noiseParams2(index, 0, 2);
        const float lift = noiseParams2(index, 0, 3);

        if (whitePoint != blackPoint)
        {
            noiseValue = saturate((noiseValue - blackPoint) / (whitePoint - blackPoint));
        }

        noiseValue = saturate(noiseValue * (1.0f - lift) + lift);

        if (noiseOptions & INVERT_NOISE)
        {
            noiseValue = 1.0f - noiseValue;
        }

        return noiseValue;
    }


    /**
     * Modify the material properties of an object based on noise.
     *
     * @arg objectIndex: The index of the object.
     * @arg intersectionPosition: The position at which the we are
     *     modifying the material.
     * @arg diffusivity: The diffuse values of the surface.
     * @arg specularity: The specular values of the surface.
     * @arg transmittance: The extinction coefficient and transmissive
     *     probability of the surface.
     * @arg emittance: The emissive values of the surface.
     * @arg specularRoughness: The specular roughness of the surface.
     * @arg transmissionRoughness: The transmissive roughness of the
     *     surface.
     * @arg refractiveIndex: The refractive index of the material.
     */
    void noiseMaterialInteraction(
            const int objectIndex,
            const float3 &intersectionPosition,
            float4 &diffusivity,
            float4 &specularity,
            float4 &transmittance,
            float4 &emittance,
            float &specularRoughness,
            float &transmissionRoughness,
            float &refractiveIndex)
    {
        int noiseOptions;
        const float noiseValue = getNoiseValue(
            objectIndex,
            intersectionPosition,
            noiseOptions
        );
        if (noiseValue >= 0.0f)
        {
            useNoiseOnMaterial(
                noiseOptions,
                noiseValue,
                diffusivity,
                specularity,
                transmittance,
                emittance,
                specularRoughness,
                transmissionRoughness,
                refractiveIndex
            );
        }
    }


    /**
     * Get the value of hdri the ray would hit at infinite distance
     *
     * @arg rayDirection: The direction of the ray.
     *
     * @returns: The colour of the pixel in the direction of the ray.
     */
    float4 readHDRIValue(float3 rayDirection)
    {
        const float2 angles = cartesionUnitVectorToSpherical(rayDirection, __hdriOffsetRadians);

        // Should be able to say image access is eEdgeClamped and not do this
        // but I see nan pixels sooo... :(
        const float2 indices = clamp(
            float2(
                __hdriPixelSize.x * angles.x,
                hdri.bounds.height() - (__hdriPixelSize.y * angles.y)
            ),
            float2(0),
            float2(hdri.bounds.width(), hdri.bounds.height()) - 1.0f
        );

        return bilinear(hdri, indices.x, indices.y);
    }


    /**
     * Get the value of irradiance the hdri would provide in a direction
     *
     * @arg rayDirection: The direction of the ray.
     *
     * @returns: The colour of the pixel in the direction of the ray.
     */
    inline float4 readIrradianceValue(float3 rayDirection)
    {
        const float2 angles = cartesionUnitVectorToSpherical(rayDirection, __hdriOffsetRadians);

        // Should be able to say image access is eEdgeClamped and not do this
        // but I see nan pixels sooo... :(
        const float2 indices = clamp(
            float2(
                __irradiancePixelSize.x * angles.x,
                irradiance.bounds.height() - (__irradiancePixelSize.y * angles.y)
            ),
            float2(0),
            float2(irradiance.bounds.width(), irradiance.bounds.height()) - 1.0f
        );

        return bilinear(irradiance, indices.x, indices.y);
    }


    /**
     * Get the scale of an object.
     *
     * @arg objectIndex: The index of the object.
     *
     * @returns: The scale of the object.
     */
    float getScale(const int objectIndex)
    {
        float scale = 1.0f;

        for (int j=0; j <= objectIndex; j++)
        {
            const float numChildren = shapeProperties(j, 0, 2);

            if (j + numChildren < objectIndex)
            {
                j += numChildren;
                continue;
            }

            scale *= positions(j, 0, 3);
        }

        return scale;
    }


    /**
     * Get the radius of an object.
     *
     * @arg objectIndex: The index of the object.
     *
     * @returns: The radius of the object.
     */
    float getRadius(const int objectIndex)
    {
        return getScale(objectIndex) * dimensions(objectIndex, 0, 0);
    }


    /**
     * Get the local position, from a world position.
     *
     * @arg objectIndex: The index of the object whose local coordinate
     *     system we are using.
     * @arg worldPosition: The world position.
     *
     * @returns: The local position of the worldPosition.
     */
    float3 worldToLocal(const int objectIndex, const float3 &worldPosition)
    {
        float3 localPosition = worldPosition;
        for (int j=0; j <= objectIndex; j++)
        {
            SampleType(shapeProperties) shapeProperty = shapeProperties(j, 0);
            const float numChildren = shapeProperty.z;

            if (j + numChildren < objectIndex)
            {
                j += numChildren;
                continue;
            }

            // Read in the shape properties
            const SampleType(positions) position = positions(j, 0);
            const SampleType(rotations) rotation = rotations(j, 0);
            const SampleType(dimensions) dimension = dimensions(j, 0);
            const SampleType(shapeModParameters0) modParameters0 = shapeModParameters0(j, 0);
            const SampleType(shapeModParameters1) modParameters1 = shapeModParameters1(j, 0);

            // const float scale = position.w;
            const int modifications = (int) shapeProperty.y;

            // Use parent transform to position child
            localPosition = transformRay(
                localPosition,
                float3(position.x, position.y, position.z),
                float3(rotation.x, rotation.y, rotation.z),
                modifications,
                modParameters0,
                modParameters1
            );
        }

        return localPosition;
    }


    /**
     * Get the world position, from a local position.
     *
     * @arg objectIndex: The index of the object whose local coordinate
     *     system we are using.
     * @arg localPosition: The local position.
     *
     * @returns: The world position of the localPosition.
     */
    float3 localToWorld(const int objectIndex, const float3 &localPosition)
    {
        float3 worldPosition = localPosition;
        for (int j=objectIndex; j >= 0; j--)
        {
            SampleType(shapeProperties) shapeProperty = shapeProperties(j, 0);
            const float numChildren = shapeProperty.z;

            if (j + numChildren < objectIndex)
            {
                continue;
            }

            // Read in the shape properties
            const SampleType(positions) position = positions(j, 0);
            const SampleType(rotations) rotation = rotations(j, 0);
            const SampleType(dimensions) dimension = dimensions(j, 0);
            const SampleType(shapeModParameters0) modParameters0 = shapeModParameters0(j, 0);
            const SampleType(shapeModParameters1) modParameters1 = shapeModParameters1(j, 0);

            // const float scale = position.w;
            const int modifications = (int) shapeProperty.y;

            // Use parent transform to position child
            worldPosition = inverseTransformRay(
                worldPosition,
                float3(position.x, position.y, position.z),
                float3(rotation.x, rotation.y, rotation.z),
                modifications,
                modParameters0,
                modParameters1
            );
        }

        return worldPosition;
    }


    /**
     * Get the world position of an object.
     *
     * @arg objectIndex: The index of the object.
     *
     * @returns: The world position of the object.
     */
    float3 getObjectPosition(const int objectIndex)
    {
        return localToWorld(objectIndex, float3(0));
    }


    /**
     * Check whether or not an object is set to interact with its
     * children in a way that is not union.
     *
     * @arg objectIndex: The index of the object to check.
     *
     * @returns: True if object's interaction type is not set to union,
     *     and false otherwise.
     */
    inline bool childInteractionIsNotUnion(const int objectIndex)
    {
        return (int(shapeProperties(objectIndex, 0, 1)) & IS_NOT_UNION) > 0;
    }


    /**
     * Check whether or not an object is the parent of another.
     *
     * @arg parentIndex: The index of the potential parent.
     * @arg childIndex: The index of the potential child.
     *
     * @returns: True if the object is the parent, and false otherwise.
     */
    inline bool isParentOf(const int parentIndex, const int childIndex)
    {
        return (
            parentIndex < childIndex
            && parentIndex + shapeProperties(parentIndex, 0, 2) >= childIndex
        );
    }


    /**
     * Check whether or not we will be exiting the current material if
     * we transmit through the surface of an object.
     *
     * @arg currentMaterialIndex: The index of the object whose material
     *     we are currently travelling through.
     * @arg objectIndex: The index of the object that we have hit.
     *
     * @returns: True if we will be exiting, and false otherwise.
     */
    bool isExitingObject(const int currentMaterialIndex, const int objectIndex)
    {
        return (
            currentMaterialIndex >= 0
            && (
                currentMaterialIndex == objectIndex
                || (
                    isParentOf(objectIndex, currentMaterialIndex)
                    && childInteractionIsNotUnion(objectIndex)
                ) || (
                    isParentOf(currentMaterialIndex, objectIndex)
                    && childInteractionIsNotUnion(currentMaterialIndex)
                )
            )
        );
    }


    /**
     * Compute the minimum distance to an object in the scene.
     *
     * @arg rayOrigin: The origin position of the ray.
     * @arg pixelFootprint: A value proportional to the amount of world
     *     space that fills a pixel, like the distance from camera.
     *
     * @returns: The minimum distance to an object in the scene.
     */
    float getMinDistanceToObjectInScene(const float3 &rayOrigin, const float pixelFootprint)
    {
        float distance = _maxRayDistance;

        // numChildren, transformedRay, scale, mods, nextDistance, diffuse colour
        // roughness, specular colour, specular, transmissive colour, transmission,
        // emissive colour, emission, refractive index, objectId, blendStrength
        float parentStack[MAX_CHILD_DEPTH][PARENT_STACK_PARAMS];
        int parentStackLength = 0;

        for (int j=0; j < _objectTextureWidth; j++)
        {
            // Read in the shape properties
            SampleType(positions) position = positions(j, 0);
            SampleType(rotations) rotation = rotations(j, 0);
            SampleType(dimensions) dimension = dimensions(j, 0);
            SampleType(shapeProperties) shapeProperty = shapeProperties(j, 0);
            SampleType(shapeModParameters0) modParameters0 = shapeModParameters0(j, 0);
            SampleType(shapeModParameters1) modParameters1 = shapeModParameters1(j, 0);

            float scale = position.w;

            const int modifications = (int) shapeProperty.y;
            float numChildren = shapeProperty.z;
            const float blendStrength = shapeProperty.w;

            int stackLastIndex = parentStackLength - 1;

            // Position relative to the parent if we have any
            float3 parentTransformedRay = rayOrigin;
            if (parentStackLength > 0)
            {
                parentTransformedRay.x = parentStack[stackLastIndex][TRANSFORM_X];
                parentTransformedRay.y = parentStack[stackLastIndex][TRANSFORM_Y];
                parentTransformedRay.z = parentStack[stackLastIndex][TRANSFORM_Z];
                scale *= parentStack[stackLastIndex][SCALE];
            }

            // Use parent transform to position child
            const float3 transformedRay = transformRay(
                parentTransformedRay,
                float3(position.x, position.y, position.z),
                float3(rotation.x, rotation.y, rotation.z),
                modifications,
                modParameters0,
                modParameters1
            );

            // Get distance to this child
            float nextDistance = getModifiedDistance(
                transformedRay,
                (int) shapeProperty.x,
                dimension,
                scale,
                modifications,
                modParameters1.w,
                rotation.w
            );

            // Track which object was hit for the alpha channel
            float objectId = (float) j + 1.0f;

            // If this is a bounding volume, we can skip its children
            // if we aren't close to, or inside it
            if (
                modifications & IS_BOUND
                && numChildren > 0
                && nextDistance > _hitTolerance + pixelFootprint
            ) {
                // Update the min distance if this bounding volume is closest.
                // Otherwise we could step through it, or if every object in
                // the scene is inside it, we would not step forward at all
                if (fabs(nextDistance) < fabs(distance))
                {
                    distance = nextDistance;
                }

                // This was tagged as a boundary object, skip its children
                // since we arent close to hitting it
                j += numChildren;

                for (int parentIndex=stackLastIndex; parentIndex >= 0; parentIndex--)
                {
                    parentStack[parentIndex][NUM_CHILDREN] -= numChildren + 1.0f;
                }

                // If there are no parents, or still children of the parent
                // we do not need to compute anything further for this loop
                if (parentStackLength <= 0 || parentStack[stackLastIndex][NUM_CHILDREN] > 0.0f)
                {
                    continue;
                }

                // pop stack
                // we know that there will be no more children if we did not continue
                numChildren = 0.0f;
                nextDistance = parentStack[stackLastIndex][DISTANCE];
                stackLastIndex--;
                parentStackLength--;
            }

            if (numChildren <= 0.0f)
            {
                // No Children left, compute interactions with parent
                if (parentStackLength > 0)
                {
                    // Process this object, along with all parents that do not
                    // have any more children, removing them from the stack,
                    // but descend all the way down the stack, without removing
                    // the objects that still have children
                    for (int stackIndex=stackLastIndex; stackIndex >= 0; stackIndex--)
                    {
                        const int parentModifications = parentStack[stackIndex][MODIFICATIONS];

                        // Do not need to interact with bounding volumes.
                        // They are in the stack for relative positioning
                        // if they weren't then we would have to manually move
                        // the bounding box to follow the children
                        const float parentBlendStrength = parentStack[stackIndex][BLEND_STRENGTH];
                        const float parentNextDistance = parentStack[stackIndex][DISTANCE];

                        // Compute interaction between parent and this child
                        nextDistance = performChildInteraction(
                            parentModifications,
                            parentNextDistance,
                            nextDistance,
                            parentBlendStrength
                        );

                        // Update the global min distance (and surface/colour)
                        if (fabs(nextDistance) < fabs(distance))
                        {
                            distance = nextDistance;
                        }
                    }

                    do
                    {
                        // Decrement the number of children each parent has
                        for (int parentIndex=stackLastIndex; parentIndex >= 0; parentIndex--)
                        {
                            parentStack[parentIndex][NUM_CHILDREN] -= 1.0f;
                        }

                        // Get the number of children still remaining for the parent
                        // If there are still children, we can break out of this loop
                        // to process the rest of them before the parent itself
                        numChildren = parentStack[stackLastIndex][NUM_CHILDREN];
                    }
                    while (numChildren <= 0.0f && --stackLastIndex >= 0);

                    parentStackLength = stackLastIndex + 1;
                }
                // No parents to interact with, simply check the distance
                else if (fabs(nextDistance) < fabs(distance))
                {
                    distance = nextDistance;
                }
            }
            else
            {
                // Node has Children, push it to the stack for later
                // processing when we have all its children
                // parentStack.push()
                parentStack[parentStackLength][NUM_CHILDREN] = numChildren;
                parentStack[parentStackLength][TRANSFORM_X] = transformedRay.x;
                parentStack[parentStackLength][TRANSFORM_Y] = transformedRay.y;
                parentStack[parentStackLength][TRANSFORM_Z] = transformedRay.z;
                parentStack[parentStackLength][SCALE] = scale;
                parentStack[parentStackLength][MODIFICATIONS] = (float) modifications;
                parentStack[parentStackLength][BLEND_STRENGTH] = blendStrength;
                parentStack[parentStackLength][DISTANCE] = nextDistance;
                parentStackLength++;
            }
        }

        return distance;
    }


    /**
     * Compute the minimum distance to an object in the scene.
     *
     * @arg rayOrigin: The origin position of the ray.
     * @arg pixelFootprint: A value proportional to the amount of world
     *     space that fills a pixel, like the distance from camera.
     * @arg diffusivity: The diffuse values of the nearest surface.
     * @arg specularity: The specular values of the nearest surface.
     * @arg transmittance: The extinction coefficient and transmissive
     *     probability of the nearest surface.
     * @arg emittance: The emissive values of the nearest surface.
     * @arg scatteringCoefficient: The scattering coefficient of the
     *     nearest material.
     * @arg specularRoughness: The specular roughness of the surface.
     * @arg transmissionRoughness: The transmissive roughness of the
     *     nearest surface.
     * @arg refractiveIndex: The refractive index of the material.
     * @arg doRefraction: Whether or not refraction is enabled on the
     *     nearest material.
     * @arg id: The ID of the nearest object.
     *
     * @returns: The minimum distance to an object in the scene.
     */
    float getMinDistanceToObjectInScene(
            const float3 &rayOrigin,
            const float pixelFootprint,
            float4 &diffusivity,
            float4 &specularity,
            float4 &transmittance,
            float4 &emittance,
            float4 &scatteringCoefficient,
            float &specularRoughness,
            float &transmissionRoughness,
            float &refractiveIndex,
            bool &doRefraction,
            int &id)
    {
        float distance = _maxRayDistance;
        id = 0;

        // numChildren, transformedRay, scale, mods, nextDistance, diffuse colour
        // roughness, specular colour, specular, transmissive colour, transmission,
        // emissive colour, emission, refractive index, objectId, blendStrength
        float parentStack[MAX_CHILD_DEPTH][FULL_PARENT_STACK_PARAMS];
        int parentStackLength = 0;

        for (int j=0; j < _objectTextureWidth; j++)
        {
            // Read in the shape properties
            SampleType(positions) position = positions(j, 0);
            SampleType(rotations) rotation = rotations(j, 0);
            SampleType(dimensions) dimension = dimensions(j, 0);
            SampleType(shapeProperties) shapeProperty = shapeProperties(j, 0);
            SampleType(shapeModParameters0) modParameters0 = shapeModParameters0(j, 0);
            SampleType(shapeModParameters1) modParameters1 = shapeModParameters1(j, 0);
            SampleType(diffusivities) diffuseColour = diffusivities(j, 0);
            SampleType(specularities) specularColour = specularities(j, 0);
            SampleType(transmittances) transmissiveColour = transmittances(j, 0);
            SampleType(emittances) emissiveColour = emittances(j, 0);
            SampleType(scatteringCoefficients) scatteringColour = scatteringCoefficients(j, 0);
            SampleType(surfaceProperties) surfaceProperty = surfaceProperties(j, 0);

            const int modifications = ((int) shapeProperty.y) | ((int) surfaceProperty.y);
            float scale = position.w;

            const float blendStrength = shapeProperty.w;
            float numChildren = shapeProperty.z;

            int stackLastIndex = parentStackLength - 1;

            float4 blendedDiffuseColour = diffuseColour;
            float4 blendedSpecularColour = specularColour;
            float4 blendedTransmissiveColour = transmissiveColour;
            float4 blendedEmissiveColour = emissiveColour;
            float4 blendedScatteringCoefficient = scatteringColour;
            float blendedRefractiveIndex = surfaceProperty.x;
            float blendedTransmissionRoughness = surfaceProperty.z;

            // Position relative to the parent if we have any
            float3 parentTransformedRay = rayOrigin;
            if (parentStackLength > 0)
            {
                parentTransformedRay.x = parentStack[stackLastIndex][TRANSFORM_X];
                parentTransformedRay.y = parentStack[stackLastIndex][TRANSFORM_Y];
                parentTransformedRay.z = parentStack[stackLastIndex][TRANSFORM_Z];
                scale *= parentStack[stackLastIndex][SCALE];
            }

            // Use parent transform to position child
            const float3 transformedRay = transformRay(
                parentTransformedRay,
                float3(position.x, position.y, position.z),
                float3(rotation.x, rotation.y, rotation.z),
                modifications,
                modParameters0,
                modParameters1
            );

            // Get distance to this child
            float nextDistance = getModifiedDistance(
                transformedRay,
                (int) shapeProperty.x,
                dimension,
                scale,
                modifications,
                modParameters1.w,
                rotation.w,
                blendedDiffuseColour,
                blendedSpecularColour,
                blendedTransmissiveColour,
                blendedEmissiveColour,
                blendedScatteringCoefficient
            );

            // Track which object was hit for the alpha channel
            float objectId = (float) j + 1.0f;

            // If this is a bounding volume, we can skip its children
            // if we aren't close to, or inside it
            if (
                modifications & IS_BOUND
                && numChildren > 0
                && nextDistance > _hitTolerance + pixelFootprint
            ) {
                // Update the min distance if this bounding volume is closest.
                // Otherwise we could step through it, or if every object in
                // the scene is inside it, we would not step forward at all
                if (fabs(nextDistance) < fabs(distance))
                {
                    distance = nextDistance;

                    diffusivity = blendedDiffuseColour;
                    specularity = blendedSpecularColour;
                    transmittance = blendedTransmissiveColour;
                    emittance = blendedEmissiveColour;
                    scatteringCoefficient = blendedScatteringCoefficient;
                    specularRoughness = blendedDiffuseColour.w;
                    transmissionRoughness = blendedTransmissionRoughness;
                    refractiveIndex = blendedRefractiveIndex;

                    id = objectId;

                    doRefraction = modifications & 262144;
                }

                // This was tagged as a boundary object, skip its children
                // since we arent close to hitting it
                j += numChildren;

                for (int parentIndex=stackLastIndex; parentIndex >= 0; parentIndex--)
                {
                    parentStack[parentIndex][NUM_CHILDREN] -= numChildren + 1.0f;
                }

                // If there are no parents, or still children of the parent
                // we do not need to compute anything further for this loop
                if (parentStackLength <= 0 || parentStack[stackLastIndex][NUM_CHILDREN] > 0.0f)
                {
                    continue;
                }

                // pop stack
                // we know that there will be no more children if we did not continue
                numChildren = 0.0f;
                nextDistance = parentStack[stackLastIndex][DISTANCE];
                blendedDiffuseColour = float4(
                    parentStack[stackLastIndex][DIFFUSE_COLOUR_R],
                    parentStack[stackLastIndex][DIFFUSE_COLOUR_G],
                    parentStack[stackLastIndex][DIFFUSE_COLOUR_B],
                    parentStack[stackLastIndex][SPECULAR_ROUGHNESS]
                );
                blendedSpecularColour = float4(
                    parentStack[stackLastIndex][SPECULAR_COLOUR_R],
                    parentStack[stackLastIndex][SPECULAR_COLOUR_G],
                    parentStack[stackLastIndex][SPECULAR_COLOUR_B],
                    parentStack[stackLastIndex][SPECULAR]
                );
                blendedTransmissiveColour = float4(
                    parentStack[stackLastIndex][EXTINCTION_R],
                    parentStack[stackLastIndex][EXTINCTION_G],
                    parentStack[stackLastIndex][EXTINCTION_B],
                    parentStack[stackLastIndex][TRANSMISSION]
                );
                blendedEmissiveColour = float4(
                    parentStack[stackLastIndex][EMISSION_R],
                    parentStack[stackLastIndex][EMISSION_G],
                    parentStack[stackLastIndex][EMISSION_B],
                    0
                );
                blendedScatteringCoefficient = float4(
                    parentStack[stackLastIndex][SCATTERING_R],
                    parentStack[stackLastIndex][SCATTERING_G],
                    parentStack[stackLastIndex][SCATTERING_B],
                    0
                );
                blendedTransmissionRoughness = parentStack[stackLastIndex][TRANSMISSION_ROUGHNESS];
                blendedRefractiveIndex = parentStack[stackLastIndex][PARENT_REFRACTIVE_INDEX];

                objectId = parentStack[stackLastIndex][PARENT_OBJECT_ID];
                stackLastIndex--;
                parentStackLength--;
            }

            if (numChildren <= 0.0f)
            {
                // No Children left, compute interactions with parent
                if (parentStackLength > 0)
                {
                    // Process this object, along with all parents that do not
                    // have any more children, removing them from the stack,
                    // but descend all the way down the stack, without removing
                    // the objects that still have children
                    for (int stackIndex=stackLastIndex; stackIndex >= 0; stackIndex--)
                    {
                        const int parentModifications = parentStack[stackIndex][MODIFICATIONS];

                        // Do not need to interact with bounding volumes.
                        // They are in the stack for relative positioning
                        // if they weren't then we would have to manually move
                        // the bounding box to follow the children
                        const float parentBlendStrength = (
                            parentStack[stackIndex][BLEND_STRENGTH]
                        );
                        const float parentNextDistance = parentStack[stackIndex][DISTANCE];
                        const float4 parentDiffuseColour = float4(
                            parentStack[stackIndex][DIFFUSE_COLOUR_R],
                            parentStack[stackIndex][DIFFUSE_COLOUR_G],
                            parentStack[stackIndex][DIFFUSE_COLOUR_B],
                            parentStack[stackIndex][SPECULAR_ROUGHNESS]
                        );
                        const float4 parentSpecularColour = float4(
                            parentStack[stackIndex][SPECULAR_COLOUR_R],
                            parentStack[stackIndex][SPECULAR_COLOUR_G],
                            parentStack[stackIndex][SPECULAR_COLOUR_B],
                            parentStack[stackIndex][SPECULAR]
                        );
                        const float4 parentTransmissiveColour = float4(
                            parentStack[stackIndex][EXTINCTION_R],
                            parentStack[stackIndex][EXTINCTION_G],
                            parentStack[stackIndex][EXTINCTION_B],
                            parentStack[stackIndex][TRANSMISSION]
                        );
                        const float4 parentEmissiveColour = float4(
                            parentStack[stackIndex][EMISSION_R],
                            parentStack[stackIndex][EMISSION_G],
                            parentStack[stackIndex][EMISSION_B],
                            0
                        );
                        const float4 parentScatteringCoefficient = float4(
                            parentStack[stackIndex][SCATTERING_R],
                            parentStack[stackIndex][SCATTERING_G],
                            parentStack[stackIndex][SCATTERING_B],
                            0
                        );
                        const float parentTransmissionRoughness = (
                            parentStack[stackLastIndex][TRANSMISSION_ROUGHNESS]
                        );

                        const float parentRefractiveIndex = (
                            parentStack[stackLastIndex][PARENT_REFRACTIVE_INDEX]
                        );

                        if (fabs(nextDistance) > fabs(parentNextDistance))
                        {
                            objectId = parentStack[stackIndex][PARENT_OBJECT_ID];
                        }

                        // Compute interaction between parent and this child
                        nextDistance = performChildInteraction(
                            parentModifications,
                            parentNextDistance,
                            nextDistance,
                            parentDiffuseColour,
                            blendedDiffuseColour,
                            parentSpecularColour,
                            blendedSpecularColour,
                            parentTransmissiveColour,
                            blendedTransmissiveColour,
                            parentEmissiveColour,
                            blendedEmissiveColour,
                            parentScatteringCoefficient,
                            blendedScatteringCoefficient,
                            parentTransmissionRoughness,
                            blendedTransmissionRoughness,
                            parentRefractiveIndex,
                            blendedRefractiveIndex,
                            parentBlendStrength
                        );

                        // Update the global min distance (and surface/colour)
                        if (fabs(nextDistance) < fabs(distance))
                        {
                            distance = nextDistance;

                            diffusivity = blendedDiffuseColour;
                            specularity = blendedSpecularColour;
                            transmittance = blendedTransmissiveColour;
                            emittance = blendedEmissiveColour;
                            scatteringCoefficient = blendedScatteringCoefficient;
                            specularRoughness = blendedDiffuseColour.w;
                            transmissionRoughness = blendedTransmissionRoughness;
                            refractiveIndex = blendedRefractiveIndex;

                            id = objectId;

                            doRefraction = parentModifications & 262144;
                        }
                    }

                    do
                    {
                        // Decrement the number of children each parent has
                        for (int parentIndex=stackLastIndex; parentIndex >= 0; parentIndex--)
                        {
                            parentStack[parentIndex][NUM_CHILDREN] -= 1.0f;
                        }

                        // Get the number of children still remaining for the parent
                        // If there are still children, we can break out of this loop
                        // to process the rest of them before the parent itself
                        numChildren = parentStack[stackLastIndex][NUM_CHILDREN];
                    }
                    while (numChildren <= 0.0f && --stackLastIndex >= 0);

                    parentStackLength = stackLastIndex + 1;
                }
                // No parents to interact with, simply check the distance
                else if (fabs(nextDistance) < fabs(distance))
                {
                    distance = nextDistance;

                    diffusivity = blendedDiffuseColour;
                    specularity = blendedSpecularColour;
                    transmittance = blendedTransmissiveColour;
                    emittance = blendedEmissiveColour;
                    scatteringCoefficient = blendedScatteringCoefficient;
                    specularRoughness = blendedDiffuseColour.w;
                    transmissionRoughness = blendedTransmissionRoughness;
                    refractiveIndex = blendedRefractiveIndex;

                    id = objectId;

                    doRefraction = modifications & 262144;
                }
            }
            else
            {
                // Node has Children, push it to the stack for later
                // processing when we have all its children
                // parentStack.push()
                parentStack[parentStackLength][NUM_CHILDREN] = numChildren;
                parentStack[parentStackLength][TRANSFORM_X] = transformedRay.x;
                parentStack[parentStackLength][TRANSFORM_Y] = transformedRay.y;
                parentStack[parentStackLength][TRANSFORM_Z] = transformedRay.z;
                parentStack[parentStackLength][SCALE] = scale;
                parentStack[parentStackLength][MODIFICATIONS] = (float) modifications;
                parentStack[parentStackLength][BLEND_STRENGTH] = blendStrength;
                parentStack[parentStackLength][DISTANCE] = nextDistance;
                parentStack[parentStackLength][DIFFUSE_COLOUR_R] = blendedDiffuseColour.x;
                parentStack[parentStackLength][DIFFUSE_COLOUR_G] = blendedDiffuseColour.y;
                parentStack[parentStackLength][DIFFUSE_COLOUR_B] = blendedDiffuseColour.z;
                parentStack[parentStackLength][SPECULAR_ROUGHNESS] = blendedDiffuseColour.w;
                parentStack[parentStackLength][SPECULAR_COLOUR_R] = blendedSpecularColour.x;
                parentStack[parentStackLength][SPECULAR_COLOUR_G] = blendedSpecularColour.y;
                parentStack[parentStackLength][SPECULAR_COLOUR_B] = blendedSpecularColour.z;
                parentStack[parentStackLength][SPECULAR] = blendedSpecularColour.w;
                parentStack[parentStackLength][EXTINCTION_R] = blendedTransmissiveColour.x;
                parentStack[parentStackLength][EXTINCTION_G] = blendedTransmissiveColour.y;
                parentStack[parentStackLength][EXTINCTION_B] = blendedTransmissiveColour.z;
                parentStack[parentStackLength][TRANSMISSION] = blendedTransmissiveColour.w;
                parentStack[parentStackLength][EMISSION_R] = blendedEmissiveColour.x;
                parentStack[parentStackLength][EMISSION_G] = blendedEmissiveColour.y;
                parentStack[parentStackLength][EMISSION_B] = blendedEmissiveColour.z;
                parentStack[parentStackLength][SCATTERING_R] = blendedScatteringCoefficient.x;
                parentStack[parentStackLength][SCATTERING_G] = blendedScatteringCoefficient.y;
                parentStack[parentStackLength][SCATTERING_B] = blendedScatteringCoefficient.z;
                parentStack[parentStackLength][TRANSMISSION_ROUGHNESS] = blendedTransmissionRoughness;
                parentStack[parentStackLength][PARENT_REFRACTIVE_INDEX] = blendedRefractiveIndex;
                parentStack[parentStackLength][PARENT_OBJECT_ID] = objectId;
                parentStackLength++;
            }
        }

        diffusivity.w = 1.0f - specularity.w - transmittance.w;

        return distance;
    }


    /**
     * Estimate the surface normal at the closest point on the closest
     * object to a point
     *
     * @arg point: The point near which to get the surface normal
     * @arg pixelFootprint: A value proportional to the amount of world
     *     space that fills a pixel, like the distance from camera.
     *
     * @returns: The normalized surface normal.
     */
    float3 estimateSurfaceNormal(const float3 &point, const float pixelFootprint)
    {
        return normalize(
            __offset0 * getMinDistanceToObjectInScene(
                point + __offset0 * _hitTolerance,
                pixelFootprint
            )
            + __offset1 * getMinDistanceToObjectInScene(
                point + __offset1 * _hitTolerance,
                pixelFootprint
            )
            + __offset2 * getMinDistanceToObjectInScene(
                point + __offset2 * _hitTolerance,
                pixelFootprint
            )
            + __offset3 * getMinDistanceToObjectInScene(
                point + __offset3 * _hitTolerance,
                pixelFootprint
            )
        );
    }


    /**
     * Sample the data of a particular artificial light in the scene.
     * Artificial lights are any that are passed into the 'lights'
     * input.
     *
     * @arg position: The position on the surface to sample the data of.
     * @arg lightIndex: The index of the chosen light in the lights
     *     texture.
     * @arg numLights: The number of lights in the scene.
     * @arg lightDirection: The direction from the surface to the light.
     * @arg distanceToLight: The distance to the light's surface.
     *
     * @returns: The PDF of the light.
     */
    float sampleArtificialLightData(
            const float3 &position,
            const int lightIndex,
            const int numLights,
            float3 &lightDirection,
            float &distanceToLight)
    {
        float visibleSurfaceArea = 1.0f;

        // Selected a 'fake' light eg. point, directional, ambient
        SampleType(lights) light = lights(lightIndex, 0);
        const int lightType = abs((int) lightProperties(lightIndex, 0, 3));

        if (lightType > 1)
        {
            getLightData(
                position,
                float3(light.x, light.y, light.z),
                lightType,
                _maxRayDistance,
                distanceToLight,
                visibleSurfaceArea,
                lightDirection
            );
        }

        return sampleLightsPDF(max(1, numLights), visibleSurfaceArea);
    }


    /**
     * Sample the data of a particular physical light in the scene.
     * Physical lights are any that have an emissive material, rather
     * than being passed into the 'lights' input with the artificial
     * lights.
     *
     * @arg seed: The seed to use in randomization.
     * @arg position: The position on the surface to sample the data of.
     * @arg objectIndex: The index of the chosen light in the object
     *     texture.
     * @arg numLights: The number of lights in the scene.
     * @arg lightDirection: The direction from the surface to the light.
     * @arg distanceToLight: The distance to the light's surface.
     *
     * @returns: The PDF of the light.
     */
    float samplePhysicalLightData(
            const float3 &seed,
            const float3 &position,
            const int objectIndex,
            const int numLights,
            float3 &lightDirection,
            float &distanceToLight)
    {
        float visibleSurfaceArea = 1.0f;

        const float3 objectPosition = getObjectPosition(objectIndex);

        sphericalLightData(
            seed,
            position,
            objectPosition,
            getRadius(objectIndex),
            lightDirection,
            distanceToLight,
            visibleSurfaceArea
        );

        if (_maxLightSamplingBounces > 1 && __lightSamplingAngle > 0.0f)
        {
            lightDirection = uniformDirectionInSolidAngle(
                lightDirection,
                __lightSamplingAngle,
                RAND_CONST_0 * seed
            );
        }

        return sampleLightsPDF(max(1, numLights), visibleSurfaceArea);
    }


    /**
     * Sample the data of a particular light in the scene.
     *
     * @arg seed: The seed to use in randomization.
     * @arg position: The position on the surface to sample the data of.
     * @arg surfaceNormal: The normal to the surface at the position we
     *     are sampling the data of.
     * @arg emissiveIndices: The indices of the emissive objects in the
     *     scene.
     * @arg numEmissive: The number of emissive objects in the scene.
     * @arg numLights: The number of lights in the scene.
     * @arg selectedLight: The index of the chosen light to sample.
     * @arg lightDirection: The direction from the surface to the light.
     * @arg distanceToLight: The distance to the light's surface.
     *
     * @returns: The PDF of the light.
     */
    float sampleLightData(
            const float3 &seed,
            const float3 &position,
            const float3 &surfaceNormal,
            const int emissiveIndices[MAX_MIS_EMISSIVE_SHAPES],
            const int numEmissive,
            const int numLights,
            const int selectedLight,
            float3 &lightDirection,
            float &distanceToLight)
    {
        float visibleSurfaceArea = 1.0f;

        if (selectedLight < _lightTextureWidth)
        {
            return sampleArtificialLightData(
                position,
                selectedLight,
                numLights,
                lightDirection,
                distanceToLight
            );
        }
        else if (selectedLight - _lightTextureWidth < numEmissive)
        {
            return samplePhysicalLightData(
                seed,
                position,
                emissiveIndices[selectedLight - _lightTextureWidth],
                numLights,
                lightDirection,
                distanceToLight
            );
        }

        hdriLightData(
            seed * RAND_CONST_1,
            surfaceNormal,
            lightDirection,
            distanceToLight
        );
        return sampleLightsPDF(max(1, numLights), 1.0f);
    }


    /**
     * Sample the data of a random light in the scene.
     *
     * @arg seed: The seed to use in randomization.
     * @arg position: The position on the surface to sample the data of.
     * @arg surfaceNormal: The normal to the surface at the position we
     *     are sampling the data of.
     * @arg emissiveIndices: The indices of the emissive objects in the
     *     scene.
     * @arg numEmissive: The number of emissive objects in the scene.
     * @arg sampleHDRI: Whether or not to sample the HDRI. If there are
     *     lights in the scene this will increase the noise, but will be
     *     more accurate.
     * @arg lightDirection: The direction from the surface to the light.
     * @arg distanceToLight: The distance to the light's surface.
     * @arg selectedLight: The index of the chosen light to sample.
     *
     * @returns: The PDF of the light.
     */
    float sampleRandomLightData(
            const float3 &seed,
            const float3 &position,
            const float3 &surfaceNormal,
            const int emissiveIndices[MAX_MIS_EMISSIVE_SHAPES],
            const int numEmissive,
            const bool sampleHDRI,
            float3 &lightDirection,
            float &distanceToLight,
            int &selectedLight)
    {
        const float rng = random(random(seed.x + seed.y) + random(seed.z));
        const int numSamplingOptions = (
            numEmissive
            + _lightTextureWidth
            + sampleHDRI
        );
        selectedLight = max(0, (int) floor(rng * (numSamplingOptions - 0.0001f)));

        return sampleLightData(
            seed,
            position,
            surfaceNormal,
            emissiveIndices,
            numEmissive,
            numSamplingOptions,
            selectedLight,
            lightDirection,
            distanceToLight
        );
    }


    /**
     * Compute a soft shadow value.
     *
     * @arg rayOrigin: The origin of the ray.
     * @arg rayDirection: The direction to cast the shadow ray.
     * @arg distanceToShadePoint: The maximum distance to check for
     *     a shadow casting object.
     * @arg softness: The softness of the shadow.
     *
     * @returns: The shadow intenstity.
     */
    inline float sampleSoftShadow(
            const float3 &rayOrigin,
            const float3 &rayDirection,
            const float distanceToShadePoint,
            const float softness)
    {
        float distanceTravelled = 0;
        float shadowIntensity = 1.0f;
        float lastStepDistance = FLT_MAX;

        int iterations = 0;
        float pixelFootprint = _hitTolerance;

        float3 position = rayOrigin;
        while (distanceTravelled < distanceToShadePoint && iterations < _maxRaySteps / 2)
        {
            const float stepDistance = fabs(
                getMinDistanceToObjectInScene(position, pixelFootprint)
            );
            const float stepDistanceSquared = stepDistance * stepDistance;
            float softOffset = stepDistanceSquared / (2.0f * lastStepDistance);
            shadowIntensity = min(
                shadowIntensity,
                softness * sqrt(stepDistanceSquared - softOffset * softOffset)
                / max(0.0f, distanceTravelled - softOffset)
            );

            if (stepDistance < pixelFootprint)
            {
                shadowIntensity = saturate(shadowIntensity);
                return shadowIntensity * shadowIntensity * (3.0f - 2.0f * shadowIntensity);
            }

            lastStepDistance = stepDistance;
            position += rayDirection * stepDistance;
            distanceTravelled += stepDistance;
            pixelFootprint += stepDistance * _hitTolerance;
            iterations++;
        }

        shadowIntensity = saturate(shadowIntensity);
        return shadowIntensity * shadowIntensity * (3.0f - 2.0f * shadowIntensity);
    }


    /**
     * Compute a shadow value.
     *
     * @arg rayOrigin: The origin of the ray.
     * @arg rayDirection: The direction to cast the shadow ray.
     * @arg distanceToShadePoint: The maximum distance to check for
     *     a shadow casting object.
     *
     * @returns: The shadow intenstity.
     */
    float sampleShadow(
            const float3 &rayOrigin,
            const float3 &rayDirection,
            const float distanceToShadePoint)
    {
        float distanceTravelled = 0;
        int iterations = 0;
        float pixelFootprint = _hitTolerance;
        float3 position = rayOrigin;

        while (distanceTravelled < distanceToShadePoint && iterations < _maxRaySteps / 2)
        {
            const float stepDistance = fabs(
                getMinDistanceToObjectInScene(position, pixelFootprint)
            );

            if (stepDistance < pixelFootprint)
            {
                return 0;
            }

            position += rayDirection * stepDistance;
            distanceTravelled += stepDistance;
            pixelFootprint += stepDistance * _hitTolerance;
            iterations++;
        }

        return 1;
    }


    /**
     * Compute the ambient occlusion.
     *
     * @arg rayOrigin: The origin of the ray.
     * @arg surfaceNormal: The normal to the surface.
     * @arg amount: The amount to scale the occlusion value by.
     * @arg iterations: The number of iterations to refine the
     *     occlusion.
     *
     * @returns: The occlusion value.
     */
    inline float sampleAmbientOcclusion(
            const float3 &rayOrigin,
            const float3 &surfaceNormal,
            const float amount,
            const int iterations)
    {
        float occlusion = 0.0f;
        float occlusionScaleFactor = 1.0f;
        for (int iteration=0; iteration < iterations; iteration++)
        {
            const float stepDistance = 0.001f + 0.15f * float(iteration) / 4.0f;
            const float distanceToClosestObject = fabs(
                getMinDistanceToObjectInScene(
                    rayOrigin + stepDistance * surfaceNormal,
                    _hitTolerance
                )
            );
            occlusion += (stepDistance - distanceToClosestObject) * occlusionScaleFactor;
            occlusionScaleFactor *= 0.95;
        }

        return (
            amount
            * saturate(0.5f + 0.5f * surfaceNormal.y)  // ambient
            * saturate(1.0f - 1.5f * occlusion)       // occlusion
        );
    }


    /**
     * Perform direct illumination light sampling on a chosen artificial
     * light in the scene.
     *
     * @arg pointOnSurface: The point on the surface to compute the
     *     light intensity at.
     * @arg surfaceNormal: The normal to the surface at the position we
     *     are sampling the illumination of.
     * @arg lightDirection: The direction from the surface to the light.
     * @arg distanceToLight: The distance to the light's surface.
     * @arg selectedLight: The index of the chosen light to sample.
     *
     * @returns: The colour of the sampled light.
     */
    inline float4 sampleArtificialLight(
            const float3 &pointOnSurface,
            const float3 &surfaceNormal,
            const float3 &lightDirection,
            const float distanceToLight,
            const int selectedLight)
    {
        // Read the light properties
        SampleType(lights) light = lights(selectedLight, 0);
        SampleType(lightProperties) lightProperty = lightProperties(selectedLight, 0);
        SampleType(lightProperties1) lightProperty1 = lightProperties1(selectedLight, 0);

        float2 intensity;

        int lightType = (int) lightProperty.w;
        int absLightType = abs(lightType);

        if (absLightType == 0)
        {
            // Ambient light, simply return the intensity.
            intensity = float2(light.w, 1);
        }
        else if (absLightType == 1)
        {
            intensity = float2(
                1.0f,
                sampleAmbientOcclusion(
                    pointOnSurface,
                    surfaceNormal,
                    light.w,
                    (int) light.x
                )
            );
        }
        else
        {
            float intensityAtPosition = lightIntensity(
                light.w,
                lightProperty1.y,
                distanceToLight
            );

            float shadowIntensityAtPosition;
            if (lightType < 0)
            {
                shadowIntensityAtPosition = sampleSoftShadow(
                    pointOnSurface,
                    lightDirection,
                    distanceToLight,
                    lightProperty1.x
                );
            }
            else
            {
                shadowIntensityAtPosition = sampleShadow(
                    pointOnSurface,
                    lightDirection,
                    distanceToLight
                );
            }

            intensity = float2(intensityAtPosition, shadowIntensityAtPosition);
        }

        return intensity.x * intensity.y * float4(
            lightProperty.x,
            lightProperty.y,
            lightProperty.z,
            0
        );
    }


    /**
     * Perform direct illumination light sampling on every artificial
     * light in the scene.
     *
     * @arg position: The position on the surface to sample the
     *     illumination of.
     * @arg surfaceNormal: The surface normal at the intersection point.
     * @arg throughput: The throughput of the ray.
     * @arg materialBRDF: The BRDF of the surface at the position we
     *     are sampling the illumination of.
     * @arg materialPDF: The PDF of the material we are sampling the
     *     direct illumination of.
     *
     * @returns: The colour of the sampled light.
     */
    inline float4 sampleArtificialLights(
            const float3 &position,
            const float3 &surfaceNormal,
            const float4 &throughput,
            const float4 &materialBRDF,
            const float materialPDF)
    {
        float4 lightColour = float4(0);

        for (int lightIndex=0; lightIndex < _lightTextureWidth; lightIndex++)
        {
            float3 lightDirection = surfaceNormal;
            float distanceToLight = 0.0f;

            const float lightPDF = sampleArtificialLightData(
                position,
                lightIndex,
                _lightTextureWidth,
                lightDirection,
                distanceToLight
            );

            float geometryFactor = saturate(dot(lightDirection, surfaceNormal));

            lightColour += multipleImportanceSample(
                sampleArtificialLight(
                    position,
                    surfaceNormal,
                    lightDirection,
                    distanceToLight,
                    lightIndex
                ),
                throughput * materialBRDF * geometryFactor / lightPDF,
                lightPDF,
                materialPDF * geometryFactor
            );
        }

        return lightColour;
    }


    /**
     * Handle the interaction between a ray and the surface of a material.
     *
     * @arg pixelFootprint: A value proportional to the amount of world
     *     space that fills a pixel, like the distance from camera.
     * @arg distance: The distance travelled since the last bounce.
     * @arg intersectionPosition: The position at which the ray
     *     intersects the geometry.
     * @arg surfaceNormal: The surface normal at the intersection point.
     * @arg objectId: The ID of the object that was hit.
     * @arg doRefraction: Whether or not refraction is enabled on the
     *     material.
     * @arg numLights: The number of lights in the scene.
     * @arg seed: The seed to use in randomization.
     * @arg direction: The incoming ray direction.
     * @arg origin: The ray origin.
     * @arg diffusivity: The diffuse values of the surface.
     * @arg specularity: The specular values of the surface.
     * @arg transmittance: The extinction coefficient and transmissive
     *     probability of the surface.
     * @arg emittance: The emissive values of the surface.
     * @arg specularRoughness: The specular roughness of the surface.
     * @arg transmissionRoughness: The transmissive roughness of the
     *     surface.
     * @arg refractiveIndex: The refractive index of the material.
     * @arg scatteringCoefficient: The scattering coefficient of the
     *     material.
     * @arg nestedDielectrics: The stack of dielectrics that we have
     *     entered without exiting.
     * @arg numNestedDielectrics: The number of dielectrics in the
     *     stack.
     * @arg rayColour: The colour of the ray.
     * @arg throughput: The throughput of the ray.
     * @arg previousMaterialPDF: The PDF of the last material interacted
     *     with.
     */
    void materialInteraction(
            const float pixelFootprint,
            const float distance,
            const float3 &intersectionPosition,
            const float3 &surfaceNormal,
            const int objectId,
            const bool doRefraction,
            const float numLights,
            float3 &seed,
            float3 &direction,
            float3 &origin,
            float4 &diffusivity,
            float4 &specularity,
            float4 &transmittance,
            float4 &emittance,
            float &specularRoughness,
            float &transmissionRoughness,
            float &refractiveIndex,
            float4 &scatteringCoefficient,
            float nestedDielectrics[MAX_NESTED_DIELECTRICS][NESTED_DIELECTRIC_PARAMS],
            int &numNestedDielectrics,
            float4 &rayColour,
            float4 &throughput,
            float &previousMaterialPDF)
    {
        // Use the noise to modify the surface properties
        noiseMaterialInteraction(
            objectId - 1,
            intersectionPosition,
            diffusivity,
            specularity,
            transmittance,
            emittance,
            specularRoughness,
            transmissionRoughness,
            refractiveIndex
        );

        // Compute the amount we would offset a point to escape the surface
        const float offset = 2.0f * pixelFootprint * _shadowBias;

        const float4 extinctionCoefficient = getExtinctionCoefficient(
            nestedDielectrics,
            numNestedDielectrics
        );
        throughput *= exp(-distance * extinctionCoefficient);

        origin = intersectionPosition;

        // Get material data for material and light sampling
        float4 materialBRDF;
        float3 bounceDirection;
        float materialLightPDF;
        const float materialPDF = sampleMaterial(
            seed,
            surfaceNormal,
            direction,
            diffusivity,
            offset,
            transmittance,
            doRefraction,
            refractiveIndex,
            scatteringCoefficient,
            transmissionRoughness,
            specularity,
            specularRoughness,
            objectId,
            isExitingObject(
                nestedDielectrics[numNestedDielectrics][OBJECT_ID] - 1,
                objectId - 1
            ),
            materialBRDF,
            bounceDirection,
            origin,
            nestedDielectrics,
            numNestedDielectrics,
            materialLightPDF
        );

        if (
            __lightSamplingEnabled
            && _doSecondaryLightSampling
            && materialLightPDF > 0.0f
            && _lightTextureWidth > 0
        ) {
            const float3 offsetPosition = offsetPoint(
                origin,
                surfaceNormal,
                offset
            );
            // Perform MIS light sampling
            rayColour += sampleArtificialLights(
                offsetPosition,
                surfaceNormal,
                throughput,
                materialBRDF,
                materialLightPDF
            );
        }

        const float radius = getRadius(objectId - 1);
        const float visibleSurfaceArea = 2.0f * PI * radius * radius;

        rayColour += multipleImportanceSample(
            emittance,
            throughput,
            previousMaterialPDF,
            sampleLightsPDF(numLights, visibleSurfaceArea)
        );

        throughput *= materialBRDF / materialPDF;

        // Prepare the variables for the next march
        previousMaterialPDF = materialPDF;

        direction = bounceDirection;
    }


    /**
     * March a path through the scene, with only MIS material and
     * artifical light sampling.
     *
     * @arg rayOrigin: The origin of the ray.
     * @arg rayDirection: The direction of the ray.
     * @arg initialSeed: The seed to use in randomization.
     * @arg sampleHDRI: Whether or not to sample the HDRI. If there are
     *     lights in the scene this will increase the noise, but will be
     *     more accurate.
     * @arg maxRayDistance: The maximum distance the ray can travel.
     * @arg currentNestedDielectrics: The stack of dielectrics that we
     *     have entered without exiting.
     * @arg currentNumNestedDielectrics: The number of dielectrics in
     *     the stack.
     * @arg numEmissive: The number of emissive objects in the scene.
     * @arg distanceTravelled: Location to store the distance the ray
     *     actually travels.
     *
     * @returns: The ray colour.
     */
    inline float4 marchPath(
            const float3 &rayOrigin,
            const float3 &rayDirection,
            const float3 &initialSeed,
            const bool sampleHDRI,
            const float maxRayDistance,
            const float currentNestedDielectrics[MAX_NESTED_DIELECTRICS][NESTED_DIELECTRIC_PARAMS],
            const int currentNumNestedDielectrics,
            const int numEmissive,
            float &distanceTravelled)
    {
        const int numLights = _lightTextureWidth + numEmissive + sampleHDRI;

        float nestedDielectrics[MAX_NESTED_DIELECTRICS][NESTED_DIELECTRIC_PARAMS];
        for (int nestedIndex=0; nestedIndex <= currentNumNestedDielectrics; nestedIndex++)
        {
            for (int dataIndex=0; dataIndex < NESTED_DIELECTRIC_PARAMS; dataIndex++)
            {
                nestedDielectrics[nestedIndex][dataIndex] = (
                    currentNestedDielectrics[nestedIndex][dataIndex]
                );
            }
        }
        int numNestedDielectrics = currentNumNestedDielectrics;

        float4 rayColour = float4(0);
        float4 throughput = float4(1);

        float lastStepDistance = 1.0f;

        float firstObjectId = 0.0f;

        int iterations = 0;
        int bounces = 0;

        distanceTravelled = 0;
        float distanceSinceLastBounce = distanceTravelled;

        // Get the next ray
        float3 origin = rayOrigin;
        float3 direction = rayDirection;
        float3 positionOnRay = origin;

        float4 diffusivity;
        float4 specularity;
        float4 transmittance;
        float4 emittance;

        float pixelFootprint = _hitTolerance;

        float previousMaterialPDF = 1.0f;

        float3 seed = initialSeed;

        // March the ray
        while (
            distanceTravelled < maxRayDistance
            && iterations < _maxRaySteps
            && sumComponent(throughput) > _hitTolerance
        ) {
            positionOnRay = origin + distanceSinceLastBounce * direction;

            // Get the closest distance to an object
            bool doRefraction = true;
            float4 scatteringCoefficient = float4(0);
            float specularRoughness = 0.0f;
            float transmissionRoughness = 0.0f;
            float refractiveIndex = 1.0f;
            int objectId = 0;

            const float signedStepDistance = getMinDistanceToObjectInScene(
                positionOnRay,
                pixelFootprint,
                diffusivity,
                specularity,
                transmittance,
                emittance,
                scatteringCoefficient,
                specularRoughness,
                transmissionRoughness,
                refractiveIndex,
                doRefraction,
                objectId
            );

            // Get the absolute value, the true shortest distance to a
            // surface
            const float stepDistance = fabs(signedStepDistance);

            // Keep track of the distance the ray has travelled
            distanceTravelled += stepDistance;
            distanceSinceLastBounce += stepDistance;

            // Have we hit the nearest object?
            if (stepDistance < pixelFootprint)
            {
                float3 intersectionPosition = positionOnRay + stepDistance * direction;

                // The normal to the surface at that position
                float3 surfaceNormal = sign(lastStepDistance) * estimateSurfaceNormal(
                    intersectionPosition,
                    pixelFootprint
                );

                materialInteraction(
                    pixelFootprint,
                    distanceSinceLastBounce,
                    intersectionPosition,
                    surfaceNormal,
                    objectId,
                    doRefraction,
                    numLights,
                    seed,
                    direction,
                    origin,
                    diffusivity,
                    specularity,
                    transmittance,
                    emittance,
                    specularRoughness,
                    transmissionRoughness,
                    refractiveIndex,
                    scatteringCoefficient,
                    nestedDielectrics,
                    numNestedDielectrics,
                    rayColour,
                    throughput,
                    previousMaterialPDF
                );

                // Exit if we have reached the bounce limit
                // or with a random chance
                const float rng = random(random(seed.x) + random(seed.y + random(seed.z)));
                const float exitProbability = max(
                    throughput.x,
                    throughput.y,
                    throughput.z
                );
                if (
                    ++bounces > _maxLightSamplingBounces
                    || emittance.w > 0.0f
                    || (_roulette && exitProbability <= rng)
                ) {
                    return rayColour;
                }
                if (_roulette)
                {
                    // Account for the lost intensity from the early exits
                    throughput /= exitProbability;
                }

                // Update the random seed
                seed = RAND_CONST_8 * random(
                    seed
                    + rng
                    + random(fabs(intersectionPosition + direction))
                );

                // Reset the pixel footprint so multiple reflections don't
                // reduce precision
                pixelFootprint = _hitTolerance;
            }
            else if (_levelOfDetail)
            {
                pixelFootprint += _hitTolerance * stepDistance;
            }

            lastStepDistance = signedStepDistance;
            iterations++;
        }

        distanceTravelled = (
            distanceSinceLastBounce
            + _maxRayDistance
            - distanceTravelled
        );

        // Read the hdri value in the direction the ray was last travelling
        // and absorb an amount of light proportional to the distance travelled
        // through the last material
        rayColour += (
            throughput
            * readHDRIValue(direction)
            * getScatteringCoefficient(
                nestedDielectrics,
                numNestedDielectrics
            ) * exp(
                -distanceTravelled
                * getExtinctionCoefficient(
                    nestedDielectrics,
                    numNestedDielectrics
                )
            )
        );

        return rayColour;
    }


    /**
     * Perform direct illumination light sampling on a chosen light in
     * the scene.
     *
     * @arg seed: The seed to use in randomization.
     * @arg throughput: The throughput of the ray.
     * @arg materialBRDF: The BRDF of the surface at the position we
     *     are sampling the illumination of.
     * @arg distanceToLight: The distance to the light's surface.
     * @arg surfaceNormal: The normal to the surface at the position we
     *     are sampling the illumination of.
     * @arg position: The position on the surface to sample the
     *     illumination of.
     * @arg lightDirection: The direction from the surface to the light.
     * @arg lightPDF: The PDF of the light we are sampling the
     *     direct illumination of.
     * @arg materialPDF: The PDF of the material we are sampling the
     *     direct illumination of.
     * @arg selectedLight: The index of the chosen light to sample.
     * @arg numEmissive: The number of emissive objects in the scene.
     * @arg sampleHDRI: Whether or not to sample the HDRI. If there are
     *     lights in the scene this will increase the noise, but will be
     *     more accurate.
     * @arg nestedDielectrics: The stack of dielectrics that we have
     *     entered without exiting.
     * @arg numNestedDielectrics: The number of dielectrics in the
     *     stack.
     *
     * @returns: The colour of the sampled light.
     */
    float4 sampleLight(
            const float3 &seed,
            const float4 &throughput,
            const float4 &materialBRDF,
            const float distanceToLight,
            const float3 &surfaceNormal,
            const float3 &position,
            const float3 &lightDirection,
            const float lightPDF,
            const float materialPDF,
            const int selectedLight,
            const int numEmissive,
            const bool sampleHDRI,
            const float nestedDielectrics[MAX_NESTED_DIELECTRICS][NESTED_DIELECTRIC_PARAMS],
            const int numNestedDielectrics)
    {
        float4 lightColour = float4(0);
        float lightGeometryFactor;

        if (selectedLight < _lightTextureWidth)
        {
            lightColour = sampleArtificialLight(
                position,
                surfaceNormal,
                lightDirection,
                distanceToLight,
                selectedLight
            );
            lightGeometryFactor = saturate(dot(lightDirection, surfaceNormal));
        }
        else if (selectedLight - _lightTextureWidth - sampleHDRI < numEmissive)
        {
            float actualDistance;
            lightColour = marchPath(
                position,
                lightDirection,
                seed,
                sampleHDRI,
                distanceToLight * 2.0f,
                nestedDielectrics,
                numNestedDielectrics,
                numEmissive,
                actualDistance
            );
            lightGeometryFactor = geometryFactor(
                lightDirection,
                surfaceNormal,
                actualDistance
            );
        }

        return multipleImportanceSample(
            lightColour,
            throughput * materialBRDF * lightGeometryFactor / lightPDF,
            lightPDF,
            materialPDF * lightGeometryFactor
        );
    }



    /**
     * Perform direct illumination light sampling on a random light in
     * the scene.
     *
     * @arg seed: The seed to use in randomization.
     * @arg throughput: The throughput of the ray.
     * @arg materialBRDF: The BRDF of the surface at the position we
     *     are sampling the illumination of.
     * @arg surfaceNormal: The normal to the surface at the position we
     *     are sampling the illumination of.
     * @arg position: The position on the surface to sample the
     *     illumination of.
     * @arg materialPDF: The PDF of the material we are sampling the
     *     direct illumination of.
     * @arg emissiveIndices: The indices of the emissive objects in the
     *     scene.
     * @arg numEmissive: The number of emissive objects in the scene.
     * @arg sampleHDRI: Whether or not to sample the HDRI. If there are
     *     lights in the scene this will increase the noise, but will be
     *     more accurate.
     * @arg nestedDielectrics: The stack of dielectrics that we have
     *     entered without exiting.
     * @arg numNestedDielectrics: The number of dielectrics in the
     *     stack.
     *
     * @returns: The colour of the sampled light.
     */
    inline float4 sampleRandomLight(
            const float3 &seed,
            const float4 &throughput,
            const float4 &materialBRDF,
            const float3 &surfaceNormal,
            const float3 &position,
            const float materialPDF,
            const int emissiveIndices[MAX_MIS_EMISSIVE_SHAPES],
            const int numEmissive,
            const bool sampleHDRI,
            const float nestedDielectrics[MAX_NESTED_DIELECTRICS][NESTED_DIELECTRIC_PARAMS],
            const int numNestedDielectrics)
    {
        float3 lightDirection = surfaceNormal;
        float distanceToLight = 0.0f;
        int selectedLight;

        // Get data for light sampling
        float lightPDF = sampleRandomLightData(
            seed,
            position,
            surfaceNormal,
            emissiveIndices,
            numEmissive,
            sampleHDRI,
            lightDirection,
            distanceToLight,
            selectedLight
        );

        // Perform MIS light sampling
        return sampleLight(
            seed * RAND_CONST_2,
            throughput,
            materialBRDF,
            distanceToLight,
            surfaceNormal,
            position,
            lightDirection,
            lightPDF,
            materialPDF,
            selectedLight,
            numEmissive,
            sampleHDRI,
            nestedDielectrics,
            numNestedDielectrics
        );
    }


    /**
     * Perform direct illumination light sampling on every light in the
     * scene.
     *
     * @arg seed: The seed to use in randomization.
     * @arg throughput: The throughput of the ray.
     * @arg materialBRDF: The BRDF of the surface at the position we
     *     are sampling the illumination of.
     * @arg surfaceNormal: The normal to the surface at the position we
     *     are sampling the illumination of.
     * @arg position: The position on the surface to sample the
     *     illumination of.
     * @arg materialPDF: The PDF of the material we are sampling the
     *     direct illumination of.
     * @arg emissiveIndices: The indices of the emissive objects in the
     *     scene.
     * @arg numEmissive: The number of emissive objects in the scene.
     * @arg sampleHDRI: Whether or not to sample the HDRI. If there are
     *     lights in the scene this will increase the noise, but will be
     *     more accurate.
     * @arg nestedDielectrics: The stack of dielectrics that we have
     *     entered without exiting.
     * @arg numNestedDielectrics: The number of dielectrics in the
     *     stack.
     *
     * @returns: The colour of the sampled light.
     */
    inline float4 sampleLights(
            const float3 &seed,
            const float4 &throughput,
            const float4 &materialBRDF,
            const float3 &surfaceNormal,
            const float3 &position,
            const float materialPDF,
            const int emissiveIndices[MAX_MIS_EMISSIVE_SHAPES],
            const int numEmissive,
            const bool sampleHDRI,
            const float nestedDielectrics[MAX_NESTED_DIELECTRICS][NESTED_DIELECTRIC_PARAMS],
            const int numNestedDielectrics)
    {
        float4 lightColour = float4(0);
        const int numLights = numEmissive + _lightTextureWidth + sampleHDRI;

        for (int path=0; path < numLights; path++)
        {
            float3 lightDirection = surfaceNormal;
            float distanceToLight = 0.0f;

            const float lightPDF = sampleLightData(
                seed * RAND_CONST_3 / (path + 1),
                position,
                surfaceNormal,
                emissiveIndices,
                numEmissive,
                numLights,
                path,
                lightDirection,
                distanceToLight
            );

            lightColour += sampleLight(
                seed * RAND_CONST_4 * (path + 1),
                throughput,
                materialBRDF,
                distanceToLight,
                surfaceNormal,
                position,
                lightDirection,
                lightPDF,
                materialPDF,
                path,
                numEmissive,
                sampleHDRI,
                nestedDielectrics,
                numNestedDielectrics
            );
        }

        return lightColour;
    }


    /**
     * Perform direct illumination light sampling.
     *
     * @arg seed: The seed to use in randomization.
     * @arg throughput: The throughput of the ray.
     * @arg materialBRDF: The BRDF of the surface at the position we
     *     are sampling the illumination of.
     * @arg surfaceNormal: The normal to the surface at the position we
     *     are sampling the illumination of.
     * @arg position: The position on the surface to sample the
     *     illumination of.
     * @arg materialPDF: The PDF of the material we are sampling the
     *     direct illumination of.
     * @arg offset: The amount to offset the ray in order to escape the
     *     surface.
     * @arg emissiveIndices: The indices of the emissive objects in the
     *     scene.
     * @arg numEmissive: The number of emissive objects in the scene.
     * @arg sampleHDRI: Whether or not to sample the HDRI. If there are
     *     lights in the scene this will increase the noise, but will be
     *     more accurate.
     * @arg nestedDielectrics: The stack of dielectrics that we have
     *     entered without exiting.
     * @arg numNestedDielectrics: The number of dielectrics in the
     *     stack.
     *
     * @returns: The colour of the sampled light.
     */
    inline float4 lightSampling(
            const float3 &seed,
            const float4 &throughput,
            const float4 &materialBRDF,
            const float3 &surfaceNormal,
            const float3 &position,
            const float materialPDF,
            const float offset,
            const int emissiveIndices[MAX_MIS_EMISSIVE_SHAPES],
            const int numEmissive,
            const bool sampleHDRI,
            const float nestedDielectrics[MAX_NESTED_DIELECTRICS][NESTED_DIELECTRIC_PARAMS],
            const int numNestedDielectrics)
    {
        const float3 offsetPosition = offsetPoint(
            position,
            surfaceNormal,
            offset
        );
        if (_sampleAllLights)
        {
            return sampleLights(
                seed,
                throughput,
                materialBRDF,
                surfaceNormal,
                offsetPosition,
                materialPDF,
                emissiveIndices,
                numEmissive,
                sampleHDRI,
                nestedDielectrics,
                numNestedDielectrics
            );
        }
        return sampleRandomLight(
            seed,
            throughput,
            materialBRDF,
            surfaceNormal,
            offsetPosition,
            materialPDF,
            emissiveIndices,
            numEmissive,
            sampleHDRI,
            nestedDielectrics,
            numNestedDielectrics
        );
    }


    /**
     * Perform equi-angular sampling for participating media.
     *
     * @arg seed: The seed to use in randomization.
     * @arg intersectionPosition: The position at which the ray
     *     intersects the geometry.
     * @arg rayOrigin: The ray origin.
     * @arg rayDirection: The incoming ray direction.
     * @arg distanceSinceLastBounce: The distance travelled since the
     *     last bounce.
     * @arg emissiveIndices: The indices of the emissive objects in the
     *     scene.
     * @arg numEmissive: The number of emissive objects in the scene.
     * @arg nestedDielectrics: The stack of dielectrics that we have
     *     entered without exiting.
     * @arg numNestedDielectrics: The number of dielectrics in the
     *     stack.
     * @arg throughput: The throughput of the ray.
     *
     * @returns: The colour of the ray.
     */
    float4 sampleEquiangular(
            const float3 &seed,
            const float3 &intersectionPosition,
            const float3 &rayOrigin,
            const float3 &rayDirection,
            const float distanceSinceLastBounce,
            const int emissiveIndices[MAX_MIS_EMISSIVE_SHAPES],
            const int numEmissive,
            const float nestedDielectrics[MAX_NESTED_DIELECTRICS][NESTED_DIELECTRIC_PARAMS],
            const int numNestedDielectrics,
            float4 &throughput)
    {
        // Get the scattering coefficient of the material we are in
        const float4 scatteringCoefficient = getScatteringCoefficient(
            nestedDielectrics,
            numNestedDielectrics
        );
        const float4 extinctionCoefficient = getExtinctionCoefficient(
            nestedDielectrics,
            numNestedDielectrics
        );
        float4 scatteredColour = float4(0);

        if (
            !__equiangularSamplingEnabled
            || (
                length(scatteringCoefficient) <= 0.0f
                && length(extinctionCoefficient) <= 0.0f
            )
        ) {
            throughput *= exp(-extinctionCoefficient * distanceSinceLastBounce);
            return scatteredColour;
        }

        int objectIndex = nestedDielectrics[numNestedDielectrics][OBJECT_ID] - 1;
        if (objectIndex < 0)
        {
            // blink cannot handle single pixel images in versions < 12.1
            // so we have a weird dummy pixel when only one object is passed
            // to the scene
            objectIndex = _objectTextureWidth == 0 ? 1 : _objectTextureWidth;
        }

        const float offset = random(random(seed.z) + random(seed.y + random(seed.x)));

        float extinctionNoiseSum = 0.0f;

        for (int step=1; step <= _equiangularSamples; step++)
        {
            const float uniform = (step + offset - 1) / (float) _equiangularSamples;

            float3 surfaceNormal = randomUnitVector(seed * RAND_CONST_5);
            float3 lightDirection = surfaceNormal;
            float distanceToLight = 0.0f;
            int selectedLight;

            const float lightPDF = sampleRandomLightData(
                seed * RAND_CONST_6 * step,
                intersectionPosition,
                surfaceNormal,
                emissiveIndices,
                numEmissive,
                _sampleHDRIEquiangular,
                lightDirection,
                distanceToLight,
                selectedLight
            );
            const float3 lightPosition = intersectionPosition + lightDirection * distanceToLight;

            float equiangularDistance;
            float equiangularPDF = _equiangularSamples * sampleEquiangularPDF(
                uniform,
                distanceSinceLastBounce,
                rayOrigin,
                rayDirection,
                lightPosition,
                equiangularDistance
            );

            const float3 particlePosition = rayOrigin + equiangularDistance * rayDirection;
            const float3 particleToLight = lightPosition - particlePosition;
            distanceToLight = length(particleToLight);

            if (distanceToLight > 0.0f)
            {
                lightDirection = normalize(particleToLight);
            }

            int noiseOptions;
            float noiseValue = getNoiseValue(
                objectIndex,
                particlePosition,
                noiseOptions
            );
            float scatteringNoise = noiseValue;
            float extinctionNoise = noiseValue;
            if (noiseValue < 0.0f || !(noiseOptions & SCATTERING_NOISE))
            {
                scatteringNoise = 1.0f;
            }
            if (noiseValue < 0.0f || !(noiseOptions & EXTINCTION_NOISE))
            {
                extinctionNoise = 1.0f;
            }

            extinctionNoiseSum += extinctionNoise;

            const float4 lightBRDF = exp(
                -extinctionCoefficient
                * extinctionNoise
                * (distanceToLight + equiangularDistance)
            );

            scatteredColour += scatteringCoefficient * scatteringNoise * sampleLight(
                seed * RAND_CONST_7 / step,
                throughput,
                lightBRDF,
                distanceToLight,
                lightDirection,
                particlePosition,
                lightDirection,
                equiangularPDF,
                lightPDF,
                selectedLight,
                numEmissive,
                _sampleHDRIEquiangular,
                nestedDielectrics,
                numNestedDielectrics
            );
        }

        throughput *= exp(
            -extinctionCoefficient
            * extinctionNoiseSum
            * distanceSinceLastBounce
            / (float) _equiangularSamples
        );

        return scatteredColour;
    }


    /**
     * Handle the interaction between a ray and the surface of a material.
     *
     * @arg stepDistance: The last step size to be marched.
     * @arg pixelFootprint: A value proportional to the amount of world
     *     space that fills a pixel, like the distance from camera.
     * @arg distance: The distance travelled since the last bounce.
     * @arg intersectionPosition: The position at which the ray
     *     intersects the geometry.
     * @arg surfaceNormal: The surface normal at the intersection point.
     * @arg objectId: The ID of the object that was hit.
     * @arg emissiveIndices: The indices of the emissive objects in the
     *     scene.
     * @arg numEmissive: The number of emissive objects in the scene.
     * @arg doRefraction: Whether or not refraction is enabled on the
     *     material.
     * @arg numLights: The number of lights in the scene.
     * @arg seed: The seed to use in randomization.
     * @arg direction: The incoming ray direction.
     * @arg origin: The ray origin.
     * @arg diffusivity: The diffuse values of the surface.
     * @arg specularity: The specular values of the surface.
     * @arg transmittance: The extinction coefficient and transmissive
     *     probability of the surface.
     * @arg emittance: The emissive values of the surface.
     * @arg specularRoughness: The specular roughness of the surface.
     * @arg transmissionRoughness: The transmissive roughness of the
     *     surface.
     * @arg refractiveIndex: The refractive index of the material.
     * @arg scatteringCoefficient: The scattering coefficient of the
     *     material.
     * @arg nestedDielectrics: The stack of dielectrics that we have
     *     entered without exiting.
     * @arg numNestedDielectrics: The number of dielectrics in the
     *     stack.
     * @arg rayColour: The colour of the ray.
     * @arg throughput: The throughput of the ray.
     * @arg previousMaterialPDF: The PDF of the last material interacted
     *     with.
     * @arg usedPrecomputedIrradiance: Whether or not we have used the
     *     precomputed irradiance.
     */
    void materialInteraction(
            const float stepDistance,
            const float pixelFootprint,
            const float distance,
            const float3 &intersectionPosition,
            const float3 &surfaceNormal,
            const int objectId,
            const int emissiveIndices[MAX_MIS_EMISSIVE_SHAPES],
            const int numEmissive,
            const bool doRefraction,
            const float numLights,
            float3 &seed,
            float3 &direction,
            float3 &origin,
            float4 &diffusivity,
            float4 &specularity,
            float4 &transmittance,
            float4 &emittance,
            float &specularRoughness,
            float &transmissionRoughness,
            float &refractiveIndex,
            float4 &scatteringCoefficient,
            float nestedDielectrics[MAX_NESTED_DIELECTRICS][NESTED_DIELECTRIC_PARAMS],
            int &numNestedDielectrics,
            float4 &rayColour,
            float4 &throughput,
            float &previousMaterialPDF,
            bool &usedPrecomputedIrradiance)
    {
        // Use the noise to modify the surface properties
        noiseMaterialInteraction(
            objectId - 1,
            intersectionPosition,
            diffusivity,
            specularity,
            transmittance,
            emittance,
            specularRoughness,
            transmissionRoughness,
            refractiveIndex
        );

        // Compute the amount we would offset a point to escape the surface
        const float offset = 2.0f * pixelFootprint * _shadowBias;

        // Perform Equi-Angular Sampling
        rayColour += sampleEquiangular(
            seed,
            intersectionPosition,
            origin,
            direction,
            distance,
            emissiveIndices,
            numEmissive,
            nestedDielectrics,
            numNestedDielectrics,
            throughput
        );

        origin = intersectionPosition;

        // Get material data for material and light sampling
        float4 materialBRDF;
        float3 bounceDirection;
        float materialLightPDF;
        const float materialPDF = sampleMaterial(
            seed * RAND_CONST_8,
            surfaceNormal,
            direction,
            diffusivity,
            offset,
            transmittance,
            doRefraction,
            refractiveIndex,
            scatteringCoefficient,
            transmissionRoughness,
            specularity,
            specularRoughness,
            objectId,
            isExitingObject(
                nestedDielectrics[numNestedDielectrics][OBJECT_ID] - 1,
                objectId - 1
            ),
            materialBRDF,
            bounceDirection,
            origin,
            nestedDielectrics,
            numNestedDielectrics,
            materialLightPDF
        );

        if (
            __lightSamplingEnabled
            && materialLightPDF > 0.0f
            && numLights > 0
        ) {
            // Perform MIS light sampling
            rayColour += lightSampling(
                seed * RAND_CONST_9,
                throughput,
                materialBRDF,
                surfaceNormal,
                origin,
                materialLightPDF,
                offset,
                emissiveIndices,
                numEmissive,
                _sampleHDRI,
                nestedDielectrics,
                numNestedDielectrics
            );
        }

        if (_usePrecomputedIrradiance && materialLightPDF > 0.0f)
        {
            emittance += diffusivity * diffusivity.w * readIrradianceValue(surfaceNormal);
            usedPrecomputedIrradiance = true;
        }

        // Perform MIS material sampling
        const float radius = getRadius(objectId - 1);
        const float visibleSurfaceArea = 2.0f * PI * radius * radius;

        rayColour += multipleImportanceSample(
            emittance,
            throughput,
            previousMaterialPDF,
            sampleLightsPDF(numLights, visibleSurfaceArea)
        );

        float materialGeometryFactor = 1.0f;
        if (materialLightPDF > 0.0f)
        {
            materialGeometryFactor = saturate(dot(bounceDirection, surfaceNormal));
        }

        throughput *= materialBRDF * materialGeometryFactor / materialPDF;

        // Prepare the variables for the next march
        previousMaterialPDF = materialPDF;

        direction = bounceDirection;
    }


    /**
     * March a path through the scene.
     *
     * @arg rayOrigin: The origin of the ray.
     * @arg rayDirection: The direction of the ray.
     * @arg emissiveIndices: The indices of the emissive objects in the
     *     scene.
     * @arg numEmissive: The number of emissive objects in the scene.
     * @arg seed: The seed to use in randomization.
     *
     * @returns: The ray colour.
     */
    float4 marchPath(
            const float3 &rayOrigin,
            const float3 &rayDirection,
            const int emissiveIndices[MAX_MIS_EMISSIVE_SHAPES],
            const int numEmissive,
            float3 &seed)
    {
        const int numLights = _lightTextureWidth + numEmissive + _sampleHDRI;

        float nestedDielectrics[MAX_NESTED_DIELECTRICS][NESTED_DIELECTRIC_PARAMS];
        nestedDielectrics[0][EXTINCTION_X] = _extinctionCoefficient.x;
        nestedDielectrics[0][EXTINCTION_Y] = _extinctionCoefficient.y;
        nestedDielectrics[0][EXTINCTION_Z] = _extinctionCoefficient.z;
        nestedDielectrics[0][OBJECT_ID] = -1;
        nestedDielectrics[0][REFRACTIVE_INDEX] = _refractiveIndex;
        nestedDielectrics[0][SCATTERING_X] = _scatteringCoefficient.x;
        nestedDielectrics[0][SCATTERING_Y] = _scatteringCoefficient.y;
        nestedDielectrics[0][SCATTERING_Z] = _scatteringCoefficient.z;
        nestedDielectrics[0][DO_REFRACTION] = false;
        int numNestedDielectrics = 0;

        float4 rayColour = float4(0);
        float4 throughput = float4(1);

        float lastStepDistance = 1.0f;

        float firstObjectId = 0.0f;

        int iterations = 0;
        int bounces = 0;

        float distanceTravelled = 0;
        float distanceSinceLastBounce = distanceTravelled;

        // Get the next ray
        float3 origin = rayOrigin;
        float3 direction = rayDirection;
        float3 positionOnRay = origin;

        float4 diffusivity;
        float4 specularity;
        float4 transmittance;
        float4 emittance;

        float pixelFootprint = _hitTolerance;

        float previousMaterialPDF = 1.0f;

        bool usedPrecomputedIrradiance = false;

        // March the ray
        while (
            distanceTravelled < _maxRayDistance
            && iterations < _maxRaySteps
            && sumComponent(throughput) > _hitTolerance
            && length(rayColour) < _maxBrightness
        ) {
            positionOnRay = origin + distanceSinceLastBounce * direction;

            // Get the closest distance to an object
            bool doRefraction = true;
            float4 scatteringCoefficient = float4(0);
            float specularRoughness = 0.0f;
            float transmissionRoughness = 0.0f;
            float refractiveIndex = 1.0f;
            int objectId = 0;

            // Keep the signed distance so we know whether or not we are
            // inside the object
            const float signedStepDistance = getMinDistanceToObjectInScene(
                positionOnRay,
                pixelFootprint,
                diffusivity,
                specularity,
                transmittance,
                emittance,
                scatteringCoefficient,
                specularRoughness,
                transmissionRoughness,
                refractiveIndex,
                doRefraction,
                objectId
            );

            // Get the absolute value, the true shortest distance to a
            // surface
            const float stepDistance = fabs(signedStepDistance);

            // Keep track of the distance the ray has travelled
            distanceTravelled += stepDistance;
            distanceSinceLastBounce += stepDistance;

            // Have we hit the nearest object?
            if (stepDistance < pixelFootprint)
            {
                float3 intersectionPosition = positionOnRay + stepDistance * direction;

                // The normal to the surface at that position
                float3 surfaceNormal = sign(lastStepDistance) * estimateSurfaceNormal(
                    intersectionPosition,
                    pixelFootprint
                );

                if (bounces == 0)
                {
                    // Keep the ID of the first object hit, so we can
                    // store it in the alpha channel
                    firstObjectId = objectId;

                    // Early exit for the various AOVs that are not 'beauty'
                    if (_outputType > BEAUTY_AOV && _outputType < STATS_AOV)
                    {
                        return earlyExitAOVs(
                            _outputType,
                            intersectionPosition,
                            worldToLocal(firstObjectId - 1, intersectionPosition),
                            surfaceNormal,
                            fabs(matmul(
                                _cameraWorldMatrix.invert(),
                                float4(
                                    intersectionPosition.x,
                                    intersectionPosition.y,
                                    intersectionPosition.z,
                                    1.0f
                                )
                            )[2]),
                            firstObjectId
                        );
                    }
                }

                materialInteraction(
                    stepDistance,
                    pixelFootprint,
                    distanceSinceLastBounce,
                    intersectionPosition,
                    surfaceNormal,
                    objectId,
                    emissiveIndices,
                    numEmissive,
                    doRefraction,
                    numLights,
                    seed,
                    direction,
                    origin,
                    diffusivity,
                    specularity,
                    transmittance,
                    emittance,
                    specularRoughness,
                    transmissionRoughness,
                    refractiveIndex,
                    scatteringCoefficient,
                    nestedDielectrics,
                    numNestedDielectrics,
                    rayColour,
                    throughput,
                    previousMaterialPDF,
                    usedPrecomputedIrradiance
                );

                // Exit if we have reached the bounce limit
                // or with a random chance
                const float rng = random(random(seed.x) + random(seed.y + random(seed.z)));
                const float exitProbability = max(
                    throughput.x,
                    throughput.y,
                    throughput.z
                );
                if (
                    ++bounces > __bouncesPerRay
                    || emittance.w >= 1.0f
                    || usedPrecomputedIrradiance
                    || (_roulette && exitProbability <= rng)
                ) {
                    return finalAOVs(
                        _outputType,
                        iterations,
                        bounces,
                        firstObjectId,
                        rayColour
                    );
                }
                if (_roulette)
                {
                    // Account for the lost intensity from the early exits
                    throughput /= exitProbability;
                }

                // Update the random seed
                seed = RAND_CONST_12 * random(
                    seed
                    + rng
                    + random(fabs(intersectionPosition + direction))
                );

                distanceSinceLastBounce = 0.0f;

                // Reset the pixel footprint so multiple reflections don't
                // reduce precision
                pixelFootprint = _hitTolerance;
            }
            else if (_levelOfDetail)
            {
                pixelFootprint += _hitTolerance * stepDistance;
            }

            lastStepDistance = signedStepDistance;
            iterations++;
        }

        // If we are not computing the scene value and we have missed all
        // objects, return an appropriate colour.
        if (_outputType > BEAUTY_AOV)
        {
            return rayMissAOVs(
                _outputType,
                iterations,
                bounces,
                firstObjectId
            );
        }

        const float correctedDistance = (
            distanceSinceLastBounce
            + _maxRayDistance
            - distanceTravelled
        );

        // Perform Equi-Angular Sampling
        rayColour += sampleEquiangular(
            seed,
            origin + correctedDistance * direction,
            origin,
            direction,
            correctedDistance,
            emissiveIndices,
            numEmissive,
            nestedDielectrics,
            numNestedDielectrics,
            throughput
        );

        // Read the hdri value in the direction the ray was last travelling
        rayColour += throughput * readHDRIValue(direction);

        rayColour.w = (bounces > 0) * firstObjectId;
        return rayColour;
    }


    /**
     * Get the indices of all the emissive objects in the scene.
     *
     * @arg emissiveIndices: The array to store the indices in.
     *
     * @returns: The total number of emissive objects found.
     */
    int getEmissiveIndices(int emissiveIndices[MAX_MIS_EMISSIVE_SHAPES])
    {
        int currentIndex = 0;
        for (int j=0; j < min(_objectTextureWidth, MAX_MIS_EMISSIVE_SHAPES); j++)
        {
            if (emittances(j, 0, 3) > 0.0f)
            {
                emissiveIndices[currentIndex++] = j;
            }
        }

        return currentIndex;
    }


    /**
     * Create a ray out of the camera. It will be either a standard ray,
     * a latlong ray, or a ray that will result in depth of field.
     *
     * @arg seed: The seed to use in randomization.
     * @arg pixelLocation: The x, and y locations of the pixel.
     * @arg rayOrigin: The location to store the origin of the new ray.
     * @arg rayDirection: The location to store the direction of the new
     *     ray.
     */
    void getCameraRay(
            const float3 &seed,
            const float2 &pixelLocation,
            float3 &rayOrigin,
            float3 &rayDirection)
    {
        const float2 uvCoordinates = pixelsToUV(
            pixelLocation + random(float2(seed.x, seed.y)),
            float2(_formatWidth, _formatHeight)
        );
        if (_latLong)
        {
            createLatLongCameraRay(
                _cameraWorldMatrix,
                uvCoordinates,
                rayOrigin,
                rayDirection
            );
        }
        else if (_depthOfFieldEnabled)
        {
            createCameraRay(
                _cameraWorldMatrix,
                __inverseCameraProjectionMatrix,
                uvCoordinates,
                __aperture,
                _focalDistance,
                seed,
                rayOrigin,
                rayDirection
            );
        }
        else
        {
            createCameraRay(
                _cameraWorldMatrix,
                __inverseCameraProjectionMatrix,
                uvCoordinates,
                rayOrigin,
                rayDirection
            );
        }
    }


    /**
     * Compute a raymarched pixel value.
     *
     * @arg pos: The x, and y location we are currently processing.
     */
    void process(int2 pos)
    {
        SampleType(noise) noisePixel = noise();
        float3 seed = random(float3(noisePixel.x, noisePixel.y, noisePixel.z));

        const float4 variancePixel = variance();

        const float numPaths = adaptiveSamples(
            _minPathsPerPixel,
            _maxPathsPerPixel,
            float3(variancePixel.x, variancePixel.y, variancePixel.z)
        );
        const float numPrecomputedPaths = variancePixel.w;
        const float totalPaths = numPaths + numPrecomputedPaths;

        float4 resultPixel = float4(0);

        float2 pixelLocation = float2(pos.x, pos.y);

        int emissiveMISOptions[MAX_MIS_EMISSIVE_SHAPES];

        const int numEmissive = getEmissiveIndices(emissiveMISOptions);

        for (int path=1; path <= numPaths; path++)
        {
            // Generate a ray from the camera
            float3 rayOrigin;
            float3 rayDirection;
            getCameraRay(
                seed,
                pixelLocation,
                rayOrigin,
                rayDirection
            );

            // Determine the colour of the ray
            resultPixel += marchPath(
                rayOrigin,
                rayDirection,
                emissiveMISOptions,
                numEmissive,
                seed
            ) / totalPaths;

            seed = RAND_CONST_10 * random(seed * path * RAND_CONST_11);
        }

        const uint objectId = resultPixel.w / totalPaths;

        dst() = resultPixel + numPrecomputedPaths * src() / totalPaths;

        if (_outputType == STATS_AOV)
        {
            dst(2) = totalPaths;
        }

        dst(3) = encodeTwoValuesInUint(objectId, totalPaths);
    }
};
