// Copyright 2022 by Owen Bulka.
// All rights reserved.
// This file is released under the "MIT License Agreement".
// Please see the LICENSE.md file that should have been included as part
// of this package.

//
// BlinkScript Ray Marcher
//

#include "camera.h"
#include "conversion.h"
#include "lights.h"
#include "math.h"
#include "colour.h"
#include "objectInteraction.h"
#include "random.h"
#include "rays.h"
#include "sdfModifications.h"
#include "sdfs.h"


#define MAX_CHILD_DEPTH 100


kernel PathMarchKernel : ImageComputationKernel<ePixelWise>
{
    // the input which specifies the format, process is called once per pixel
    // in this image, which also provides random seeds
    Image<eRead, eAccessPoint, eEdgeNone> noise;

    // the hdribox in latlong format
    Image<eRead, eAccessRandom, eEdgeClamped> hdri;


    // the shape positons.xyz, scale.w
    Image<eRead, eAccessRandom, eEdgeNone> positions;

    // the shape rotations.xyz, wall thickness.w
    Image<eRead, eAccessRandom, eEdgeNone> rotations;

    // the shape dimensions.xyzw (some shapes may not use all channels)
    Image<eRead, eAccessRandom, eEdgeNone> dimensions;

    // the shape diffusivities.xyz, refractive index.w
    Image<eRead, eAccessRandom, eEdgeNone> diffusivities;

    Image<eRead, eAccessRandom, eEdgeNone> specularities;

    Image<eRead, eAccessRandom, eEdgeNone> transmittances;

    Image<eRead, eAccessRandom, eEdgeNone> emittances;


    // shape type.x, operation.y, numChildren.z, blend strength.w
    Image<eRead, eAccessRandom, eEdgeNone> shapeProperties;

    // repetition params.xyzw
    Image<eRead, eAccessRandom, eEdgeNone> shapeModParameters0;

    // elongation.xyz edgeRadius.w
    Image<eRead, eAccessRandom, eEdgeNone> shapeModParameters1;

    // reflection.x, transmission.y, emission.z, roughness.w
    Image<eRead, eAccessRandom, eEdgeNone> surfaceProperties;


    // the output image
    Image<eWrite> dst;


    param:
        // These parameters are made available to the user.

        // Camera params
        float _focalLength;
        float _horizontalAperture;
        float _nearPlane;
        float _farPlane;
        float4x4 _cameraWorldMatrix;

        // Image params
        float _formatWidth;
        float _formatHeight;

        float _hdriOffsetAngle;

        // Ray params
        int _subdivisions;
        int _pathsPerSubpixel;
        int _maxBounces;
        float _maxRayDistance;
        int _maxRaySteps;
        float _hitTolerance;
        float _shadowBias;

        // Scene params
        float _refractiveIndex;

        // Shape Textures
        int _objectTextureWidth;

        int _outputType;
        bool _useToneMap;
        float _exposure;


    local:
        // These local variables are not exposed to the user.

        float4x4 __inverseCameraProjectionMatrix;

        int __bouncesPerRay;

        int __numSubPixels;
        float __subdividedPixelSize;

        float2 __hdriPixelSize;
        float2 __hdriLightPixelSize;
        float __hdriOffsetRadians;

        float3 __offset0;
        float3 __offset1;
        float3 __offset2;
        float3 __offset3;


    /**
     * In define(), parameters can be given labels and default values.
     */
    void define()
    {
        // Camera params
        defineParam(_focalLength, "Focal Length", 50.0f);
        defineParam(_horizontalAperture, "Horizontal Aperture", 24.576f);
        defineParam(_nearPlane, "Near Plane", 0.1f);
        defineParam(_farPlane, "Far Plane", 10000.0f);
        defineParam(
            _cameraWorldMatrix,
            "Camera World Matrix",
            float4x4(
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            )
        );

        // Image params
        defineParam(_formatHeight, "Screen Height", 2160.0f);
        defineParam(_formatWidth, "Screen Width", 3840.0f);
        defineParam(_hdriOffsetAngle, "HDRI Offset Angle", 0.0f);

        // Ray params
        defineParam(_subdivisions, "Pixel Subdivisions", 0);
        defineParam(_pathsPerSubpixel, "Paths Per Subpixel", 1);
        defineParam(_maxRayDistance, "Max Ray Distance", 1000.0f);
        defineParam(_maxRaySteps, "Max Ray Steps", 128);
        defineParam(_maxBounces, "Max Bounces", 1);
        defineParam(_hitTolerance, "Hit Tolerance", 0.001f);
        defineParam(_shadowBias, "Shadow Bias", 1.0f);

        // Scene params
        defineParam(_refractiveIndex, "Index of Refraction", 1.0f);

        // Shape Counts
        defineParam(_objectTextureWidth, "Object Texture Width", 0);

        defineParam(_outputType, "Output Type", 0);
        defineParam(_useToneMap, "Use Tone Map", true);
        defineParam(_exposure, "Exposure", 1.0f);
    }


    /**
     * The init() function is run before any calls to process().
     * Local variables can be initialized here.
     */
    void init()
    {
        __bouncesPerRay = _maxBounces <= 0 ? 1 : _maxBounces;

        // TODO use angles to allow -ve focal length like for latlongs
        float aspect = aspectRatio(_formatHeight, _formatWidth);
        float4x4 cameraProjectionMatrix = projectionMatrix(
            _focalLength,
            _horizontalAperture,
            aspect,
            _nearPlane,
            _farPlane
        );
        __inverseCameraProjectionMatrix = cameraProjectionMatrix.invert();

        int subPixelDivisions = pow(2, abs(_subdivisions));
        __subdividedPixelSize = 1.0f / (float) subPixelDivisions;
        __numSubPixels = pow(subPixelDivisions, 2);

        __hdriPixelSize = float2(
            hdri.bounds.width() / (2 * PI),
            hdri.bounds.height() / PI
        );
        __hdriOffsetRadians = _hdriOffsetAngle * PI / 180.0f;

        __offset0 = 0.5773f * float3(1, -1, -1);
        __offset1 = 0.5773f * float3(-1, -1, 1);
        __offset2 = 0.5773f * float3(-1, 1, -1);
        __offset3 = 0.5773f * float3(1, 1, 1);
    }


    /**
     * Get the value of hdri the ray would hit at infinite distance
     *
     * @arg rayDirection: The direction of the ray.
     *
     * @returns: The colour of the pixel in the direction of the ray.
     */
    float4 readHDRIValue(float3 rayDirection)
    {
        const float2 angles = cartesionUnitVectorToSpherical(rayDirection, __hdriOffsetRadians);

        // Should be able to say image access is eEdgeClamped and not do this
        // but I see nan pixels sooo... :(
        const float2 indices = clamp(
            float2(
                __hdriPixelSize.x * angles.x,
                hdri.bounds.height() - (__hdriPixelSize.y * angles.y)
            ),
            float2(0),
            float2(hdri.bounds.width(), hdri.bounds.height()) - 1.0f
        );

        return bilinear(hdri, indices.x, indices.y);
    }


    //
    // Render Engine
    //


    /**
     * Transform a ray's location.
     *
     * @arg rayOrigin: The location the ray originates from.
     * @arg position: The amount to translate the ray.
     * @arg rotation: The amount to rotate the ray (radians).
     * @arg modifications: The modifications to perform.
     *     Each bit will enable a modification:
     *         bit 0: finite repetition
     *         bit 1: infinite repetition
     *         bit 2: elongation
     *         bit 3: mirror x
     *         bit 4: mirror y
     *         bit 5: mirror z
     * @arg repetition: The values to use when repeating the ray.
     * @arg elongation: The values to use when elongating the ray.
     *
     * @returns: The transformed ray origin.
     */
    float3 transformRay(
        const float3 &rayOrigin,
        const float3 &translation,
        const float3 &rotation,
        const int modifications,
        const float4 &repetition,
        const float4 &elongation)
    {
        float3x3 rotMatrix;
        float3 transformedRay;
        rotationMatrix(rotation, rotMatrix);
        matmul(
            rotMatrix.invert(),
            rayOrigin - translation,
            transformedRay
        );
        performShapeModification(
            modifications,
            repetition,
            elongation,
            transformedRay
        );

        return transformedRay;
    }


    /**
     * Compute the modified distance to an object.
     *
     * @arg rayOrigin: The location the ray originates from.
     * @arg shape: The shape of the object:
     *     0: sphere
     *     1: ellipsoid
     *     2: cut sphere
     *     3: hollow sphere
     *     4: death star
     *     5: solid angle
     *     6: rectangular prism
     *     7: rectangular prism frame
     *     8: rhombus
     *     9: triangular prism
     *     10: cylinder
     *     11: infinite cylinder
     *     12: plane
     *     13: capsule
     *     14: cone
     *     15: infinite cone
     *     16: capped cone
     *     17: rounded cone
     *     18: torus
     *     19: capped torus
     *     20: link
     *     21: hexagonal prism
     *     22: octahedron
     *     23: mandelbulb
     *     24: mandelbox
     *     25: mandelbox (no trap colour)
     * @arg dimensions: The dimensions of the object.
     * @arg uniformScale: The factor to scale the object by.
     * @arg modifications: The modifications to perform.
     *     Each bit will enable a modification:
     *         bit 6: hollowing
     * @arg edgeRadius: The radius to round the edges by.
     * @arg wallThickness: The thickness of the walls if hollowing the
     *     object.
     * @arg colour: The colour of the surface will be stored here.
     *     This will only be modified by the fractals (23-25).
     *
     * @returns: The distance to the modified object.
     */
    inline float getModifiedDistance(
        const float3 &rayOrigin,
        const int shape,
        const float4 &dimensions,
        const float uniformScale,
        const int modifications,
        const float edgeRadius,
        const float wallThickness,
        float4 &colour)
    {
        float nextDistance = distanceToObject(
            rayOrigin / uniformScale,
            shape,
            dimensions,
            colour
        ) * uniformScale;

        return performDistanceModification(
            modifications,
            edgeRadius,
            wallThickness,
            nextDistance
        );
    }


    /**
     * Compute the minimum distance to an object in the scene
     *
     * @arg rayOrigin: The origin position of the ray.
     * @arg pixelFootprint: A value proportional to the amount of world
     *     space that fills a pixel, like the distance from camera.
     *
     * @returns: The minimum distance to an object in the scene.
     */
    float getMinDistanceToObjectInScene(const float3 &rayOrigin, const float pixelFootprint)
    {
        float distance = _maxRayDistance;

        // numChildren, transformedRay, scale, mods, nextDistance, diffuse colour
        // roughness, specular colour, specular, transmissive colour, transmission,
        // emissive colour, emission, refractive index, objectId, blendStrength
        float parentStack[MAX_CHILD_DEPTH][
            1   // numChildren
            + 3 // transformedRay
            + 1 // scale
            + 1 // mods
            + 1 // nextDistance
            + 1 // blendStrength
        ];
        int parentStackLength = 0;

        for (int j=0; j < _objectTextureWidth; j++)
        {
            // Read in the shape properties
            SampleType(positions) position = positions(j, 0);
            SampleType(rotations) rotation = rotations(j, 0);
            SampleType(dimensions) dimension = dimensions(j, 0);
            SampleType(shapeProperties) shapeProperty = shapeProperties(j, 0);
            SampleType(shapeModParameters0) modParameters0 = shapeModParameters0(j, 0);
            SampleType(shapeModParameters1) modParameters1 = shapeModParameters1(j, 0);

            float scale = position.w;

            const int modifications = (int) shapeProperty.y;
            float numChildren = shapeProperty.z;
            const float blendStrength = shapeProperty.w;

            int stackLastIndex = parentStackLength - 1;

            // Position relative to the parent if we have any
            float3 parentTransformedRay = rayOrigin;
            if (parentStackLength > 0)
            {
                parentTransformedRay.x = parentStack[stackLastIndex][1];
                parentTransformedRay.y = parentStack[stackLastIndex][2];
                parentTransformedRay.z = parentStack[stackLastIndex][3];
                scale *= parentStack[stackLastIndex][4];
            }

            // Use parent transform to position child
            const float3 transformedRay = transformRay(
                parentTransformedRay,
                float3(position.x, position.y, position.z),
                float3(rotation.x, rotation.y, rotation.z),
                modifications,
                modParameters0,
                modParameters1
            );

            float4 tmp;
            // Get distance to this child
            float nextDistance = getModifiedDistance(
                transformedRay,
                (int) shapeProperty.x,
                dimension,
                scale,
                modifications,
                modParameters1.w,
                rotation.w,
                tmp
            );

            // Track which object was hit for the alpha channel
            float objectId = (float) j + 1.0f;

            // If this is a bounding volume, we can skip its children
            // if we aren't close to, or inside it
            if (
                modifications & 4096
                && numChildren > 0
                && nextDistance > _hitTolerance + pixelFootprint
            ) {
                // Update the min distance if this bounding volume is closest.
                // Otherwise we could step through it, or if every object in
                // the scene is inside it, we would not step forward at all
                if (fabs(nextDistance) < fabs(distance))
                {
                    distance = nextDistance;
                }

                // This was tagged as a boundary object, skip its children
                // since we arent close to hitting it
                j += numChildren;

                for (int parentIndex=stackLastIndex; parentIndex >= 0; parentIndex--)
                {
                    parentStack[parentIndex][0] -= numChildren + 1.0f;
                }

                // If there are no parents, or still children of the parent
                // we do not need to compute anything further for this loop
                if (parentStackLength <= 0 || parentStack[stackLastIndex][0] > 0.0f)
                {
                    continue;
                }

                // pop stack
                // we know that there will be no more children if we did not continue
                numChildren = 0.0f;
                nextDistance = parentStack[stackLastIndex][6];
                stackLastIndex--;
                parentStackLength--;
            }

            if (numChildren <= 0.0f)
            {
                // No Children left, compute interactions with parent
                if (parentStackLength > 0)
                {
                    // Process this object, along with all parents that do not
                    // have any more children, removing them from the stack,
                    // but descend all the way down the stack, without removing
                    // the objects that still have children
                    for (int stackIndex=stackLastIndex; stackIndex >= 0; stackIndex--)
                    {
                        const int parentModifications = (int) parentStack[stackIndex][5];

                        // Do not need to interact with bounding volumes.
                        // They are in the stack for relative positioning
                        // if they weren't then we would have to manually move
                        // the bounding box to follow the children
                        if (!(parentModifications & 4096))
                        {
                            const float parentNextDistance = parentStack[stackIndex][6];
                            const float parentBlendStrength = parentStack[stackIndex][7];

                            // Compute interaction between parent and this child
                            nextDistance = performChildInteraction(
                                parentModifications,
                                parentNextDistance,
                                nextDistance,
                                parentBlendStrength
                            );
                        }

                        // Update the global min distance (and surface/colour)
                        if (fabs(nextDistance) < fabs(distance))
                        {
                            distance = nextDistance;
                        }
                    }

                    do
                    {
                        // Decrement the number of children each parent has
                        for (int parentIndex=stackLastIndex; parentIndex >= 0; parentIndex--)
                        {
                            parentStack[parentIndex][0] -= 1.0f;
                        }

                        // Get the number of children still remaining for the parent
                        // If there are still children, we can break out of this loop
                        // to process the rest of them before the parent itself
                        numChildren = parentStack[stackLastIndex][0];
                    }
                    while (numChildren <= 0.0f && --stackLastIndex >= 0);

                    parentStackLength = stackLastIndex + 1;
                }
                // No parents to interact with, simply check the distance
                else if (fabs(nextDistance) < fabs(distance))
                {
                    distance = nextDistance;
                }
            }
            else
            {
                // Node has Children, push it to the stack for later
                // processing when we have all its children
                // parentStack.push()
                // TODO not all this needs to be in the stack (maybe)
                parentStack[parentStackLength][0] = numChildren;
                parentStack[parentStackLength][1] = transformedRay.x;
                parentStack[parentStackLength][2] = transformedRay.y;
                parentStack[parentStackLength][3] = transformedRay.z;
                parentStack[parentStackLength][4] = scale;
                parentStack[parentStackLength][5] = (float) modifications;
                parentStack[parentStackLength][6] = nextDistance;
                parentStack[parentStackLength][7] = blendStrength;
                parentStackLength++;
            }
        }

        return distance;
    }


    /**
     * Compute the minimum distance to an object in the scene
     *
     * @arg rayOrigin: The origin position of the ray.
     * @arg pixelFootprint: A value proportional to the amount of world
     *     space that fills a pixel, like the distance from camera.
     * @arg colour: Location to store the colour of the hit object.
     * @arg surface: Location to store the surface properties of the hit
     *     object.
     *
     * @returns: The minimum distance to an object in the scene, and the
     *     unique identifier of the object.
     */
    float2 getMinDistanceToObjectInScene(
            const float3 &rayOrigin,
            const float pixelFootprint,
            float4 &diffusivity,
            float4 &specularity,
            float4 &transmittance,
            float4 &emittance,
            float4 &surface)
    {
        float distance = _maxRayDistance;
        float id = 0.0f;

        // numChildren, transformedRay, scale, mods, nextDistance, diffuse colour
        // roughness, specular colour, specular, transmissive colour, transmission,
        // emissive colour, emission, refractive index, objectId, blendStrength
        float parentStack[MAX_CHILD_DEPTH][
            1   // numChildren
            + 3 // transformedRay
            + 1 // scale
            + 1 // mods
            + 1 // nextDistance
            + 3 // diffuse colour
            + 1 // roughness
            + 3 // specular colour
            + 1 // specular
            + 3 // transmissive colour
            + 1 // transmission
            + 3 // emissive colour
            + 1 // emission
            + 3 // unused for now
            + 1 // refractive index
            + 1 // objectId
            + 1 // blendStrength
        ];
        int parentStackLength = 0;

        for (int j=0; j < _objectTextureWidth; j++)
        {
            // Read in the shape properties
            SampleType(positions) position = positions(j, 0);
            SampleType(rotations) rotation = rotations(j, 0);
            SampleType(dimensions) dimension = dimensions(j, 0);
            SampleType(shapeProperties) shapeProperty = shapeProperties(j, 0);
            SampleType(shapeModParameters0) modParameters0 = shapeModParameters0(j, 0);
            SampleType(shapeModParameters1) modParameters1 = shapeModParameters1(j, 0);
            SampleType(diffusivities) diffuseColour = diffusivities(j, 0);
            SampleType(specularities) specularColour = specularities(j, 0);
            SampleType(transmittances) transmissiveColour = transmittances(j, 0);
            SampleType(emittances) emissiveColour = emittances(j, 0);
            SampleType(surfaceProperties) surfaceProperty = surfaceProperties(j, 0);

            const int modifications = (int) shapeProperty.y;
            float scale = position.w;

            const float blendStrength = shapeProperty.w;
            float numChildren = shapeProperty.z;

            int stackLastIndex = parentStackLength - 1;

            float4 blendedDiffuseColour = diffuseColour;
            float4 blendedSpecularColour = specularColour;
            float4 blendedTransmissiveColour = transmissiveColour;
            float4 blendedEmissiveColour = emissiveColour;
            float4 blendedSurface = surfaceProperty;

            // Position relative to the parent if we have any
            float3 parentTransformedRay = rayOrigin;
            if (parentStackLength > 0)
            {
                parentTransformedRay.x = parentStack[stackLastIndex][1];
                parentTransformedRay.y = parentStack[stackLastIndex][2];
                parentTransformedRay.z = parentStack[stackLastIndex][3];
                scale *= parentStack[stackLastIndex][4];
            }

            // Use parent transform to position child
            const float3 transformedRay = transformRay(
                parentTransformedRay,
                float3(position.x, position.y, position.z),
                float3(rotation.x, rotation.y, rotation.z),
                modifications,
                modParameters0,
                modParameters1
            );

            // Get distance to this child
            float nextDistance = getModifiedDistance(
                transformedRay,
                (int) shapeProperty.x,
                dimension,
                scale,
                modifications,
                modParameters1.w,
                rotation.w,
                blendedDiffuseColour
            );

            // Track which object was hit for the alpha channel
            float objectId = (float) j + 1.0f;

            // If this is a bounding volume, we can skip its children
            // if we aren't close to, or inside it
            if (
                modifications & 4096
                && numChildren > 0
                && nextDistance > _hitTolerance + pixelFootprint
            ) {
                // Update the min distance if this bounding volume is closest.
                // Otherwise we could step through it, or if every object in
                // the scene is inside it, we would not step forward at all
                if (fabs(nextDistance) < fabs(distance))
                {
                    distance = nextDistance;

                    diffusivity = blendedDiffuseColour;
                    specularity = blendedSpecularColour;
                    transmittance = blendedTransmissiveColour;
                    emittance = blendedEmissiveColour;

                    surface = blendedSurface;

                    id = objectId;
                }

                // This was tagged as a boundary object, skip its children
                // since we arent close to hitting it
                j += numChildren;

                for (int parentIndex=stackLastIndex; parentIndex >= 0; parentIndex--)
                {
                    parentStack[parentIndex][0] -= numChildren + 1.0f;
                }

                // If there are no parents, or still children of the parent
                // we do not need to compute anything further for this loop
                if (parentStackLength <= 0 || parentStack[stackLastIndex][0] > 0.0f)
                {
                    continue;
                }

                // pop stack
                // we know that there will be no more children if we did not continue
                numChildren = 0.0f;
                nextDistance = parentStack[stackLastIndex][6];
                blendedDiffuseColour = float4(
                    parentStack[stackLastIndex][7],
                    parentStack[stackLastIndex][8],
                    parentStack[stackLastIndex][9],
                    parentStack[stackLastIndex][10]
                );
                blendedSurface = float4(
                    parentStack[stackLastIndex][11],
                    parentStack[stackLastIndex][12],
                    parentStack[stackLastIndex][13],
                    parentStack[stackLastIndex][14]
                );
                objectId = parentStack[stackLastIndex][15];
                stackLastIndex--;
                parentStackLength--;
            }

            if (numChildren <= 0.0f)
            {
                // No Children left, compute interactions with parent
                if (parentStackLength > 0)
                {
                    // Process this object, along with all parents that do not
                    // have any more children, removing them from the stack,
                    // but descend all the way down the stack, without removing
                    // the objects that still have children
                    for (int stackIndex=stackLastIndex; stackIndex >= 0; stackIndex--)
                    {
                        const int parentModifications = (int) parentStack[stackIndex][5];

                        // Do not need to interact with bounding volumes.
                        // They are in the stack for relative positioning
                        // if they weren't then we would have to manually move
                        // the bounding box to follow the children
                        if (!(parentModifications & 4096))
                        {
                            const float parentNextDistance = parentStack[stackIndex][6];
                            const float4 parentDiffuseColour = float4(
                                parentStack[stackIndex][7],
                                parentStack[stackIndex][8],
                                parentStack[stackIndex][9],
                                parentStack[stackIndex][10]
                            );
                            const float4 parentSpecularColour = float4(
                                parentStack[stackIndex][11],
                                parentStack[stackIndex][12],
                                parentStack[stackIndex][13],
                                parentStack[stackIndex][14]
                            );
                            const float4 parentTransmissiveColour = float4(
                                parentStack[stackIndex][15],
                                parentStack[stackIndex][16],
                                parentStack[stackIndex][17],
                                parentStack[stackIndex][18]
                            );
                            const float4 parentEmissiveColour = float4(
                                parentStack[stackIndex][19],
                                parentStack[stackIndex][20],
                                parentStack[stackIndex][21],
                                parentStack[stackIndex][22]
                            );
                            const float4 parentSurfaceProperty = float4(
                                parentStack[stackIndex][23],
                                parentStack[stackIndex][24],
                                parentStack[stackIndex][25],
                                parentStack[stackIndex][26]
                            );
                            if (fabs(nextDistance) > fabs(parentNextDistance))
                            {
                                objectId = parentStack[stackIndex][27];
                            }
                            const float parentBlendStrength = parentStack[stackIndex][28];

                            // Compute interaction between parent and this child
                            nextDistance = performChildInteraction(
                                parentModifications,
                                parentNextDistance,
                                nextDistance,
                                parentDiffuseColour,
                                blendedDiffuseColour,
                                parentSpecularColour,
                                blendedSpecularColour,
                                parentTransmissiveColour,
                                blendedTransmissiveColour,
                                parentEmissiveColour,
                                blendedEmissiveColour,
                                parentSurfaceProperty,
                                blendedSurface,
                                parentBlendStrength
                            );
                        }

                        // Update the global min distance (and surface/colour)
                        if (fabs(nextDistance) < fabs(distance))
                        {
                            distance = nextDistance;

                            diffusivity = blendedDiffuseColour;
                            specularity = blendedSpecularColour;
                            transmittance = blendedTransmissiveColour;
                            emittance = blendedEmissiveColour;

                            surface = blendedSurface;

                            id = objectId;
                        }
                    }

                    do
                    {
                        // Decrement the number of children each parent has
                        for (int parentIndex=stackLastIndex; parentIndex >= 0; parentIndex--)
                        {
                            parentStack[parentIndex][0] -= 1.0f;
                        }

                        // Get the number of children still remaining for the parent
                        // If there are still children, we can break out of this loop
                        // to process the rest of them before the parent itself
                        numChildren = parentStack[stackLastIndex][0];
                    }
                    while (numChildren <= 0.0f && --stackLastIndex >= 0);

                    parentStackLength = stackLastIndex + 1;
                }
                // No parents to interact with, simply check the distance
                else if (fabs(nextDistance) < fabs(distance))
                {
                    distance = nextDistance;

                    diffusivity = blendedDiffuseColour;
                    specularity = blendedSpecularColour;
                    transmittance = blendedTransmissiveColour;
                    emittance = blendedEmissiveColour;

                    surface = blendedSurface;

                    id = objectId;
                }
            }
            else
            {
                // Node has Children, push it to the stack for later
                // processing when we have all its children
                // parentStack.push()
                // TODO not all this needs to be in the stack (maybe)
                parentStack[parentStackLength][0] = numChildren;
                parentStack[parentStackLength][1] = transformedRay.x;
                parentStack[parentStackLength][2] = transformedRay.y;
                parentStack[parentStackLength][3] = transformedRay.z;
                parentStack[parentStackLength][4] = scale;
                parentStack[parentStackLength][5] = (float) modifications;
                parentStack[parentStackLength][6] = nextDistance;
                parentStack[parentStackLength][7] = blendedDiffuseColour.x;
                parentStack[parentStackLength][8] = blendedDiffuseColour.y;
                parentStack[parentStackLength][9] = blendedDiffuseColour.z;
                parentStack[parentStackLength][10] = blendedDiffuseColour.w;
                parentStack[parentStackLength][11] = blendedSpecularColour.x;
                parentStack[parentStackLength][12] = blendedSpecularColour.y;
                parentStack[parentStackLength][13] = blendedSpecularColour.z;
                parentStack[parentStackLength][14] = blendedSpecularColour.w;
                parentStack[parentStackLength][15] = blendedTransmissiveColour.x;
                parentStack[parentStackLength][16] = blendedTransmissiveColour.y;
                parentStack[parentStackLength][17] = blendedTransmissiveColour.z;
                parentStack[parentStackLength][18] = blendedTransmissiveColour.w;
                parentStack[parentStackLength][19] = blendedEmissiveColour.x;
                parentStack[parentStackLength][20] = blendedEmissiveColour.y;
                parentStack[parentStackLength][21] = blendedEmissiveColour.z;
                parentStack[parentStackLength][22] = blendedEmissiveColour.w;
                parentStack[parentStackLength][23] = blendedSurface.x;
                parentStack[parentStackLength][24] = blendedSurface.y;
                parentStack[parentStackLength][25] = blendedSurface.z;
                parentStack[parentStackLength][26] = blendedSurface.w;
                parentStack[parentStackLength][27] = objectId;
                parentStack[parentStackLength][28] = blendStrength;
                parentStackLength++;
            }
        }

        return float2(distance, id);
    }


    /**
     * Estimate the surface normal at the closest point on the closest
     * object to a point
     *
     * @arg point: The point near which to get the surface normal
     * @arg pixelFootprint: A value proportional to the amount of world
     *     space that fills a pixel, like the distance from camera.
     *
     * @returns: The normalized surface normal.
     */
    float3 estimateSurfaceNormal(const float3 &point, const float pixelFootprint)
    {
        return normalize(
            __offset0 * getMinDistanceToObjectInScene(
                point + __offset0 * _hitTolerance,
                pixelFootprint
            )
            + __offset1 * getMinDistanceToObjectInScene(
                point + __offset1 * _hitTolerance,
                pixelFootprint
            )
            + __offset2 * getMinDistanceToObjectInScene(
                point + __offset2 * _hitTolerance,
                pixelFootprint
            )
            + __offset3 * getMinDistanceToObjectInScene(
                point + __offset3 * _hitTolerance,
                pixelFootprint
            )
        );
    }


    /**
     * March a ray through the scene.
     *
     * @arg rayOrigin: The origin of the ray.
     * @arg rayDirection: The direction of the ray.
     * @arg numBounces: The number of times a ray can be reflected and
     *     transmitted.
     * @arg rayDistance: The maximum distance a ray can travel.
     * @arg seed: A random value to use as the seed for roughness.
     *
     * @returns: The ray colour.
     */
    float4 marchRay(
            const float3 &rayOrigin,
            const float3 &rayDirection,
            const int numBounces,
            const float rayDistance,
            float3 &seed)
    {
        float4 rayColour = float4(0);
        float4 absorption = float4(1);

        float lastStepDistance = 1.0f;

        float id = 0.0f;
        float lastRefractedId = -1.0f;

        float depth = 0.0f;

        int bounces = 0;
        int iterations = 0;

        float distanceTravelled = 0;

        // Get the next ray
        float3 origin = rayOrigin;
        float3 direction = rayDirection;
        float refractiveIndex = _refractiveIndex;
        float lastRefractiveIndex = refractiveIndex;

        float4 diffusivity;
        float4 specularity;
        float4 transmittance;
        float4 emittance;
        float4 surface;

        // March the ray
        while (distanceTravelled < rayDistance && iterations < _maxRaySteps)
        {
            // TODO see if its faster to use colourless until hit
            // Get the closest distance to an object
            const float2 result = getMinDistanceToObjectInScene(
                origin,
                distanceTravelled,
                diffusivity,
                specularity,
                transmittance,
                emittance,
                surface
            );

            // Keep the signed distance so we know whether or not we are
            // inside the object
            const float signedStepDistance = result.x;

            // Get the absolute value, the true shortest distance to a
            // surface
            const float stepDistance = fabs(signedStepDistance);

            // Keep track of the distance the ray has travelled
            distanceTravelled += stepDistance;
            const float pixelFootprint = _hitTolerance * distanceTravelled;

            // Step the ray forwards
            origin += direction * stepDistance;

            // Update the random seed
            seed += fabs(origin + direction);

            // Have we hit the nearest object?
            if (stepDistance < pixelFootprint)
            {
                // The actual position on the surface we hit
                const float3 surfacePosition = origin - direction * _hitTolerance;

                // The normal to the surface at that position
                float3 surfaceNormal = sign(lastStepDistance) * estimateSurfaceNormal(
                    surfacePosition,
                    pixelFootprint
                );

                if (bounces == 0)
                {
                    // Keep the ID of the first object hit, so we can
                    // store it in the alpha channel
                    id = result.y;
                    depth = distanceTravelled;

                    // Early exit for the various AOVs that are not 'scene'
                    if (_outputType > 0)
                    {
                        if (_outputType == 1)
                        {
                            return float4(
                                surfacePosition.x,
                                surfacePosition.y,
                                surfacePosition.z,
                                encodeFloatsInUint(id, depth)
                            );
                        }
                        if (_outputType == 2)
                        {
                            return float4(
                                surfaceNormal.x,
                                surfaceNormal.y,
                                surfaceNormal.z,
                                encodeFloatsInUint(id, depth)
                            );
                        }
                        if (_outputType == 3)
                        {
                            return float4(
                                depth,
                                0,
                                0,
                                encodeFloatsInUint(id, depth)
                            );
                        }
                    }
                }

                // Update the colour of the ray
                rayColour += emittance * emittance.w * absorption;

                // Get the diffuse direction for the next ray
                const float3 diffuseDirection = roughen(
                    surfaceNormal,
                    1.0f,
                    seed
                );

                const float rng = random(seed.x + seed.y + seed.z);
                float specularProbability = specularity.w;

                float refractedRefractiveIndex;
                if (lastRefractedId == id)
                {
                    refractedRefractiveIndex = lastRefractiveIndex;
                }
                else
                {
                    refractedRefractiveIndex = surface.w;
                }

                // Compute the refraction values
                // const float reflectivity = schlickReflectionCoefficient(
                //     direction,
                //     surfaceNormal,
                //     refractiveIndex,
                //     refractedRefractiveIndex
                // );

                // specularProbability += reflectivity * (transmittance.w > 0.0f);

                // Maybe reflect the ray
                if (specularProbability > 0.0f && rng <= specularProbability)
                {
                    const float3 specularDirection = reflectRayOffSurface(
                        direction,
                        surfaceNormal
                    );

                    direction = blend(
                        diffuseDirection,
                        specularDirection,
                        diffusivity.w * diffusivity.w
                    );
                    absorption *= specularity;

                    // Offset the point so that it doesn't get trapped on
                    // surface.
                    origin = offsetPoint(
                        origin,
                        direction + surfaceNormal,
                        pixelFootprint * _shadowBias
                    );
                }
                // Maybe spawn a refracted ray
                else if (transmittance.w > 0.0f && rng - specularProbability <= transmittance.w)// + (1 - reflectivity))
                {
                    const float3 refractedDirection = refractRayThroughSurface(
                        direction,
                        surfaceNormal,
                        refractiveIndex,
                        refractedRefractiveIndex
                    );

                    direction = blend(
                        diffuseDirection,
                        refractedDirection,
                        diffusivity.w * diffusivity.w / 2.0f
                    );
                    absorption *= transmittance;

                    // Offset the point so that it doesn't get trapped on
                    // surface.
                    origin = offsetPoint(
                        surfacePosition,
                        refractedDirection - surfaceNormal,
                        (2.0f * pixelFootprint + stepDistance) * _shadowBias
                    );

                    // We are passing through the surface, so update the refractive index
                    lastRefractiveIndex = refractiveIndex;
                    refractiveIndex = refractedRefractiveIndex;
                    lastRefractedId = id;
                }
                // Otherwise diffuse the light
                else
                {
                    // fallback is diffuse
                    direction = diffuseDirection;
                    absorption *= diffusivity;

                    // Offset the point so that it doesn't get trapped on
                    // surface.
                    origin = offsetPoint(
                        origin,
                        direction + surfaceNormal,
                        pixelFootprint * _shadowBias
                    );
                }

                // Exit if we have reached the bounce limit
                if (++bounces >= numBounces)
                {
                    rayColour.w = encodeFloatsInUint(id, depth);
                    return rayColour;
                }
            }

            lastStepDistance = signedStepDistance;
            iterations++;
        }

        // If we are not computing the scene value and we have missed all
        // objects, return black.
        if (_outputType > 0)
        {
            return float4(0);
        }

        // Otherwise, read the hdri value
        // in the direction the ray was last travelling
        rayColour += absorption * readHDRIValue(direction);

        rayColour.w = (bounces > 0) * encodeFloatsInUint(id, depth);
        return rayColour;
    }


    /**
     * Compute a raymarched pixel value.
     * 
     * @arg pos: The x, and y location we are currently processing.
     */
    void process(int2 pos)
    {
        SampleType(noise) noisePixel = noise();
        float3 seed = float3(noisePixel.x, noisePixel.y, noisePixel.z);

        float4 resultPixel = float4(0);

        float2 pixelLocation = float2(pos.x, pos.y);

        float2 pixelOffset;
        for (
            pixelOffset.x = 0.0f;
            pixelOffset.x < 1.0f;
            pixelOffset.x += __subdividedPixelSize
        ) {
            for (
                pixelOffset.y = 0.0f;
                pixelOffset.y < 1.0f;
                pixelOffset.y += __subdividedPixelSize
            ) {
                for (int path=1; path <= _pathsPerSubpixel; path++)
                {
                    seed *= path;

                    // Generate a ray from the camera
                    float3 rayOrigin;
                    float3 rayDirection;
                    createCameraRay(
                        _cameraWorldMatrix,
                        __inverseCameraProjectionMatrix,
                        pixelsToUV(
                            pixelLocation
                            + pixelOffset
                            + __subdividedPixelSize * random(float2(seed.x, seed.y)),
                            float2(_formatWidth, _formatHeight)
                        ),
                        rayOrigin,
                        rayDirection
                    );

                    resultPixel += marchRay(
                        rayOrigin,
                        rayDirection,
                        __bouncesPerRay,
                        _maxRayDistance,
                        seed
                    );
                }
            }
        }

        const float4 resultColour = resultPixel / __numSubPixels / _pathsPerSubpixel;
        if (_useToneMap && _outputType == 0)
        {
            const float3 toneMapped = ACESToneMap(
                _exposure * float3(resultColour.x, resultColour.y, resultColour.z)
            );
            dst() = float4(toneMapped.x, toneMapped.y, toneMapped.z, resultColour.w);
        }
        else
        {
            dst() = float4(
                _exposure * resultColour.x,
                _exposure * resultColour.y,
                _exposure * resultColour.z,
                resultColour.w
            );
        }
    }
};
