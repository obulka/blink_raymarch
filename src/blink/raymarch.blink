#include "colour.h"
#include "mmath.h"
#include "sdfs.h"


kernel RayMarchKernel : ImageComputationKernel<ePixelWise>
{
    Image<eRead, eAccessPoint, eEdgeNone> bg; // the input for format, process called once per pixel
    Image<eRead, eAccessRandom, eEdgeNone> skyBox; // the skybox
    Image<eRead, eAccessRandom, eEdgeNone> spheres; // the input spheres positions.xyz radius.w
    Image<eRead, eAccessRandom, eEdgeNone> rectPrisms; // the input rectPrisms positions.xyz radius.w
    Image<eRead, eAccessRandom, eEdgeNone> tori; // the input tori positions.xyz radius.w
    Image<eRead, eAccessRandom, eEdgeNone> triangularPrisms; // the input triangularPrisms positions.xyz radius.w
    Image<eRead, eAccessRandom, eEdgeNone> cylinders; // the input cylinders positions.xyz radius.w
    Image<eRead, eAccessRandom, eEdgeNone> directionalLights; // the input directional lights direction.xyz intensity.w
    Image<eRead, eAccessRandom, eEdgeNone> pointLights; // the input point lights positions.xyz intensity.w

    Image<eWrite> dst; // the output image

    param:
        // These parameters are made available to the user.

        // Camera params
        float focalLength;
        float horizontalAperture;
        float nearPlane;
        float farPlane;
        float4x4 cameraWorldMatrix;

        // Image params
        float formatWidth;
        float formatHeight;

        float skyBoxOffsetAngle;
        int skyFormatWidth;
        int skyFormatHeight;

        // Ray params
        int subdivisions;
        int maxBounces;
        float maxRayDistance;
        float hitTolerance;

        // Shader params
        float shadowBias;
        int raysPerPixel;
        float rayOffset;

        // Scene params
        // Shape Textures
        int spheresTextureWidth;
        int spheresTextureHeight;
        int rectPrismsTextureWidth;
        int rectPrismsTextureHeight;
        int toriTextureHeight;
        int toriTextureWidth;
        int triangularPrismsTextureHeight;
        int triangularPrismsTextureWidth;
        int cylindersTextureHeight;
        int cylindersTextureWidth;

        // Light textures
        int pointLightTextureHeight;
        int pointLightTextureWidth;
        int directionalLightTextureHeight;
        int directionalLightTextureWidth;

    local:
        // These local variables are not exposed to the user.

        float fieldOfView;
        float4x4 cameraProjectionMatrix;
        float4x4 inverseCameraProjectionMatrix;
        float3 cameraPosition;
        float aspect;

        int numSubPixels;
        float subdividedPixelSize;

        float2 skyBoxPixelSize;
        float skyBoxOffsetRadians;


    // In define(), parameters can be given labels and default values.
    void define()
    {
        // Camera params
        defineParam(focalLength, "Focal Length", 50.0f);
        defineParam(horizontalAperture, "Horizontal Aperture", 24.576f);
        defineParam(nearPlane, "Near Plane", 0.1f);
        defineParam(farPlane, "Far Plane", 10000.0f);
        defineParam(
            cameraWorldMatrix,
            "Camera World Matrix",
            float4x4(
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            )
        );

        // Image params
        defineParam(formatHeight, "Screen Height", 2160.0f);
        defineParam(formatWidth, "Screen Width", 3840.0f);
        defineParam(skyBoxOffsetAngle, "SkyBox Offset Angle", 0.0f);
        defineParam(skyFormatHeight, "SkyBox Height", 1024);
        defineParam(skyFormatWidth, "SkyBox Width", 2048);

        // Ray params
        defineParam(subdivisions, "Pixel Subdivisions", 0);
        defineParam(maxRayDistance, "Max Ray Distance", 10000.0f);
        defineParam(maxBounces, "Max Bounces", 1);
        defineParam(hitTolerance, "Hit Tolerance", 0.001f);

        // Shader params TODO make these surface spawn rays
        defineParam(shadowBias, "Shadow Bias", 0.05f);
        defineParam(raysPerPixel, "Rays Per Pixel", 1);
        defineParam(rayOffset, "Ray Offset", 0.0001f);

        // Scene params

        // Shape Counts
        defineParam(spheresTextureHeight, "Spheres Texture Height", 0);
        defineParam(spheresTextureWidth, "Spheres Texture Width", 0);
        defineParam(rectPrismsTextureHeight, "Rectangular Prisms Texture Height", 0);
        defineParam(rectPrismsTextureWidth, "Rectangular Prisms Texture Width", 0);
        defineParam(toriTextureHeight, "Tori Texture Height", 0);
        defineParam(toriTextureWidth, "Tori Texture Width", 0);
        defineParam(triangularPrismsTextureHeight, "Triangular Prisms Texture Height", 0);
        defineParam(triangularPrismsTextureWidth, "Triangular Prisms Texture Width", 0);
        defineParam(cylindersTextureHeight, "Cylinders Texture Height", 0);
        defineParam(cylindersTextureWidth, "Cylinders Texture Width", 0);

        // Light Counts
        defineParam(directionalLightTextureHeight, "Directional Light Texture Height", 0);
        defineParam(directionalLightTextureWidth, "Directional Light Texture Width", 0);
        defineParam(pointLightTextureHeight, "Point Light Texture Height", 0);
        defineParam(pointLightTextureWidth, "Point Light Texture Width", 0);
    }


    // The init() function is run before any calls to process().
    // Local variables can be initialized here.
    void init()
    {
        //formatWidth = formatWidth == 0 ? 1 : formatWidth;
        //focalLength = focalLength == 0 ? 1 : focalLength;
        //aspect = aspect == 0 ? 1 : aspect;
        //horizontalAperture = horizontalAperture == 0 ? 1 : horizontalAperture;
        //rayOffset = rayOffset == 0 ? 0.000001 : rayOffset;
        float farMinusNear = farPlane - nearPlane;

        // TODO use angles to allow -ve focal length like for latlongs
        aspect = formatHeight / formatWidth;
        fieldOfView = 2 * atan(1 / focalLength);
        cameraProjectionMatrix = float4x4(
            2 * focalLength / horizontalAperture, 0, 0, 0,
            0, 2 * focalLength / horizontalAperture / aspect, 0, 0,
            0, 0, -(farPlane + nearPlane) / farMinusNear, -2 * (farPlane * nearPlane) / farMinusNear,
            0, 0, -1, 0
        );
        invert4x4(cameraProjectionMatrix, inverseCameraProjectionMatrix);
        positionFromWorldMatrix(cameraWorldMatrix, cameraPosition);

        int subPixelDivisions = pow(2, abs(subdivisions));
        subdividedPixelSize = 1.0f / (float) subPixelDivisions;
        numSubPixels = pow(subPixelDivisions, 2);

        skyBoxPixelSize = float2(skyFormatWidth / (2 * PI), skyFormatHeight / PI);
        skyBoxOffsetRadians = skyBoxOffsetAngle * PI / 180.0f;
    }

    /**
     * Get the value of sky the ray would hit at infinite distance
     */
    float4 readSkyValue(float3 rayDirection)
    {
        float rayAnglePhi = fmod(acos(rayDirection.y), PI);
        rayAnglePhi += PI * (rayAnglePhi < 0);

        float rayAngleTheta = fmod(
            atan2(rayDirection.z, rayDirection.x) + skyBoxOffsetRadians,
            2 * PI
        );
        rayAngleTheta += 2 * PI * (rayAngleTheta < 0);

        SampleType(skyBox) skyBoxPixel = bilinear(
            skyBox,
            skyBoxPixelSize.x * rayAngleTheta,
            skyFormatHeight - (skyBoxPixelSize.y * rayAnglePhi)
        );

        return skyBoxPixel;
    }


    /**
     * Generate a ray out of the camera
     */
    void createCameraRay(float2 pixelLocation, float3 &rayOrigin, float3 &rayDirection)
    {
        float2 uvPosition = float2(
            2 * pixelLocation.x / formatWidth - 1,
            2 * pixelLocation.y / formatHeight - 1
        );
        rayOrigin = cameraPosition;
        float4 direction;
        matmul(
            inverseCameraProjectionMatrix,
            float4(uvPosition.x, uvPosition.y, 0, 1),
            direction
        );
        matmul(
            cameraWorldMatrix,
            float4(direction.x, direction.y, direction.z, 0),
            direction
        );
        rayDirection = normalize(float3(direction.x, direction.y, direction.z));
    }


    //
    // Render Engine
    //

    /**
     * Compute the minimum distance to an object in the scene
     */
    float getMinDistanceToObjectInScene(float3 rayOrigin)
    {
        float distance = maxRayDistance;

        for (int i=0; i < spheresTextureHeight; i++)
        {
            for (int j=0; j < spheresTextureWidth; j++)
            {
                SampleType(spheres) sphere = spheres(j, i);
                distance = min(
                    distance,
                    distanceToSphere(
                        rayOrigin,
                        float3(sphere.x, sphere.y, sphere.z),
                        sphere.w
                    )
                );
            }
        }

        for (int i=0; i < rectPrismsTextureHeight; i++)
        {
            for (int j=0; j < rectPrismsTextureWidth; j++)
            {
                SampleType(rectPrisms) rectPrism = rectPrisms(j, i);
                distance = min(
                    distance,
                    distanceToRectangularPrism(
                        rayOrigin,
                        float3(rectPrism.x, rectPrism.y, rectPrism.z),
                        float3(rectPrism.w, rectPrism.w / 2.0f, rectPrism.w / 3.0f)
                    )
                );
            }
        }

        for (int i=0; i < toriTextureHeight; i++)
        {
            for (int j=0; j < toriTextureWidth; j++)
            {
                SampleType(tori) torus = tori(j, i);
                distance = min(
                    distance,
                    distanceToTorus(
                        rayOrigin,
                        float3(torus.x, torus.y, torus.z),
                        float2(torus.w / 2.0f, torus.w)
                    )
                );
            }
        }

        for (int i=0; i < triangularPrismsTextureHeight; i++)
        {
            for (int j=0; j < triangularPrismsTextureWidth; j++)
            {
                SampleType(triangularPrisms) triangularPrism = triangularPrisms(j, i);
                distance = min(
                    distance,
                    distanceToTriangularPrism(
                        rayOrigin,
                        float3(triangularPrism.x, triangularPrism.y, triangularPrism.z),
                        float2(triangularPrism.w, triangularPrism.w / 2.0f)
                    )
                );
            }
        }

        for (int i=0; i < cylindersTextureHeight; i++)
        {
            for (int j=0; j < cylindersTextureWidth; j++)
            {
                SampleType(cylinders) cylinder = cylinders(j, i);
                distance = min(
                    distance,
                    distanceToCylinder(
                        rayOrigin,
                        float3(cylinder.x, cylinder.y, cylinder.z),
                        float2(cylinder.w / 2.0f, cylinder.w)
                    )
                );
            }
        }

        return distance;
    }


    /**
     * Estimate the surface normal at the closest point on the closest
     * object to a point
     *
     * @arg point: The point near which to get the surface normal
     *
     * @returns: The normalized surface normal
     */
    float3 estimateSurfaceNormal(const float3 &point) {
        return normalize(float3(
            getMinDistanceToObjectInScene(float3(
                point.x + hitTolerance,
                point.y,
                point.z
            )) - getMinDistanceToObjectInScene(float3(
                point.x - hitTolerance,
                point.y,
                point.z
            )),
            getMinDistanceToObjectInScene(float3(
                point.x,
                point.y + hitTolerance,
                point.z
            )) - getMinDistanceToObjectInScene(float3(
                point.x,
                point.y - hitTolerance,
                point.z
            )),
            getMinDistanceToObjectInScene(float3(
                point.x,
                point.y,
                point.z+hitTolerance
            )) - getMinDistanceToObjectInScene(float3(
                point.x,
                point.y,
                point.z - hitTolerance
            ))
        ));
    }


    float computeLightIntensityOnSurface(const float3 &pointOnSurface, const float3 &surfaceNormal)
    {
        float3 offsetPos = pointOnSurface + surfaceNormal * shadowBias;

        float shadowIntensity = 0;
        float lightIntensity = 0;

        for (int i=0; i < directionalLightTextureHeight; i++)
        {
            for (int j=0; j < directionalLightTextureWidth; j++)
            {
                SampleType(directionalLights) directionalLight = directionalLights(j, i);

                lightIntensity += saturate(
                    dot(
                        surfaceNormal,
                        -normalize(float3(directionalLight.x, directionalLight.y, directionalLight.z))
                    ) * directionalLight.w
                );
            }
        }

        for (int i=0; i < pointLightTextureHeight; i++)
        {
            for (int j=0; j < pointLightTextureWidth; j++)
            {
                SampleType(pointLights) pointLight = pointLights(j, i);

                lightIntensity += saturate(
                    dot(
                        surfaceNormal,
                        normalize(float3(pointLight.x, pointLight.y, pointLight.z) - pointOnSurface)
                    ) * pointLight.w
                );
            }
        }

        return saturate(lightIntensity);
    }


    float computeShadowIntensityOnSurface(const float3 &pointOnSurface, const float3 &surfaceNormal)
    {
        //float3 dirToLight = (positionLight)?normalize(_Light- offsetPos):-_Light;

        //ray.origin = offsetPos;
        //ray.direction = dirToLight;

        //float dstToLight = (positionLight)?distance(offsetPos,_Light):maxDst;
        //float shadow = CalculateShadow(ray, dstToLight);

        return 1;//shadow;
    }


    /**
     * March a ray through the scene
     */
    void marchRay(
            const float3 &rayOrigin,
            const float3 &rayDirection,
            int numRays,
            int numBounces,
            float rayDistance,
            float4 &resultColour
        )
    {
        float3 origin = rayOrigin;
        float3 direction = rayDirection;

        float3 rayNormal = normalize(float3(direction.y, -direction.x, 0));
        float radialOffset = rayOffset;
        float angularOffset = 0;


        for (int rayNum=0; rayNum < numRays; rayNum++)
        {
            int bounces = 0;
            float distanceTravelled = 0;

            while (distanceTravelled < rayDistance)
            {
                float stepDistance = getMinDistanceToObjectInScene(origin);
                distanceTravelled += stepDistance;

                if (stepDistance <= hitTolerance)
                {
                    bounces++;

                    float3 pointOnSurface = origin + rayDirection * stepDistance;
                    float3 surfaceNormal = estimateSurfaceNormal(
                        pointOnSurface - rayDirection * hitTolerance
                    );

                    float lightIntensity = computeLightIntensityOnSurface(
                        pointOnSurface,
                        surfaceNormal
                    );

                    resultColour += float4(lightIntensity, lightIntensity / 2, lightIntensity, 1);

                    break;
                    // if (bounces == numBounces)
                    // {
                    //    break;
                    //}
                }

                origin += direction * stepDistance;
            }

            // If the ray missed, grab the skybox colour
            resultColour += bounces == 0 ? readSkyValue(direction) : float4(0, 0, 0, 0);

            // Update the ray direction to send a scattered cluster of rays
            // TODO these shouldnt diverge more and more the more rays you add
            origin = rayOrigin;

            rayNormal = (
                cos(angularOffset)
                * rayNormal
                + sin(angularOffset)
                * cross(direction, rayNormal)
            );

            direction = radialOffset * rayNormal + rayDirection;

            angularOffset = 90 * (1 - 0.5 * ((rayNum % 4) == 0));
            radialOffset += rayOffset * ((rayNum % 8) == 0);
        }

        resultColour /= raysPerPixel; // Normalize the output after multiple rays
    }


    /**
     * Compute a raymarched pixel value
     */
    void process(int2 pos)
    {
        // Read the input to pass through
        float4 resultPixel(0, 0, 0, 0);

        float2 pixelLocation = float2((float) pos.x, (float) pos.y);

        float2 pixelOffset;
        for (
            pixelOffset.x = 0.0f;
            pixelOffset.x < 1.0f;
            pixelOffset.x += subdividedPixelSize
        ) {
            for (
                pixelOffset.y = 0.0f;
                pixelOffset.y < 1.0f;
                pixelOffset.y += subdividedPixelSize
            ) {
                // Generate a ray from the camera
                float3 rayOrigin;
                float3 rayDirection;
                createCameraRay(pixelLocation + pixelOffset, rayOrigin, rayDirection);

                marchRay(
                    rayOrigin,
                    rayDirection,
                    raysPerPixel,
                    maxBounces,
                    maxRayDistance,
                    resultPixel
                );
            }
        }

        dst() = resultPixel / numSubPixels;
    }
};
