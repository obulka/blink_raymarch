#include "camera.h"
#include "colour.h"
#include "lights.h"
#include "mmath.h"
#include "sdfs.h"
#include "sdfTransforms.h"
#include "sdTransforms.h"


kernel RayMarchKernel : ImageComputationKernel<ePixelWise>
{
    // the input for format, process called once per pixel
    Image<eRead, eAccessPoint, eEdgeNone> bg;

    // the skybox in latlong format
    Image<eRead, eAccessRandom, eEdgeNone> skyBox;


    // the shape positons.xyz
    Image<eRead, eAccessRandom, eEdgeNone> positions;

    // the shape rotations
    Image<eRead, eAccessRandom, eEdgeNone> rotations;

    // the shape dimensions.xyz scale.w (some shapes may not use all channels, all use w)
    Image<eRead, eAccessRandom, eEdgeNone> scales;

    // the shape colours.xyz
    Image<eRead, eAccessRandom, eEdgeNone> colours;


    // shape type.x, operation.y, numChildren.z, blend strength.w
    // x in [0, 1) sphere
    // x in [1, 2) rectangular prism
    // x in [2, 3) cylinder
    // x in [3, 4) triangular prism
    // x in [4, inf) torus
    Image<eRead, eAccessRandom, eEdgeNone> shapeProperties;

    // reflection.x, transmission.y, emission.z, roughness.w (TODO)
    Image<eRead, eAccessRandom, eEdgeNone> surfaceProperties;


    // the input directional lights direction.xyz intensity.w
    Image<eRead, eAccessRandom, eEdgeNone> lights;

    // colour.xyz, type.w
    // w in [0, 1) = directional, [1, inf) = point
    Image<eRead, eAccessRandom, eEdgeNone> lightProperties;

    // the output image
    Image<eWrite> dst;


    param:
        // These parameters are made available to the user.

        // Camera params
        float focalLength;
        float horizontalAperture;
        float nearPlane;
        float farPlane;
        float4x4 cameraWorldMatrix;

        // Image params
        float formatWidth;
        float formatHeight;

        float skyBoxOffsetAngle;
        int skyFormatWidth;
        int skyFormatHeight;

        // Ray params
        int subdivisions;
        int maxBounces;
        float maxRayDistance;
        float hitTolerance;
        float shadowBias;

        // Shader params
        float intensityInShadow;
        int raysPerPixel;
        float rayOffset;

        // Scene params
        // Shape Textures
        int objectTextureHeight;
        int objectTextureWidth;

        // Light textures
        int lightTextureHeight;
        int lightTextureWidth;

        float hazeAmount;
        float hazeStart;
        float hazeDistance;
        float4 hazeColour;

        float iterGlowAmount;
        float4 iterGlowColour;

    local:
        // These local variables are not exposed to the user.

        float4x4 inverseCameraProjectionMatrix;

        int bouncesPerRay;

        int numSubPixels;
        float subdividedPixelSize;

        float2 skyBoxPixelSize;
        float skyBoxOffsetRadians;



    // In define(), parameters can be given labels and default values.
    void define()
    {
        // Camera params
        defineParam(focalLength, "Focal Length", 50.0f);
        defineParam(horizontalAperture, "Horizontal Aperture", 24.576f);
        defineParam(nearPlane, "Near Plane", 0.1f);
        defineParam(farPlane, "Far Plane", 10000.0f);
        defineParam(
            cameraWorldMatrix,
            "Camera World Matrix",
            float4x4(
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            )
        );

        // Image params
        defineParam(formatHeight, "Screen Height", 2160.0f);
        defineParam(formatWidth, "Screen Width", 3840.0f);
        defineParam(skyBoxOffsetAngle, "SkyBox Offset Angle", 0.0f);
        defineParam(skyFormatHeight, "SkyBox Height", 1024);
        defineParam(skyFormatWidth, "SkyBox Width", 2048);

        // Ray params
        defineParam(subdivisions, "Pixel Subdivisions", 0);
        defineParam(maxRayDistance, "Max Ray Distance", 1000.0f);
        defineParam(maxBounces, "Max Bounces", 1);
        defineParam(hitTolerance, "Hit Tolerance", 0.001f);
        defineParam(shadowBias, "Shadow Bias", 1.0f);

        // Shader params TODO make these surface spawn rays
        defineParam(intensityInShadow, "Intensity in Shadows", 1.0f);
        defineParam(raysPerPixel, "Rays Per Pixel", 1);
        defineParam(rayOffset, "Ray Offset", 0.0001f);

        // Scene params

        // Shape Counts
        defineParam(objectTextureHeight, "Object Texture Height", 0);
        defineParam(objectTextureWidth, "Object Texture Width", 0);

        // Light Counts
        defineParam(lightTextureHeight, "Directional Light Texture Height", 0);
        defineParam(lightTextureWidth, "Directional Light Texture Width", 0);

        defineParam(hazeAmount, "Haze Amount", 0.0f);
        defineParam(hazeStart, "Haze Start", 0.0f);
        defineParam(hazeDistance, "Haze Distance", 1000.0f);
        defineParam(hazeColour, "Haze Colour", float4(1, 1, 1, 1));

        defineParam(iterGlowAmount, "Iter Glow Amount", 0.0f);
        defineParam(iterGlowColour, "Iter Glow Colour", float4(1, 1, 1, 1));
    }


    // The init() function is run before any calls to process().
    // Local variables can be initialized here.
    void init()
    {
        //formatWidth = formatWidth == 0 ? 1 : formatWidth;
        //focalLength = focalLength == 0 ? 1 : focalLength;
        //aspect = aspect == 0 ? 1 : aspect;
        //horizontalAperture = horizontalAperture == 0 ? 1 : horizontalAperture;
        //rayOffset = rayOffset == 0 ? 0.000001 : rayOffset;

        bouncesPerRay = maxBounces <= 0 ? 1 : maxBounces;

        // TODO use angles to allow -ve focal length like for latlongs
        float aspect = aspectRatio(formatHeight, formatWidth);
        float4x4 cameraProjectionMatrix = projectionMatrix(
            focalLength,
            horizontalAperture,
            aspect,
            nearPlane,
            farPlane
        );
        inverseCameraProjectionMatrix = cameraProjectionMatrix.invert();

        int subPixelDivisions = pow(2, abs(subdivisions));
        subdividedPixelSize = 1.0f / (float) subPixelDivisions;
        numSubPixels = pow(subPixelDivisions, 2);

        skyBoxPixelSize = float2(skyFormatWidth / (2 * PI), skyFormatHeight / PI);
        skyBoxOffsetRadians = skyBoxOffsetAngle * PI / 180.0f;
    }


    /**
     * Get the value of sky the ray would hit at infinite distance
     */
    float4 readSkyValue(float3 rayDirection)
    {
        float2 angles = cartesionUnitVectorToSpherical(rayDirection, skyBoxOffsetRadians);

        SampleType(skyBox) skyBoxPixel = bilinear(
            skyBox,
            skyBoxPixelSize.x * angles.x,
            skyFormatHeight - (skyBoxPixelSize.y * angles.y)
        );

        return skyBoxPixel;
    }


    //
    // Render Engine
    //


    /**
     * Compute the minimum distance to an object in the scene
     */
    float getMinDistanceToObjectInScene(
            const float3 rayOrigin,
            float4 &colour,
            float4 &surface)
    {
        float distance = maxRayDistance;

        float3x3 rotMatrix;
        float3 transformedRay;
        for (int i=0; i < objectTextureHeight; i++)
        {
            for (int j=0; j < objectTextureWidth; j++)
            {
                SampleType(positions) position = positions(j, i);
                SampleType(rotations) rotation = rotations(j, i);
                SampleType(scales) scale = scales(j, i);
                SampleType(shapeProperties) shapeProperty = shapeProperties(j, i);

                rotationMatrix(float3(rotation.x, rotation.y, rotation.z), rotMatrix);
                matmul(
                    rotMatrix.invert(),
                    rayOrigin - float3(position.x, position.y, position.z),
                    transformedRay
                );

                float nextDistance = distanceToObject(
                    transformedRay / scale.w,
                    (int) shapeProperty.x,
                    float3(scale.x, scale.y, scale.z)
                ) * scale.w;

                if (nextDistance < distance)
                {
                    distance = nextDistance;

                    SampleType(colours) surfaceColour = colours(j, i);
                    SampleType(surfaceProperties) surfaceProperty = surfaceProperties(j, i);

                    colour = float4(surfaceColour);
                    surface = float4(surfaceProperty);
                }
            }
        }

        return distance;
    }


    float computeShadow(
            const float3 &rayDirection,
            const float distanceToShadePoint,
            float3 rayOrigin)
    {
        float distanceTravelled = 0;
        float4 colour;
        float4 surface;
        while (distanceTravelled < distanceToShadePoint)
        {
            float stepDistance = getMinDistanceToObjectInScene(rayOrigin, colour, surface);

            if (stepDistance < hitTolerance)
            {
                return intensityInShadow;
            }

            rayOrigin += rayDirection * stepDistance;
            distanceTravelled += stepDistance;
        }

        return 1;
    }


    float2 lightIntensityOnSurface(
            const float3 &pointOnSurface,
            const float3 &surfaceNormal,
            const float3 &light,
            const int lightType,
            const float intensity)
    {
        float3 surfaceOffset;
        float distanceToLight;
        float3 lightDirection;
        float3 shadowOffsetLightDirection;
        float intensityAtPosition = getLightData(
            pointOnSurface,
            surfaceNormal,
            light,
            lightType,
            intensity,
            hitTolerance,
            maxRayDistance,
            shadowBias,
            distanceToLight,
            surfaceOffset,
            lightDirection,
            shadowOffsetLightDirection
        );

        float normalFactor = dot(surfaceNormal, normalize(lightDirection));

        return saturate(
            normalFactor * float2(
                intensityAtPosition,
                computeShadow(
                    normalize(shadowOffsetLightDirection),
                    distanceToLight,
                    surfaceOffset
                )
            )
        );
    }


    /**
     * Get the intensity of the light on the surface of an object
     *
     *
     */
    float computeLightIntensityOnSurface(const float3 &pointOnSurface, const float3 &surfaceNormal)
    {
        float2 lightIntensity = float2(0, 0);

        for (int i=0; i < lightTextureHeight; i++)
        {
            for (int j=0; j < lightTextureWidth; j++)
            {
                SampleType(lights) light = lights(j, i);
                SampleType(lightProperties) lightProperty = lightProperties(j, i);

                lightIntensity += lightIntensityOnSurface(
                    pointOnSurface,
                    surfaceNormal,
                    float3(light.x, light.y, light.z),
                    (int) lightProperty.w,
                    light.w
                );
            }
        }

        return saturate(lightIntensity.x * lightIntensity.y);
    }


    float getHazeAmount(const float distance)
    {
        return hazeAmount * saturate((distance - hazeStart) / hazeDistance);
    }


    /**
     * Estimate the surface normal at the closest point on the closest
     * object to a point
     *
     * @arg point: The point near which to get the surface normal
     *
     * @returns: The normalized surface normal
     */
    float3 estimateSurfaceNormal(const float3 &point) {
        float4 colour;
        float4 surface;
        return normalize(
            float3(
                getMinDistanceToObjectInScene(
                    float3(
                        point.x + hitTolerance,
                        point.y,
                        point.z
                    ),
                    colour,
                    surface
                ) - getMinDistanceToObjectInScene(
                    float3(
                        point.x - hitTolerance,
                        point.y,
                        point.z
                    ),
                    colour,
                    surface
                ),
                getMinDistanceToObjectInScene(
                    float3(
                        point.x,
                        point.y + hitTolerance,
                        point.z
                    ),
                    colour,
                    surface
                ) - getMinDistanceToObjectInScene(
                    float3(
                        point.x,
                        point.y - hitTolerance,
                        point.z
                    ),
                    colour,
                    surface
                ),
                getMinDistanceToObjectInScene(
                    float3(
                        point.x,
                        point.y,
                        point.z+hitTolerance
                    ),
                    colour,
                    surface
                ) - getMinDistanceToObjectInScene(
                    float3(
                        point.x,
                        point.y,
                        point.z - hitTolerance
                    ),
                    colour,
                    surface
                )
        ));
    }


    /**
     * March a ray through the scene
     *
     * @returns: The ray colour
     */
    float4 marchRay(
            const float3 &rayOrigin,
            const float3 &rayDirection,
            const int numBounces,
            const float rayDistance)
    {
        float3 origin = rayOrigin;
        float3 direction = rayDirection;
        float4 colour;
        float4 surface;

        int bounces = 0;
        float distanceTravelled = 0;
        float lastHitDistance = distanceTravelled;

        float lightIntensity = 1;

        float4 rayColour = float4(0, 0, 0, 0);

        float rayStrength = 1;

        int iterations = 1;
        while (distanceTravelled < rayDistance && rayStrength > 0)
        {
            float stepDistance = getMinDistanceToObjectInScene(origin, colour, surface);
            distanceTravelled += stepDistance;
            origin += direction * stepDistance;

            if (stepDistance < hitTolerance)
            {
                bounces++;

                float3 surfaceNormal = estimateSurfaceNormal(
                    origin - direction * hitTolerance
                );

                lightIntensity = computeLightIntensityOnSurface(
                    origin,
                    surfaceNormal
                );

                rayColour = blend(
                    iterGlowColour,
                    blend(
                        hazeColour,
                        blend(
                            colour,
                            rayColour,
                            rayStrength * (1 - surface.x) * lightIntensity
                        ),
                        getHazeAmount(distanceTravelled - lastHitDistance)
                    ),
                    iterGlowAmount * iterations
                );

                if (bounces >= numBounces)
                {
                    return rayColour;
                }

                rayStrength *= surface.x * lightIntensity;

                direction = reflectRayOffSurface(
                    direction,
                    surfaceNormal
                );
                origin = offsetPoint(
                    origin,
                    direction + surfaceNormal,
                    hitTolerance
                );

                lastHitDistance = distanceTravelled;
            }
            iterations++;
        }

        return blend(
            blend(
                iterGlowColour,
                blend(
                    hazeColour,
                    readSkyValue(direction),
                    getHazeAmount(distanceTravelled - lastHitDistance)
                ),
                iterGlowAmount * iterations
            ),
            rayColour,
            rayStrength
        );
    }


    /**
     * March rays through the scene
     */
    void marchRays(
            const float3 &rayOrigin,
            const float3 &rayDirection,
            const int numRays,
            const int numBounces,
            const float rayDistance,
            float4 &resultColour)
    {
        float3 direction = rayDirection;

        float3 rayNormal = normalize(float3(direction.y, -direction.x, 0));
        float radialOffset = rayOffset;
        float angularOffset = 0;

        float4 colour;

        for (int rayNum=0; rayNum < numRays; rayNum++)
        {
            resultColour += marchRay(
                rayOrigin,
                direction,
                numBounces,
                rayDistance
            );

            // Update the ray direction to send a scattered cluster of rays
            // TODO these shouldnt diverge more and more the more rays you add
            rayNormal = (
                cos(angularOffset)
                * rayNormal
                + sin(angularOffset)
                * cross(direction, rayNormal)
            );

            direction = radialOffset * rayNormal + rayDirection;

            angularOffset = 90 * (1 - 0.5 * ((rayNum % 4) == 0));
            radialOffset += rayOffset * ((rayNum % 8) == 0);
        }

        // Normalize the output after multiple rays
        resultColour /= numRays;
    }


    /**
     * Compute a raymarched pixel value
     */
    void process(int2 pos)
    {
        float4 resultPixel(0, 0, 0, 0);

        float2 pixelLocation = float2(pos.x, pos.y);

        float2 pixelOffset;
        for (
            pixelOffset.x = 0.0f;
            pixelOffset.x < 1.0f;
            pixelOffset.x += subdividedPixelSize
        ) {
            for (
                pixelOffset.y = 0.0f;
                pixelOffset.y < 1.0f;
                pixelOffset.y += subdividedPixelSize
            ) {
                // Generate a ray from the camera
                float3 rayOrigin;
                float3 rayDirection;
                createCameraRay(
                    cameraWorldMatrix,
                    inverseCameraProjectionMatrix,
                    pixelsToUV(
                        pixelLocation + pixelOffset,
                        float2(formatWidth, formatHeight)
                    ),
                    rayOrigin,
                    rayDirection
                );

                marchRays(
                    rayOrigin,
                    rayDirection,
                    raysPerPixel,
                    bouncesPerRay,
                    maxRayDistance,
                    resultPixel
                );
            }
        }

        dst() = resultPixel / numSubPixels;
    }
};
