#include "camera.h"
#include "lights.h"
#include "mmath.h"
#include "sdfs.h"
#include "sdfTransforms.h"
#include "sdTransforms.h"


#define MAX_RAYS_PER_SUBPIXEL 100
#define MAX_CHILD_DEPTH 100


kernel RayMarchKernel : ImageComputationKernel<ePixelWise>
{
    // the input for format, process called once per pixel
    Image<eRead, eAccessPoint, eEdgeNone> bg;

    // the skybox in latlong format
    Image<eRead, eAccessRandom, eEdgeConstant> skyBox;


    // the shape positons.xyz, scale.w
    Image<eRead, eAccessRandom, eEdgeNone> positions;

    // the shape rotations.xyz, wall thickness.w
    Image<eRead, eAccessRandom, eEdgeNone> rotations;

    // the shape dimensions.xyzw (some shapes may not use all channels)
    Image<eRead, eAccessRandom, eEdgeNone> dimensions;

    // the shape colours.xyz, refractive index.w
    Image<eRead, eAccessRandom, eEdgeNone> colours;


    // shape type.x, operation.y, numChildren.z, blend strength.w
    Image<eRead, eAccessRandom, eEdgeNone> shapeProperties;

    // repetition params.xyzw
    Image<eRead, eAccessRandom, eEdgeNone> shapeModParameters0;

    // elongation.xyz edgeRadius.w
    Image<eRead, eAccessRandom, eEdgeNone> shapeModParameters1;

    // reflection.x, transmission.y, emission.z, roughness.w (TODO)
    Image<eRead, eAccessRandom, eEdgeNone> surfaceProperties;


    // the input lights direction/position.xyz intensity.w
    Image<eRead, eAccessRandom, eEdgeNone> lights;

    // colour.xyz, type.w
    // w in [0, 1) = directional, [1, inf) = point
    Image<eRead, eAccessRandom, eEdgeNone> lightProperties;

    // shadow hardness.x
    Image<eRead, eAccessRandom, eEdgeNone> lightProperties1;

    // the skybox in latlong format
    Image<eRead, eAccessRandom, eEdgeNone> skyBoxLight;

    // the output image
    Image<eWrite> dst;


    param:
        // These parameters are made available to the user.

        // Camera params
        float focalLength;
        float horizontalAperture;
        float nearPlane;
        float farPlane;
        float4x4 cameraWorldMatrix;

        // Image params
        float formatWidth;
        float formatHeight;

        float skyBoxOffsetAngle;
        int skyFormatWidth;
        int skyFormatHeight;
        float skyLightGain;
        float skyLightShadowHardness;
        int softenSkyLightShadows;
        int skyLightFormatWidth;
        int skyLightFormatHeight;
        int skyLightSamples;

        // Ray params
        int subdivisions;
        int maxRaysPerSubPixel;
        int maxBounces;
        float maxRayDistance;
        int maxRaySteps;
        float hitTolerance;
        float shadowBias;

        // Scene params
        float refractiveIndex;

        // Shape Textures
        int objectTextureHeight;
        int objectTextureWidth;

        // Light textures
        int lightTextureHeight;
        int lightTextureWidth;

        float hazeAmount;
        float hazeStart;
        float hazeDistance;
        float4 hazeColour;

        float iterGlowAmount;
        float4 iterGlowColour;

        int outputType;

    local:
        // These local variables are not exposed to the user.

        float4x4 inverseCameraProjectionMatrix;

        int bouncesPerRay;

        int numSubPixels;
        float subdividedPixelSize;

        float2 skyBoxPixelSize;
        float2 skyLightPixelSize;
        float skyBoxOffsetRadians;



    // In define(), parameters can be given labels and default values.
    void define()
    {
        // Camera params
        defineParam(focalLength, "Focal Length", 50.0f);
        defineParam(horizontalAperture, "Horizontal Aperture", 24.576f);
        defineParam(nearPlane, "Near Plane", 0.1f);
        defineParam(farPlane, "Far Plane", 10000.0f);
        defineParam(
            cameraWorldMatrix,
            "Camera World Matrix",
            float4x4(
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            )
        );

        // Image params
        defineParam(formatHeight, "Screen Height", 2160.0f);
        defineParam(formatWidth, "Screen Width", 3840.0f);
        defineParam(skyBoxOffsetAngle, "SkyBox Offset Angle", 0.0f);
        defineParam(skyFormatHeight, "SkyBox Height", 1024);
        defineParam(skyFormatWidth, "SkyBox Width", 2048);
        defineParam(skyLightGain, "SkyBox Lighting Gain", 0.1f);
        defineParam(skyLightShadowHardness, "SkyBox Shadow Hardness", 1.0f);
        defineParam(softenSkyLightShadows, "Soften SkyBox Shadows", 1);
        defineParam(skyLightFormatHeight, "SkyBox Lighting Height", 512);
        defineParam(skyLightFormatWidth, "SkyBox Lighting Width", 1024);
        defineParam(skyLightSamples, "SkyBox Lighting Samples", 5);

        // Ray params
        defineParam(subdivisions, "Pixel Subdivisions", 0);
        defineParam(maxRaysPerSubPixel, "Max Rays Per Subpixel", 1);
        defineParam(maxRayDistance, "Max Ray Distance", 1000.0f);
        defineParam(maxRaySteps, "Max Ray Steps", 128);
        defineParam(maxBounces, "Max Bounces", 1);
        defineParam(hitTolerance, "Hit Tolerance", 0.001f);
        defineParam(shadowBias, "Shadow Bias", 1.0f);

        // Scene params
        defineParam(refractiveIndex, "Index of Refraction", 1.0f);

        // Shape Counts
        defineParam(objectTextureHeight, "Object Texture Height", 0);
        defineParam(objectTextureWidth, "Object Texture Width", 0);

        // Light Counts
        defineParam(lightTextureHeight, "Light Texture Height", 0);
        defineParam(lightTextureWidth, "Light Texture Width", 0);

        defineParam(hazeAmount, "Haze Amount", 0.0f);
        defineParam(hazeStart, "Haze Start", 0.0f);
        defineParam(hazeDistance, "Haze Distance", 1000.0f);
        defineParam(hazeColour, "Haze Colour", float4(1, 1, 1, 1));

        defineParam(iterGlowAmount, "Iter Glow Amount", 0.0f);
        defineParam(iterGlowColour, "Iter Glow Colour", float4(1, 1, 1, 1));

        defineParam(outputType, "Output Type", 0);
    }


    // The init() function is run before any calls to process().
    // Local variables can be initialized here.
    void init()
    {
        bouncesPerRay = maxBounces <= 0 ? 1 : maxBounces;

        // TODO use angles to allow -ve focal length like for latlongs
        float aspect = aspectRatio(formatHeight, formatWidth);
        float4x4 cameraProjectionMatrix = projectionMatrix(
            focalLength,
            horizontalAperture,
            aspect,
            nearPlane,
            farPlane
        );
        inverseCameraProjectionMatrix = cameraProjectionMatrix.invert();

        int subPixelDivisions = pow(2, abs(subdivisions));
        subdividedPixelSize = 1.0f / (float) subPixelDivisions;
        numSubPixels = pow(subPixelDivisions, 2);

        skyBoxPixelSize = float2(skyFormatWidth / (2 * PI), skyFormatHeight / PI);
        skyLightPixelSize = float2(skyLightFormatWidth / (2 * PI), skyLightFormatHeight / PI);
        skyBoxOffsetRadians = skyBoxOffsetAngle * PI / 180.0f;
    }


    /**
     * Get the value of sky the ray would hit at infinite distance
     */
    float4 readSkyValue(float3 rayDirection)
    {
        const float2 angles = cartesionUnitVectorToSpherical(rayDirection, skyBoxOffsetRadians);

        const float2 indices = clamp(
            float2(
                skyBoxPixelSize.x * angles.x,
                skyFormatHeight - (skyBoxPixelSize.y * angles.y)
            ),
            float2(0),
            float2(skyFormatWidth, skyFormatHeight) - 1.0f
        );

        return bilinear(skyBox, indices.x, indices.y);
    }


    /**
     * Get the value of sky the ray would hit at infinite distance
     */
    float4 readSkyLightValue(float3 rayDirection)
    {
        const float2 angles = cartesionUnitVectorToSpherical(rayDirection, skyBoxOffsetRadians);

        const float2 indices = clamp(
            float2(
                skyLightPixelSize.x * angles.x,
                skyLightFormatHeight - (skyLightPixelSize.y * angles.y)
            ),
            float2(0),
            float2(skyLightFormatWidth, skyLightFormatHeight) - 1.0f
        );

        return bilinear(skyBoxLight, indices.x, indices.y);
    }


    //
    // Render Engine
    //


    float3 transformRay(
        const float3 &rayOrigin,
        const float3 &position,
        const float3 &rotation,
        const int modifications,
        const float4 &modParameters0,
        const float4 &modParameters1)
    {
        float3x3 rotMatrix;
        float3 transformedRay;
        rotationMatrix(rotation, rotMatrix);
        matmul(
            rotMatrix.invert(),
            rayOrigin - position,
            transformedRay
        );
        performShapeModification(
            modifications,
            modParameters0,
            modParameters1,
            transformedRay
        );

        return transformedRay;
    }


    float getNextDistance(
        const float3 &rayOrigin,
        const int shape,
        const float4 &dimension,
        const float uniformScale,
        const int modifications,
        const float edgeRadius,
        const float wallThickness,
        float4 &colour)
    {
        float nextDistance = distanceToObject(
            rayOrigin / uniformScale,
            shape,
            dimension,
            colour
        ) * uniformScale;

        return performDistanceModification(
            modifications,
            edgeRadius,
            wallThickness,
            nextDistance
        );
    }


    /**
     * Compute the minimum distance to an object in the scene
     */
    float getMinDistanceToObjectInScene(
            const float3 &rayOrigin,
            float4 &colour,
            float4 &surface)
    {
        float distance = maxRayDistance;

        // numChildren, transformedRay, nextDistance, colour, refractive
        // index, surface, blendStrength, mods
        float parentStack[MAX_CHILD_DEPTH][1 + 3 + 1 + 3 + 1 +  4 + 1 + 1];
        int parentStackLength = 0;

        for (int i=0; i < objectTextureHeight; i++)
        {
            for (int j=0; j < objectTextureWidth; j++)
            {
                SampleType(positions) position = positions(j, i);
                SampleType(rotations) rotation = rotations(j, i);
                SampleType(dimensions) dimension = dimensions(j, i);
                SampleType(shapeProperties) shapeProperty = shapeProperties(j, i);
                SampleType(shapeModParameters0) modParameters0 = shapeModParameters0(j, i);
                SampleType(shapeModParameters1) modParameters1 = shapeModParameters1(j, i);
                SampleType(colours) surfaceColour = colours(j, i);
                SampleType(surfaceProperties) surfaceProperty = surfaceProperties(j, i);

                const int modifications = (int) shapeProperty.y;
                const float scale = position.w;

                const float blendStrength = shapeProperty.w;
                int numChildren = (int) shapeProperty.z;

                float nextDistance = maxRayDistance;

                int stackLastIndex = parentStackLength - 1;

                float4 blendedColour = surfaceColour;
                float4 blendedSurface = surfaceProperty;
                if (numChildren <= 0)
                {
                    // No Children left, compute interactions with parent
                    if (parentStackLength > 0)
                    {
                        const float3 parentTransformedRay = float3(
                            parentStack[stackLastIndex][1],
                            parentStack[stackLastIndex][2],
                            parentStack[stackLastIndex][3]
                        );

                        // Use parent transform to position child
                        const float3 transformedRay = transformRay(
                            parentTransformedRay,
                            float3(position.x, position.y, position.z),
                            float3(rotation.x, rotation.y, rotation.z),
                            modifications,
                            modParameters0,
                            modParameters1
                        );

                        // Get distance to this child
                        nextDistance = getNextDistance(
                            transformedRay,
                            (int) shapeProperty.x,
                            dimension,
                            scale,
                            modifications,
                            modParameters1.w,
                            rotation.w,
                            blendedColour
                        );

                        do
                        {
                            const float parentNextDistance = parentStack[stackLastIndex][4];
                            const float4 parentSurfaceColour = float4(
                                parentStack[stackLastIndex][5],
                                parentStack[stackLastIndex][6],
                                parentStack[stackLastIndex][7],
                                parentStack[stackLastIndex][8]
                            );
                            const float4 parentSurfaceProperty = float4(
                                parentStack[stackLastIndex][9],
                                parentStack[stackLastIndex][10],
                                parentStack[stackLastIndex][11],
                                parentStack[stackLastIndex][12]
                            );
                            const float parentBlendStrength = parentStack[stackLastIndex][13];
                            const int parentModifications = (int) parentStack[stackLastIndex][14];

                            // Compute interaction between parent and this child
                            nextDistance = performChildInteraction(
                                parentModifications,
                                parentNextDistance,
                                nextDistance,
                                parentSurfaceColour,
                                blendedColour,
                                parentSurfaceProperty,
                                blendedSurface,
                                parentBlendStrength
                            );
                            // Update the global min distance (and surface/colour)
                            if (fabs(nextDistance) < fabs(distance))
                            {
                                distance = nextDistance;

                                colour = blendedColour;
                                surface = blendedSurface;
                            }
                            for (int parentIndex=stackLastIndex; parentIndex >= 0; parentIndex--)
                            {
                                parentStack[parentIndex][0]--;
                            }

                            numChildren = parentStack[stackLastIndex][0];
                        }
                        while (numChildren <= 0 && --stackLastIndex >= 0);

                        parentStackLength = stackLastIndex + 1;
                    }
                    else
                    {
                        const float3 transformedRay = transformRay(
                            rayOrigin,
                            float3(position.x, position.y, position.z),
                            float3(rotation.x, rotation.y, rotation.z),
                            modifications,
                            modParameters0,
                            modParameters1
                        );

                        nextDistance = getNextDistance(
                            transformedRay,
                            (int) shapeProperty.x,
                            dimension,
                            scale,
                            modifications,
                            modParameters1.w,
                            rotation.w,
                            blendedColour
                        );

                        if (fabs(nextDistance) < fabs(distance))
                        {
                            distance = nextDistance;

                            colour = blendedColour;
                            surface = blendedSurface;
                        }
                    }
                }
                else
                {
                    // Node has Children, push it to the stack for later
                    // processing when we have its children
                    float3 parentTransformedRay = rayOrigin;
                    if (parentStackLength > 0)
                    {
                        parentTransformedRay.x = parentStack[stackLastIndex][1];
                        parentTransformedRay.y = parentStack[stackLastIndex][2];
                        parentTransformedRay.z = parentStack[stackLastIndex][3];
                    }
                    const float3 transformedRay = transformRay(
                        parentTransformedRay,
                        float3(position.x, position.y, position.z),
                        float3(rotation.x, rotation.y, rotation.z),
                        modifications,
                        modParameters0,
                        modParameters1
                    );

                    nextDistance = getNextDistance(
                        transformedRay,
                        (int) shapeProperty.x,
                        dimension,
                        scale,
                        modifications,
                        modParameters1.w,
                        rotation.w,
                        blendedColour
                    );

                    // parentStack.push()
                    parentStack[parentStackLength][0] = numChildren;
                    parentStack[parentStackLength][1] = transformedRay.x;
                    parentStack[parentStackLength][2] = transformedRay.y;
                    parentStack[parentStackLength][3] = transformedRay.z;
                    parentStack[parentStackLength][4] = nextDistance;
                    parentStack[parentStackLength][5] = blendedColour.x;
                    parentStack[parentStackLength][6] = blendedColour.y;
                    parentStack[parentStackLength][7] = blendedColour.z;
                    parentStack[parentStackLength][8] = blendedColour.w;
                    parentStack[parentStackLength][9] = blendedSurface.x;
                    parentStack[parentStackLength][10] = blendedSurface.y;
                    parentStack[parentStackLength][11] = blendedSurface.z;
                    parentStack[parentStackLength][12] = blendedSurface.w;
                    parentStack[parentStackLength][13] = blendStrength;
                    parentStack[parentStackLength][14] = (float) modifications;
                    parentStackLength++;
                }
            }
        }

        return distance;
    }


    float computeSoftShadow(
            const float3 &rayDirection,
            const float distanceToShadePoint,
            const float softness,
            float3 &rayOrigin)
    {
        float distanceTravelled = 0;
        float shadowIntensity = 1.0f;
        float lastStepDistance = 1000000000000000000000000.0f;
        float4 colour;
        float4 surface;

        int iterations = 0;
        while (distanceTravelled < distanceToShadePoint && iterations < maxRaySteps / 2)
        {
            const float stepDistance = fabs(getMinDistanceToObjectInScene(
                rayOrigin,
                colour,
                surface
            ));
            const float stepDistanceSquared = stepDistance * stepDistance;
            float softOffset = stepDistanceSquared / (2.0f * lastStepDistance);
            shadowIntensity = min(
                shadowIntensity,
                softness * sqrt(stepDistanceSquared - softOffset * softOffset)
                / max(0.0f, distanceTravelled - softOffset)
            );

            if (stepDistance < hitTolerance)
            {
                break;
            }

            lastStepDistance = stepDistance;
            rayOrigin += rayDirection * stepDistance;
            distanceTravelled += stepDistance;
            iterations++;
        }

        shadowIntensity = saturate(shadowIntensity);
        return shadowIntensity * shadowIntensity * (3.0f - 2.0f * shadowIntensity);
    }


    float computeShadow(
            const float3 &rayDirection,
            const float distanceToShadePoint,
            float3 &rayOrigin)
    {
        float distanceTravelled = 0;
        float4 colour;
        float4 surface;
        int iterations = 0;
        while (distanceTravelled < distanceToShadePoint && iterations < maxRaySteps / 2)
        {
            float stepDistance = fabs(getMinDistanceToObjectInScene(rayOrigin, colour, surface));

            if (stepDistance < hitTolerance)
            {
                return 0;
            }

            rayOrigin += rayDirection * stepDistance;
            distanceTravelled += stepDistance;
            iterations++;
        }

        return 1;
    }


    float computeAmbientOcclusion(
            const float3 &rayDirection,
            const float3 &rayOrigin,
            const float amount,
            const int iterations)
    {
        float occlusion = 0.0f;
        float occlusionScaleFactor = 1.0f;
        float4 colour;
        float4 surface;
        for(int iteration=0; iteration < iterations; iteration++)
        {
            float stepDistance = 0.001f + 0.15f * float(iteration) / 4.0f;
            float distanceToClosestObject = fabs(getMinDistanceToObjectInScene(
                rayOrigin + stepDistance * rayDirection,
                colour,
                surface
            ));
            occlusion += (stepDistance - distanceToClosestObject) * occlusionScaleFactor;
            occlusionScaleFactor *= 0.95;
        }

        return (
            amount
            * saturate(0.5f + 0.5f * rayDirection.y)  // ambient
            * saturate(1.0f - 1.5f * occlusion)       // occlusion
        );
    }


    float2 lightIntensityOnSurface(
            const float3 &pointOnSurface,
            const float3 &surfaceNormal,
            const float3 &light,
            const int lightType,
            const float intensity,
            const float falloff,
            const float shadow_hardness)
    {
        int absLightType = abs(lightType);
        if (absLightType == 3)
        {
            return float2(
                1.0f,
                computeAmbientOcclusion(
                    surfaceNormal,
                    pointOnSurface,
                    intensity,
                    (int) light.x
                )
            );
        }

        float distanceToLight;
        float3 lightDirection;
        float3 shadowOffsetLightDirection;
        float intensityAtPosition = getLightData(
            pointOnSurface,
            surfaceNormal,
            light,
            absLightType,
            intensity,
            falloff,
            maxRayDistance,
            distanceToLight,
            lightDirection,
            shadowOffsetLightDirection
        );
        float3 surfaceOffset = surfaceOffsetPoint(
            pointOnSurface,
            lightDirection,
            surfaceNormal,
            shadowBias,
            hitTolerance 
        );
        lightDirection = normalize(lightDirection);

        float normalFactor = dot(surfaceNormal, lightDirection);

        float shadowIntensityAtPosition;
        if (lightType < 0)
        {
            shadowIntensityAtPosition = computeSoftShadow(
                normalize(shadowOffsetLightDirection),
                distanceToLight,
                shadow_hardness,
                surfaceOffset
            );
        }
        else
        {
            shadowIntensityAtPosition = computeShadow(
                normalize(shadowOffsetLightDirection),
                distanceToLight,
                surfaceOffset
            );
        }

        return saturate(
            normalFactor * float2(intensityAtPosition, shadowIntensityAtPosition)
        );
    }


    /**
     * Get the intensity of the light on the surface of an object
     */
    float computeLightIntensityOnSurface(
            const float3 &pointOnSurface,
            const float3 &surfaceNormal,
            const float4 &surface,
            float4 &lightColour)
    {
        float2 lightIntensity = float2(0, 0);
        lightColour = float4(0);

        float2 currentLightIntensity;
        for (int i=0; i < lightTextureHeight; i++)
        {
            for (int j=0; j < lightTextureWidth; j++)
            {
                SampleType(lights) light = lights(j, i);
                SampleType(lightProperties) lightProperty = lightProperties(j, i);
                SampleType(lightProperties1) lightProperty1 = lightProperties1(j, i);

                int lightType = (int) lightProperty.w;
                if (lightType == 0)
                {
                    currentLightIntensity = float2(light.w, 1);
                }
                else
                {
                    currentLightIntensity = lightIntensityOnSurface(
                        pointOnSurface,
                        surfaceNormal,
                        float3(light.x, light.y, light.z),
                        lightType,
                        light.w,
                        lightProperty1.y,
                        lightProperty1.x
                    );
                }
                lightColour += currentLightIntensity.x * currentLightIntensity.y * float4(
                    lightProperty.x,
                    lightProperty.y,
                    lightProperty.z,
                    0.0f
                );
                lightIntensity += currentLightIntensity;
            }
        }

        // Add HDRI lighting
        float3 rayDirection = surfaceNormal;
        float seed = fabs(pointOnSurface.x + pointOnSurface.y + pointOnSurface.z) + 0.5773f;
        for (int iteration=1; iteration <= skyLightSamples; iteration++)
        {
            rayDirection = roughen(
                surfaceNormal,
                saturate(1.0f - surface.x - surface.y),
                iteration * seed / skyLightSamples
            );
            currentLightIntensity = lightIntensityOnSurface(
                pointOnSurface,
                surfaceNormal,
                rayDirection,
                softenSkyLightShadows * 100,
                skyLightGain,
                0.0f,
                skyLightShadowHardness
            );
            const float4 skyLightColour = readSkyLightValue(rayDirection);
            lightColour = blend(
                skyLightColour,
                lightColour,
                saturate(length(skyLightColour) * currentLightIntensity.x * currentLightIntensity.y)
            );
            lightIntensity += currentLightIntensity / (float) skyLightSamples;
            seed += fabs(
                rayDirection.x + rayDirection.y + rayDirection.z
            ) + 0.5773f / (float) iteration;
        }

        lightColour = saturate(lightColour);
        return saturate(lightIntensity.x * lightIntensity.y);
    }


    float getHazeAmount(const float distance)
    {
        return hazeAmount * saturate((distance - hazeStart) / hazeDistance);
    }


    /**
     * Estimate the surface normal at the closest point on the closest
     * object to a point
     *
     * @arg point: The point near which to get the surface normal
     *
     * @returns: The normalized surface normal
     */
    float3 estimateSurfaceNormal(const float3 &point) {
        float4 colour;
        float4 surface;

        const float epsilon = hitTolerance;

        const float3 offset0 = 0.5773f * float3(1, -1, -1);
        const float3 offset1 = 0.5773f * float3(-1, -1, 1);
        const float3 offset2 = 0.5773f * float3(-1, 1, -1);
        const float3 offset3 = 0.5773f * float3(1, 1, 1);

        return normalize(
            offset0
            * getMinDistanceToObjectInScene(
                point + offset0 * epsilon,
                colour,
                surface
            )
            + offset1
            * getMinDistanceToObjectInScene(
                point + offset1 * epsilon,
                colour,
                surface
            )
            + offset2
            * getMinDistanceToObjectInScene(
                point + offset2 * epsilon,
                colour,
                surface
            )
            + offset3
            * getMinDistanceToObjectInScene(
                point + offset3 * epsilon,
                colour,
                surface
            )
        );
    }


    /**
     * March a ray through the scene
     *
     * @returns: The ray colour
     */
    float4 marchRay(
            const float3 &rayOrigin,
            const float3 &rayDirection,
            const int numBounces,
            const float rayDistance)
    {
        const int lastRay = min(MAX_RAYS_PER_SUBPIXEL, maxRaysPerSubPixel);

        // rayOrigin, rayDirection, rayIntensity, index of refraction
        float rays[MAX_RAYS_PER_SUBPIXEL][3 + 3 + 1 + 1];
        rays[0][0] = rayOrigin.x;
        rays[0][1] = rayOrigin.y;
        rays[0][2] = rayOrigin.z;

        rays[0][3] = rayDirection.x;
        rays[0][4] = rayDirection.y;
        rays[0][5] = rayDirection.z;

        rays[0][6] = 1.0f;

        rays[0][7] = refractiveIndex;

        int numRays = 1;
        int currentRayIndex = 0;

        float4 colour;
        float4 surface;

        float4 rayColour = float4(0);
        float4 lightColour = float4(0);

        float lastStepDistance = 1.0f;

        int bounces = 0;
        int iterations = 1;
        while (currentRayIndex < numRays)
        {
            float lightIntensity = 1;

            float distanceTravelled = 0;

            float3 origin = float3(
                rays[currentRayIndex][0],
                rays[currentRayIndex][1],
                rays[currentRayIndex][2]
            );
            const float3 direction = float3(
                rays[currentRayIndex][3],
                rays[currentRayIndex][4],
                rays[currentRayIndex][5]
            );
            const float rayIntensity = rays[currentRayIndex][6];

            bool madeContact = false;

            while (distanceTravelled < rayDistance && iterations <= maxRaySteps)
            {
                const float signedStepDistance = getMinDistanceToObjectInScene(
                    origin,
                    colour,
                    surface
                );
                const float stepDistance = fabs(signedStepDistance);

                distanceTravelled += stepDistance;
                origin += direction * stepDistance;

                if (stepDistance < hitTolerance * distanceTravelled)
                {
                    const float3 surfacePosition = origin - direction * hitTolerance;
                    float3 surfaceNormal = sign(lastStepDistance) * estimateSurfaceNormal(
                        surfacePosition
                    );

                    if (surface.w > 0.0f)
                    {
                        surfaceNormal = roughen(
                            surfaceNormal,
                            surface.w,
                            (iterations * distanceTravelled + stepDistance)
                            * (surfaceNormal.x + surfaceNormal.y + surfaceNormal.z)
                        );
                    }

                    if (outputType > 0)
                    {
                        if (outputType == 1)
                        {
                            return float4(
                                surfacePosition.x,
                                surfacePosition.y,
                                surfacePosition.z,
                                1
                            );
                        }
                        if (outputType == 2)
                        {
                            return float4(
                                surfaceNormal.x,
                                surfaceNormal.y,
                                surfaceNormal.z,
                                1
                            );
                        }
                        if (outputType == 3)
                        {
                            return float4(
                                distanceTravelled,
                                0,
                                0,
                                1
                            );
                        }
                    }
                    bounces++;

                    lightIntensity = computeLightIntensityOnSurface(
                        origin,
                        surfaceNormal,
                        surface,
                        lightColour
                    );

                    rayColour = blend(
                        iterGlowColour,
                        blend(
                            hazeColour,
                            blend(
                                lightColour * colour,
                                rayColour,
                                rayIntensity * (1 - surface.x - surface.y) * lightIntensity
                            ),
                            getHazeAmount(distanceTravelled)
                        ),
                        saturate(iterGlowAmount * iterations)
                    );

                    if (bounces >= numBounces)
                    {
                        rayColour.w = 1.0f;
                        return rayColour;
                    }

                    const float incidentRefractiveIndex = rays[currentRayIndex][7];
                    const float refractedRefractiveIndex = colour.w;
                    const float reflectivity = schlickReflectionCoefficient(
                        direction,
                        surfaceNormal,
                        incidentRefractiveIndex,
                        refractedRefractiveIndex
                    );
                    const float refraction = saturate(surface.y * (1 - reflectivity));
                    float intensity = rayIntensity * refraction;
                    float reflection = surface.x;

                    if (surface.y > 0.0f && numRays < lastRay && intensity > hitTolerance)
                    {
                        reflection = clamp(reflection + reflectivity, 0.0f, 1.0f - refraction);

                        const float3 refractedDirection = refractRayThroughSurface(
                            direction,
                            surfaceNormal,
                            incidentRefractiveIndex,
                            refractedRefractiveIndex
                        );
                        const float3 refractedOrigin = offsetPoint(
                            surfacePosition,
                            refractedDirection - surfaceNormal,
                            2.0f * hitTolerance + stepDistance
                        );

                        rays[numRays][0] = refractedOrigin.x;
                        rays[numRays][1] = refractedOrigin.y;
                        rays[numRays][2] = refractedOrigin.z;

                        rays[numRays][3] = refractedDirection.x;
                        rays[numRays][4] = refractedDirection.y;
                        rays[numRays][5] = refractedDirection.z;

                        rays[numRays][6] = intensity;

                        rays[numRays][7] = refractedRefractiveIndex;

                        numRays++;
                    }

                    intensity = rayIntensity * reflection;
                    if (reflection > 0.0f && numRays < lastRay && intensity > hitTolerance)
                    {
                        const float3 reflectedDirection = reflectRayOffSurface(
                            direction,
                            surfaceNormal
                        );
                        const float3 reflectedOrigin = offsetPoint(
                            origin,
                            reflectedDirection + surfaceNormal,
                            hitTolerance
                        );

                        rays[numRays][0] = reflectedOrigin.x;
                        rays[numRays][1] = reflectedOrigin.y;
                        rays[numRays][2] = reflectedOrigin.z;

                        rays[numRays][3] = reflectedDirection.x;
                        rays[numRays][4] = reflectedDirection.y;
                        rays[numRays][5] = reflectedDirection.z;

                        rays[numRays][6] = intensity;

                        rays[numRays][7] = incidentRefractiveIndex;

                        numRays++;
                    }

                    madeContact = true;
                    break;
                }

                lastStepDistance = signedStepDistance;
                iterations++;
            }

            if (outputType > 0)
            {
                return float4(0);
            }

            if (!madeContact)
            {
                rayColour = blend(
                    blend(
                        iterGlowColour,
                        blend(
                            hazeColour,
                            saturate(readSkyValue(direction)),
                            getHazeAmount(distanceTravelled)
                        ),
                        saturate(iterGlowAmount * iterations)
                    ),
                    rayColour,
                    rayIntensity
                );
            }

            currentRayIndex++;
        }

        rayColour.w = bounces > 0;
        return rayColour;
    }


    /**
     * Compute a raymarched pixel value
     */
    void process(int2 pos)
    {
        float4 resultPixel(0, 0, 0, 0);

        float2 pixelLocation = float2(pos.x, pos.y);

        float2 pixelOffset;
        for (
            pixelOffset.x = 0.0f;
            pixelOffset.x < 1.0f;
            pixelOffset.x += subdividedPixelSize
        ) {
            for (
                pixelOffset.y = 0.0f;
                pixelOffset.y < 1.0f;
                pixelOffset.y += subdividedPixelSize
            ) {
                // Generate a ray from the camera
                float3 rayOrigin;
                float3 rayDirection;
                createCameraRay(
                    cameraWorldMatrix,
                    inverseCameraProjectionMatrix,
                    pixelsToUV(
                        pixelLocation + pixelOffset,
                        float2(formatWidth, formatHeight)
                    ),
                    rayOrigin,
                    rayDirection
                );

                resultPixel += marchRay(
                    rayOrigin,
                    rayDirection,
                    bouncesPerRay,
                    maxRayDistance
                );
            }
        }

        dst() = resultPixel / numSubPixels;
    }
};
