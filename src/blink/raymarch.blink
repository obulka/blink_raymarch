//#include "colour.h"
//#include "mmath.h"
//#include "sdfs.h"


kernel RayMarchKernel : ImageComputationKernel<ePixelWise>
{
    // the input for format, process called once per pixel
    Image<eRead, eAccessPoint, eEdgeNone> bg;

    // the skybox in latlong format
    Image<eRead, eAccessRandom, eEdgeNone> skyBox;


    // the shape positons.xyz
    Image<eRead, eAccessRandom, eEdgeNone> positions;

    // the shape rotations (TODO)
    Image<eRead, eAccessRandom, eEdgeNone> rotations;

    // the shape scales.xyz (some shapes may not use all channels)
    Image<eRead, eAccessRandom, eEdgeNone> scales;

    // the shape colours.xyz
    Image<eRead, eAccessRandom, eEdgeNone> colours;


    // shape type.x, operation.y, numChildren.z, blend strength.w
    // x in [0, 1) sphere
    // x in [1, 2) rectangular prism
    // x in [2, 3) cylinder
    // x in [3, 4) triangular prism
    // x in [4, inf) torus
    Image<eRead, eAccessRandom, eEdgeNone> shapeProperties;

    // reflection.x, transmission.y, emission.z, roughness.w (TODO)
    Image<eRead, eAccessRandom, eEdgeNone> surfaceProperties;


    // the input directional lights direction.xyz intensity.w
    Image<eRead, eAccessRandom, eEdgeNone> lights;

    // colour.xyz, type.w
    // w in [0, 1) = directional, [1, inf) = point
    Image<eRead, eAccessRandom, eEdgeNone> lightProperties;

    // the output image
    Image<eWrite> dst;


    param:
        // These parameters are made available to the user.

        // Camera params
        float focalLength;
        float horizontalAperture;
        float nearPlane;
        float farPlane;
        float4x4 cameraWorldMatrix;

        // Image params
        float formatWidth;
        float formatHeight;

        float skyBoxOffsetAngle;
        int skyFormatWidth;
        int skyFormatHeight;

        // Ray params
        int subdivisions;
        int maxBounces;
        float maxRayDistance;
        float hitTolerance;

        // Shader params
        float intensityInShadow;
        int raysPerPixel;
        float rayOffset;

        // Scene params
        // Shape Textures
        int objectTextureHeight;
        int objectTextureWidth;

        // Light textures
        int lightTextureHeight;
        int lightTextureWidth;

    local:
        // These local variables are not exposed to the user.

        float fieldOfView;
        float4x4 cameraProjectionMatrix;
        float4x4 inverseCameraProjectionMatrix;
        float3 cameraPosition;
        float aspect;

        int bouncesPerRay;

        int numSubPixels;
        float subdividedPixelSize;

        float2 skyBoxPixelSize;
        float skyBoxOffsetRadians;


    // In define(), parameters can be given labels and default values.
    void define()
    {
        // Camera params
        defineParam(focalLength, "Focal Length", 50.0f);
        defineParam(horizontalAperture, "Horizontal Aperture", 24.576f);
        defineParam(nearPlane, "Near Plane", 0.1f);
        defineParam(farPlane, "Far Plane", 10000.0f);
        defineParam(
            cameraWorldMatrix,
            "Camera World Matrix",
            float4x4(
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            )
        );

        // Image params
        defineParam(formatHeight, "Screen Height", 2160.0f);
        defineParam(formatWidth, "Screen Width", 3840.0f);
        defineParam(skyBoxOffsetAngle, "SkyBox Offset Angle", 0.0f);
        defineParam(skyFormatHeight, "SkyBox Height", 1024);
        defineParam(skyFormatWidth, "SkyBox Width", 2048);

        // Ray params
        defineParam(subdivisions, "Pixel Subdivisions", 0);
        defineParam(maxRayDistance, "Max Ray Distance", 1000.0f);
        defineParam(maxBounces, "Max Bounces", 1);
        defineParam(hitTolerance, "Hit Tolerance", 0.001f);

        // Shader params TODO make these surface spawn rays
        defineParam(intensityInShadow, "Intensity in Shadows", 1.0f);
        defineParam(raysPerPixel, "Rays Per Pixel", 1);
        defineParam(rayOffset, "Ray Offset", 0.0001f);

        // Scene params

        // Shape Counts
        defineParam(objectTextureHeight, "Object Texture Height", 0);
        defineParam(objectTextureWidth, "Object Texture Width", 0);

        // Light Counts
        defineParam(lightTextureHeight, "Directional Light Texture Height", 0);
        defineParam(lightTextureWidth, "Directional Light Texture Width", 0);
    }


    // The init() function is run before any calls to process().
    // Local variables can be initialized here.
    void init()
    {
        //formatWidth = formatWidth == 0 ? 1 : formatWidth;
        //focalLength = focalLength == 0 ? 1 : focalLength;
        //aspect = aspect == 0 ? 1 : aspect;
        //horizontalAperture = horizontalAperture == 0 ? 1 : horizontalAperture;
        //rayOffset = rayOffset == 0 ? 0.000001 : rayOffset;

        bouncesPerRay = maxBounces <= 0 ? 1 : maxBounces;

        float farMinusNear = farPlane - nearPlane;

        // TODO use angles to allow -ve focal length like for latlongs
        aspect = formatHeight / formatWidth;
        fieldOfView = 2 * atan(1 / focalLength);
        cameraProjectionMatrix = float4x4(
            2 * focalLength / horizontalAperture, 0, 0, 0,
            0, 2 * focalLength / horizontalAperture / aspect, 0, 0,
            0, 0, -(farPlane + nearPlane) / farMinusNear, -2 * (farPlane * nearPlane) / farMinusNear,
            0, 0, -1, 0
        );
        invert4x4(cameraProjectionMatrix, inverseCameraProjectionMatrix);
        positionFromWorldMatrix(cameraWorldMatrix, cameraPosition);

        int subPixelDivisions = pow(2, abs(subdivisions));
        subdividedPixelSize = 1.0f / (float) subPixelDivisions;
        numSubPixels = pow(subPixelDivisions, 2);

        skyBoxPixelSize = float2(skyFormatWidth / (2 * PI), skyFormatHeight / PI);
        skyBoxOffsetRadians = skyBoxOffsetAngle * PI / 180.0f;
    }

    /**
     * Get the value of sky the ray would hit at infinite distance
     */
    float4 readSkyValue(float3 rayDirection)
    {
        float rayAnglePhi = fmod(acos(rayDirection.y), PI);
        rayAnglePhi += PI * (rayAnglePhi < 0);

        float rayAngleTheta = fmod(
            atan2(rayDirection.z, rayDirection.x) + skyBoxOffsetRadians,
            2 * PI
        );
        rayAngleTheta += 2 * PI * (rayAngleTheta < 0);

        SampleType(skyBox) skyBoxPixel = bilinear(
            skyBox,
            skyBoxPixelSize.x * rayAngleTheta,
            skyFormatHeight - (skyBoxPixelSize.y * rayAnglePhi)
        );

        return skyBoxPixel;
    }


    //
    // Signed Distance Functions
    //


    /**
     * Compute the signed distance from a point to a sphere
     *
     * @arg position: The point to get the distance to from the object
     * @arg centre: The object centre
     * @arg radius: The radius of the sphere
     *
     * @returns: The minimum distance from the point to the shape
     */
    float distanceToSphere(
            const float3 &position,
            const float3 &centre,
            const float radius)
    {
        return length(centre - position) - radius;
    }

    /**
     * Compute the signed distance from a point to a rectangular prism
     *
     * @arg position: The point to get the distance to from the object
     * @arg centre: The object centre
     * @arg size: The length, width, and depth of the prism
     *
     * @returns: The minimum distance from the point to the shape
     */
    float distanceToRectangularPrism(
            const float3 &position,
            const float3 &centre,
            const float3 &size)
    {
        float3 boundingSphereVector = fabs(position - centre) - size;
        float ud = length(max(boundingSphereVector, float3(0, 0, 0)));
        float n = max(
            max(min(boundingSphereVector.x, 0.0f), min(boundingSphereVector.y, 0.0f)),
            min(boundingSphereVector.z, 0.0f)
        );

        return ud + n;
    }

    /**
     * Compute the signed distance from a point to a torus
     *
     * @arg position: The point to get the distance to from the object
     * @arg centre: The object centre
     * @arg radii: The inner and outer radii of the torus
     *
     * @returns: The minimum distance from the point to the shape
     */
    float distanceToTorus(
            const float3 &position,
            const float3 &centre,
            const float2 &radii)
    {
        float3 centreVector = position - centre;
        float2 centreXZ = float2(centreVector.x, centreVector.z);
        float2 inner = float2(
            length(centreXZ) - radii.y,
            position.y - centre.y
        );

        return length(inner) - radii.x;
    }

    /**
     * Compute the signed distance from a point to a triangular prism
     *
     * @arg position: The point to get the distance to from the object
     * @arg centre: The object centre
     * @arg size: The height and depth of the prism
     *
     * @returns: The minimum distance from the point to the shape
     */
    float distanceToTriangularPrism(
            const float3 &position,
            const float3 &centre,
            const float2 &size)
    {
        float3 centreVector = fabs(position - centre);

        return max(
            centreVector.z - size.y,
            max(
                centreVector.x * 0.866025f + position.y * 0.5f,
                -position.y
            ) - size.x * 0.5f
        );
    }

    /**
     * Compute the signed distance from a point to a cylinder
     *
     * @arg position: The point to get the distance to from the object
     * @arg centre: The object centre
     * @arg size: The height and radius of the cylinder
     *
     * @returns: The minimum distance from the point to the shape
     */
    float distanceToCylinder(
            const float3 &position,
            const float3 &centre,
            const float2 &size)
    {
        float3 centreVector = fabs(position - centre);

        float2 distanceToXZ = float2(centreVector.x, centreVector.z);

        float2 d = fabs(float2(length(distanceToXZ), centreVector.y)) - size;

        return length(max(d, float2(0, 0))) + min(max(d.x, d.y), 0.0f);
    }


    /**
     * Compute the signed distance from a point to a mandelbulb
     *
     * @arg position: The point to get the distance to from the object
     *
     * @returns: The minimum distance from the point to the shape
     */
    float distanceToMandelbulb(const float3 &position, const float power) {
        float3 z = position;
        float dr = 1;
        float r = 0;

        for (int i = 0; i < 15; i++) {
            r = length(z);

            if (r > 2) {
                break;
            }

            // convert to polar coordinates
            float theta = acos(z.z / r);
            float phi = atan2(z.y, z.x);
            dr = pow(r, power - 1.0f) * power * dr + 1.0f;

            // scale and rotate the point
            float zr = pow(r, power);
            theta = theta * power;
            phi = phi * power;

            // convert back to cartesian coordinates
            z = zr * float3(
                sin(theta) * cos(phi),
                sin(phi) * sin(theta),
                cos(theta)
            );
            z += position;
        }

        return 0.5f * log(r) * r / dr;
    }


    //
    // Matrix and vector math operations
    //


    /**
     * Saturate a value ie. clamp between 0 and 1
     *
     * @args value: The value to saturate
     *
     * @returns: The clamped value
     */
    float saturate(float value)
    {
        return clamp(value, 0.0f, 1.0f);
    }


    /**
     * Get the position component of a world matrix.
     *
     * @arg worldMatrix: The world matrix
     * @arg position: The location to store the position
     */
    void positionFromWorldMatrix(const float4x4 &worldMatrix, float3 &position)
    {
        position = float3(
            worldMatrix[0][3],
            worldMatrix[1][3],
            worldMatrix[2][3]
        );
    }


    /**
     * Multiply a 4d vector by a 4x4 matrix.
     *
     * @arg m: The matrix that will transform the vector
     * @arg v: The vector to transform
     * @arg out: The location to store the resulting vector
     */
    void matmul(const float4x4 &m, const float4 &v, float4 &out)
    {
        for (int i=0; i < 4; i++)
        {
            out[i] = 0;

            for (int j=0; j < 4; j++)
            {
                out[i] += m[i][j] * v[j];
            }
        }
    }


    /**
     * Invert a 4x4 matrix
     *
     * @arg m: The matrix to invert
     * @arg invOut: The location to store the inverted matrix
     *
     * @returns: true if it was possible to invert the matrix, flase otherwise
     */
    bool invert4x4(const float4x4 &m, float4x4 &invOut)
    {
        float4x4 inv;
        float det;

        inv[0][0] =
            m[1][1]  * m[2][2] * m[3][3] - 
            m[1][1]  * m[2][3] * m[3][2] - 
            m[2][1]  * m[1][2]  * m[3][3] + 
            m[2][1]  * m[1][3]  * m[3][2] +
            m[3][1] * m[1][2]  * m[2][3] - 
            m[3][1] * m[1][3]  * m[2][2];

        inv[1][0] =
            -m[1][0]  * m[2][2] * m[3][3] + 
            m[1][0]  * m[2][3] * m[3][2] + 
            m[2][0]  * m[1][2]  * m[3][3] - 
            m[2][0]  * m[1][3]  * m[3][2] - 
            m[3][0] * m[1][2]  * m[2][3] + 
            m[3][0] * m[1][3]  * m[2][2];

        inv[2][0] =
            m[1][0]  * m[2][1] * m[3][3] - 
            m[1][0]  * m[2][3] * m[3][1] - 
            m[2][0]  * m[1][1] * m[3][3] + 
            m[2][0]  * m[1][3] * m[3][1] + 
            m[3][0] * m[1][1] * m[2][3] - 
            m[3][0] * m[1][3] * m[2][1];

        inv[3][0] =
            -m[1][0]  * m[2][1] * m[3][2] + 
            m[1][0]  * m[2][2] * m[3][1] +
            m[2][0]  * m[1][1] * m[3][2] - 
            m[2][0]  * m[1][2] * m[3][1] - 
            m[3][0] * m[1][1] * m[2][2] + 
            m[3][0] * m[1][2] * m[2][1];

        inv[0][1] =
            -m[0][1]  * m[2][2] * m[3][3] + 
            m[0][1]  * m[2][3] * m[3][2] + 
            m[2][1]  * m[0][2] * m[3][3] - 
            m[2][1]  * m[0][3] * m[3][2] - 
            m[3][1] * m[0][2] * m[2][3] + 
            m[3][1] * m[0][3] * m[2][2];

        inv[1][1] =
            m[0][0]  * m[2][2] * m[3][3] - 
            m[0][0]  * m[2][3] * m[3][2] - 
            m[2][0]  * m[0][2] * m[3][3] + 
            m[2][0]  * m[0][3] * m[3][2] + 
            m[3][0] * m[0][2] * m[2][3] - 
            m[3][0] * m[0][3] * m[2][2];

        inv[2][1] = 
            m[0][0]  * m[2][1] * m[3][3] + 
            m[0][0]  * m[2][3] * m[3][1] + 
            m[2][0]  * m[0][1] * m[3][3] - 
            m[2][0]  * m[0][3] * m[3][1] - 
            m[3][0] * m[0][1] * m[2][3] + 
            m[3][0] * m[0][3] * m[2][1];

        inv[3][1] =
            m[0][0]  * m[2][1] * m[3][2] - 
            m[0][0]  * m[2][2] * m[3][1] - 
            m[2][0]  * m[0][1] * m[3][2] + 
            m[2][0]  * m[0][2] * m[3][1] + 
            m[3][0] * m[0][1] * m[2][2] - 
            m[3][0] * m[0][2] * m[2][1];

        inv[0][2] =
            m[0][1]  * m[1][2] * m[3][3] - 
            m[0][1]  * m[1][3] * m[3][2] - 
            m[1][1]  * m[0][2] * m[3][3] + 
            m[1][1]  * m[0][3] * m[3][2] + 
            m[3][1] * m[0][2] * m[1][3] - 
            m[3][1] * m[0][3] * m[1][2];

        inv[1][2] =
            -m[0][0]  * m[1][2] * m[3][3] + 
            m[0][0]  * m[1][3] * m[3][2] + 
            m[1][0]  * m[0][2] * m[3][3] - 
            m[1][0]  * m[0][3] * m[3][2] - 
            m[3][0] * m[0][2] * m[1][3] + 
            m[3][0] * m[0][3] * m[1][2];

        inv[2][2] =
            m[0][0]  * m[1][1] * m[3][3] - 
            m[0][0]  * m[1][3] * m[3][1] - 
            m[1][0]  * m[0][1] * m[3][3] + 
            m[1][0]  * m[0][3] * m[3][1] + 
            m[3][0] * m[0][1] * m[1][3] - 
            m[3][0] * m[0][3] * m[1][1];

        inv[3][2] =
            -m[0][0]  * m[1][1] * m[3][2] + 
            m[0][0]  * m[1][2] * m[3][1] + 
            m[1][0]  * m[0][1] * m[3][2] - 
            m[1][0]  * m[0][2] * m[3][1] - 
            m[3][0] * m[0][1] * m[1][2] + 
            m[3][0] * m[0][2] * m[1][1];

        inv[0][3] =
            -m[0][1] * m[1][2] * m[2][3] + 
            m[0][1] * m[1][3] * m[2][2] + 
            m[1][1] * m[0][2] * m[2][3] - 
            m[1][1] * m[0][3] * m[2][2] - 
            m[2][1] * m[0][2] * m[1][3] + 
            m[2][1] * m[0][3] * m[1][2];

        inv[1][3] =
            m[0][0] * m[1][2] * m[2][3] - 
            m[0][0] * m[1][3] * m[2][2] - 
            m[1][0] * m[0][2] * m[2][3] + 
            m[1][0] * m[0][3] * m[2][2] + 
            m[2][0] * m[0][2] * m[1][3] - 
            m[2][0] * m[0][3] * m[1][2];

        inv[2][3] =
            -m[0][0] * m[1][1] * m[2][3] + 
            m[0][0] * m[1][3] * m[2][1] + 
            m[1][0] * m[0][1] * m[2][3] - 
            m[1][0] * m[0][3] * m[2][1] - 
            m[2][0] * m[0][1] * m[1][3] + 
            m[2][0] * m[0][3] * m[1][1];

        inv[3][3] =
            m[0][0] * m[1][1] * m[2][2] - 
            m[0][0] * m[1][2] * m[2][1] - 
            m[1][0] * m[0][1] * m[2][2] + 
            m[1][0] * m[0][2] * m[2][1] + 
            m[2][0] * m[0][1] * m[1][2] - 
            m[2][0] * m[0][2] * m[1][1];

        det = m[0][0] * inv[0][0] + m[0][1] * inv[1][0] + m[0][2] * inv[2][0] + m[0][3] * inv[3][0];

        if (det == 0)
            return false;

        det = 1.0 / det;

        for (int i=0; i < 4; i++)
        {
            for (int j=0; j < 4; j++)
            {
                invOut[i][j] = inv[i][j] * det;
            }
        }

        return true;
    }


    //
    // Colour functions
    //


    float2 smoothMinN(float colour0, float colour1, float blendSize, float exponent)
    {
        float m = 0.5f * pow(
            max(blendSize - fabs(colour0 - colour1), 0.0f) / blendSize,
            exponent
        );

        float s = m * blendSize / exponent;

        return (colour0 < colour1) ? float2(colour0 - s, m) : float2(colour1 - s, m - 1.0f);
    }


    /**
     * Generate a ray out of the camera
     */
    void createCameraRay(float2 pixelLocation, float3 &rayOrigin, float3 &rayDirection)
    {
        float2 uvPosition = float2(
            2 * pixelLocation.x / formatWidth - 1,
            2 * pixelLocation.y / formatHeight - 1
        );
        rayOrigin = cameraPosition;
        float4 direction;
        matmul(
            inverseCameraProjectionMatrix,
            float4(uvPosition.x, uvPosition.y, 0, 1),
            direction
        );
        matmul(
            cameraWorldMatrix,
            float4(direction.x, direction.y, direction.z, 0),
            direction
        );
        rayDirection = normalize(float3(direction.x, direction.y, direction.z));
    }


    //
    // Render Engine
    //


    float distanceToObject(
            const float3 &position,
            const int shapeType,
            const float3 &objectPosition,
            const float3 &scale)
    {
        if (shapeType == 0)
        {
            return distanceToSphere(position, objectPosition, scale.x);
        }
        if (shapeType == 1)
        {
            return distanceToRectangularPrism(position, objectPosition, scale);
        }

        float2 size = float2(scale.x, scale.y);
        if (shapeType == 2)
        {
            return distanceToCylinder(position, objectPosition, size);
        }
        if (shapeType == 3)
        {
            return distanceToTriangularPrism(position, objectPosition, size);
        }
        if (shapeType == 4)
        {
            return distanceToTorus(position, objectPosition, size);
        }

        return distanceToMandelbulb(position, size.x);
    }


    /**
     * Compute the minimum distance to an object in the scene
     */
    float getMinDistanceToObjectInScene(
            const float3 rayOrigin,
            float4 &colour,
            float4 &surface)
    {
        float distance = maxRayDistance;

        for (int i=0; i < objectTextureHeight; i++)
        {
            for (int j=0; j < objectTextureWidth; j++)
            {
                SampleType(positions) position = positions(j, i);
                //SampleType(spheres) rotation = spheres(j, i);
                SampleType(scales) scale = scales(j, i);
                SampleType(shapeProperties) shapeProperty = shapeProperties(j, i);

                float nextDistance = distanceToObject(
                    rayOrigin,
                    (int) shapeProperty.x,
                    float3(position.x, position.y, position.z),
                    float3(scale.x, scale.y, scale.z)
                );

                if (nextDistance < distance)
                {
                    distance = nextDistance;

                    SampleType(colours) surfaceColour = colours(j, i);
                    SampleType(surfaceProperties) surfaceProperty = surfaceProperties(j, i);

                    colour = float4(surfaceColour);
                    surface = float4(surfaceProperty);
                }
            }
        }

        return distance;
    }


    /**
     * Estimate the surface normal at the closest point on the closest
     * object to a point
     *
     * @arg point: The point near which to get the surface normal
     *
     * @returns: The normalized surface normal
     */
    float3 estimateSurfaceNormal(const float3 &point) {
        float4 colour;
        float4 surface;
        return normalize(
            float3(
                getMinDistanceToObjectInScene(
                    float3(
                        point.x + hitTolerance,
                        point.y,
                        point.z
                    ),
                    colour,
                    surface
                ) - getMinDistanceToObjectInScene(
                    float3(
                        point.x - hitTolerance,
                        point.y,
                        point.z
                    ),
                    colour,
                    surface
                ),
                getMinDistanceToObjectInScene(
                    float3(
                        point.x,
                        point.y + hitTolerance,
                        point.z
                    ),
                    colour,
                    surface
                ) - getMinDistanceToObjectInScene(
                    float3(
                        point.x,
                        point.y - hitTolerance,
                        point.z
                    ),
                    colour,
                    surface
                ),
                getMinDistanceToObjectInScene(
                    float3(
                        point.x,
                        point.y,
                        point.z+hitTolerance
                    ),
                    colour,
                    surface
                ) - getMinDistanceToObjectInScene(
                    float3(
                        point.x,
                        point.y,
                        point.z - hitTolerance
                    ),
                    colour,
                    surface
                )
        ));
    }


    float computeShadow(float3 rayOrigin, float3 rayDirection, float distanceToShadePoint)
    {
        float distanceTravelled = 0;
        float4 colour;
        float4 surface;
        while (distanceTravelled < distanceToShadePoint)
        {
            float stepDistance = getMinDistanceToObjectInScene(rayOrigin, colour, surface);

            if (stepDistance < hitTolerance)
            {
                return intensityInShadow;
            }

            rayOrigin += rayDirection * stepDistance;
            distanceTravelled += stepDistance;
        }

        return 1;
    }


    static float3 offsetPoint(
            const float3 &point,
            const float3 &direction,
            const float offset)
    {
        return offset * direction + point;
    }


    void computeDirectionalLightShadow(
        const float3 &pointOnSurface,
        const float3 &surfaceNormal,
        const float3 &light,
        float3 &lightDirection,
        float3 &surfaceOffset,
        float3 &shadowOffsetLightDirection,
        float &distanceToLight)
    {
        lightDirection = -light;
        surfaceOffset = offsetPoint(
            pointOnSurface,
            lightDirection + surfaceNormal,
            hitTolerance
        );
        shadowOffsetLightDirection = lightDirection;

        distanceToLight = maxRayDistance;
    }


    void computePointLightShadow(
        const float3 &pointOnSurface,
        const float3 &surfaceNormal,
        const float3 &light,
        float3 &lightDirection,
        float3 &surfaceOffset,
        float3 &shadowOffsetLightDirection,
        float &distanceToLight)
    {
        lightDirection = light - pointOnSurface;
        surfaceOffset = offsetPoint(
            pointOnSurface,
            lightDirection + surfaceNormal,
            hitTolerance
        );
        shadowOffsetLightDirection = light - surfaceOffset;

        distanceToLight = length(shadowOffsetLightDirection);
    }


    float2 lightIntensityOnSurface(
            const float3 &pointOnSurface,
            const float3 &surfaceNormal,
            const float3 &light,
            const int lightType,
            const float intensity)
    {
        float3 surfaceOffset;

        float distanceToLight;
        float3 lightDirection;
        float3 shadowOffsetLightDirection;
        if (lightType == 0)
        {
            // directional
            computeDirectionalLightShadow(
                pointOnSurface,
                surfaceNormal,
                light,
                lightDirection,
                surfaceOffset,
                shadowOffsetLightDirection,
                distanceToLight
            );
        }
        else
        {
            // point
            computePointLightShadow(
                pointOnSurface,
                surfaceNormal,
                light,
                lightDirection,
                surfaceOffset,
                shadowOffsetLightDirection,
                distanceToLight
            );
        }

        return float2(
            saturate(dot(surfaceNormal, normalize(lightDirection)) * intensity),
            computeShadow(
                surfaceOffset,
                normalize(shadowOffsetLightDirection),
                distanceToLight
            )
        );
    }


    /**
     * Get the intensity of the light on the surface of an object
     *
     *
     */
    float computeLightIntensityOnSurface(const float3 &pointOnSurface, const float3 &surfaceNormal)
    {
        float2 lightIntensity = float2(0, 0);

        for (int i=0; i < lightTextureHeight; i++)
        {
            for (int j=0; j < lightTextureWidth; j++)
            {
                SampleType(lights) light = lights(j, i);
                SampleType(lightProperties) lightProperty = lightProperties(j, i);

                lightIntensity += lightIntensityOnSurface(
                    pointOnSurface,
                    surfaceNormal,
                    float3(light.x, light.y, light.z),
                    (int) lightProperty.w,
                    light.w
                );
            }
        }

        return saturate(lightIntensity.x * lightIntensity.y);
    }


    float3 reflectRayOffSurface(
        const float3 &incidentRayDirection,
        const float3 &surfaceNormalDirection)
    {
        return (
            incidentRayDirection
            - 2 * dot(incidentRayDirection, surfaceNormalDirection) * surfaceNormalDirection
        );
    }

    /**
     * March a ray through the scene
     *
     * @returns: The ray colour
     */
    float4 marchRay(
            const float3 &rayOrigin,
            const float3 &rayDirection,
            const int numBounces,
            const float rayDistance)
    {
        float3 origin = rayOrigin;
        float3 direction = rayDirection;
        float4 colour;
        float4 surface;

        int bounces = 0;
        float distanceTravelled = 0;

        float lightIntensity = 1;

        float4 rayColour = float4(0, 0, 0, 0);

        float rayStrength = 1;
        float colourStrength;

        while (distanceTravelled < rayDistance && rayStrength > 0)
        {
            float stepDistance = getMinDistanceToObjectInScene(origin, colour, surface);
            distanceTravelled += stepDistance;
            origin += direction * stepDistance;

            if (stepDistance < hitTolerance)
            {
                bounces++;

                float3 surfaceNormal = estimateSurfaceNormal(
                    origin - direction * hitTolerance
                );

                lightIntensity = computeLightIntensityOnSurface(
                    origin,
                    surfaceNormal
                );

                colourStrength = rayStrength * (1 - surface.x) * lightIntensity;
                rayColour = colourStrength * colour + (1 - colourStrength) * rayColour;

                if (bounces >= numBounces)
                {
                    return rayColour;
                }

                rayStrength *= surface.x * lightIntensity;

                direction = reflectRayOffSurface(
                    direction,
                    surfaceNormal
                );
                origin = offsetPoint(
                    origin,
                    direction + surfaceNormal,
                    hitTolerance
                );
            }
        }

        // If the ray missed, grab the skybox colour
        float4 skyColour = readSkyValue(direction);
        if (bounces == 0)
        {
            return skyColour;
        }

        colourStrength = rayStrength * lightIntensity;
        rayColour = colourStrength * skyColour + (1 - colourStrength) * rayColour;

        return rayColour;
    }


    /**
     * March rays through the scene
     */
    void marchRays(
            const float3 &rayOrigin,
            const float3 &rayDirection,
            const int numRays,
            const int numBounces,
            const float rayDistance,
            float4 &resultColour)
    {
        float3 direction = rayDirection;

        float3 rayNormal = normalize(float3(direction.y, -direction.x, 0));
        float radialOffset = rayOffset;
        float angularOffset = 0;

        float4 colour;

        for (int rayNum=0; rayNum < numRays; rayNum++)
        {
            resultColour += marchRay(
                rayOrigin,
                direction,
                numBounces,
                rayDistance
            );

            // Update the ray direction to send a scattered cluster of rays
            // TODO these shouldnt diverge more and more the more rays you add
            rayNormal = (
                cos(angularOffset)
                * rayNormal
                + sin(angularOffset)
                * cross(direction, rayNormal)
            );

            direction = radialOffset * rayNormal + rayDirection;

            angularOffset = 90 * (1 - 0.5 * ((rayNum % 4) == 0));
            radialOffset += rayOffset * ((rayNum % 8) == 0);
        }

        // Normalize the output after multiple rays
        resultColour /= numRays;
    }


    /**
     * Compute a raymarched pixel value
     */
    void process(int2 pos)
    {
        float4 resultPixel(0, 0, 0, 0);

        float2 pixelLocation = float2(pos.x, pos.y);

        float2 pixelOffset;
        for (
            pixelOffset.x = 0.0f;
            pixelOffset.x < 1.0f;
            pixelOffset.x += subdividedPixelSize
        ) {
            for (
                pixelOffset.y = 0.0f;
                pixelOffset.y < 1.0f;
                pixelOffset.y += subdividedPixelSize
            ) {
                // Generate a ray from the camera
                float3 rayOrigin;
                float3 rayDirection;
                createCameraRay(pixelLocation + pixelOffset, rayOrigin, rayDirection);

                marchRays(
                    rayOrigin,
                    rayDirection,
                    raysPerPixel,
                    bouncesPerRay,
                    maxRayDistance,
                    resultPixel
                );
            }
        }

        dst() = resultPixel / numSubPixels;
    }
};
