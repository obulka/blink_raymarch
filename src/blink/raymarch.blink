#include "camera.h"
#include "lights.h"
#include "mmath.h"
#include "sdfs.h"
#include "sdfTransforms.h"
#include "sdTransforms.h"


kernel RayMarchKernel : ImageComputationKernel<ePixelWise>
{
    // the input for format, process called once per pixel
    Image<eRead, eAccessPoint, eEdgeNone> bg;

    // the skybox in latlong format
    Image<eRead, eAccessRandom, eEdgeNone> skyBox;


    // the shape positons.xyz, scale.w
    Image<eRead, eAccessRandom, eEdgeNone> positions;

    // the shape rotations.xyz, wall thickness.w
    Image<eRead, eAccessRandom, eEdgeNone> rotations;

    // the shape dimensions.xyzw (some shapes may not use all channels)
    Image<eRead, eAccessRandom, eEdgeNone> dimensions;

    // the shape colours.xyz
    Image<eRead, eAccessRandom, eEdgeNone> colours;


    // shape type.x, operation.y, numChildren.z, blend strength.w
    Image<eRead, eAccessRandom, eEdgeNone> shapeProperties;

    // repetition params.xyzw
    Image<eRead, eAccessRandom, eEdgeNone> shapeModParameters0;

    // elongation.xyz edgeRadius.w
    Image<eRead, eAccessRandom, eEdgeNone> shapeModParameters1;

    // reflection.x, transmission.y, emission.z, roughness.w (TODO)
    Image<eRead, eAccessRandom, eEdgeNone> surfaceProperties;


    // the input lights direction/position.xyz intensity.w
    Image<eRead, eAccessRandom, eEdgeNone> lights;

    // colour.xyz, type.w
    // w in [0, 1) = directional, [1, inf) = point
    Image<eRead, eAccessRandom, eEdgeNone> lightProperties;

    // the output image
    Image<eWrite> dst;


    param:
        // These parameters are made available to the user.

        // Camera params
        float focalLength;
        float horizontalAperture;
        float nearPlane;
        float farPlane;
        float4x4 cameraWorldMatrix;

        // Image params
        float formatWidth;
        float formatHeight;

        float skyBoxOffsetAngle;
        int skyFormatWidth;
        int skyFormatHeight;

        // Ray params
        int subdivisions;
        int maxBounces;
        float maxRayDistance;
        int maxRaySteps;
        float hitTolerance;
        float shadowBias;

        // Scene params
        // Shape Textures
        int objectTextureHeight;
        int objectTextureWidth;

        // Light textures
        int lightTextureHeight;
        int lightTextureWidth;

        float hazeAmount;
        float hazeStart;
        float hazeDistance;
        float4 hazeColour;

        float iterGlowAmount;
        float4 iterGlowColour;

    local:
        // These local variables are not exposed to the user.

        float4x4 inverseCameraProjectionMatrix;

        int bouncesPerRay;

        int numSubPixels;
        float subdividedPixelSize;

        float2 skyBoxPixelSize;
        float skyBoxOffsetRadians;



    // In define(), parameters can be given labels and default values.
    void define()
    {
        // Camera params
        defineParam(focalLength, "Focal Length", 50.0f);
        defineParam(horizontalAperture, "Horizontal Aperture", 24.576f);
        defineParam(nearPlane, "Near Plane", 0.1f);
        defineParam(farPlane, "Far Plane", 10000.0f);
        defineParam(
            cameraWorldMatrix,
            "Camera World Matrix",
            float4x4(
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            )
        );

        // Image params
        defineParam(formatHeight, "Screen Height", 2160.0f);
        defineParam(formatWidth, "Screen Width", 3840.0f);
        defineParam(skyBoxOffsetAngle, "SkyBox Offset Angle", 0.0f);
        defineParam(skyFormatHeight, "SkyBox Height", 1024);
        defineParam(skyFormatWidth, "SkyBox Width", 2048);

        // Ray params
        defineParam(subdivisions, "Pixel Subdivisions", 0);
        defineParam(maxRayDistance, "Max Ray Distance", 1000.0f);
        defineParam(maxRaySteps, "Max Ray Steps", 128);
        defineParam(maxBounces, "Max Bounces", 1);
        defineParam(hitTolerance, "Hit Tolerance", 0.001f);
        defineParam(shadowBias, "Shadow Bias", 1.0f);

        // Scene params

        // Shape Counts
        defineParam(objectTextureHeight, "Object Texture Height", 0);
        defineParam(objectTextureWidth, "Object Texture Width", 0);

        // Light Counts
        defineParam(lightTextureHeight, "Light Texture Height", 0);
        defineParam(lightTextureWidth, "Light Texture Width", 0);

        defineParam(hazeAmount, "Haze Amount", 0.0f);
        defineParam(hazeStart, "Haze Start", 0.0f);
        defineParam(hazeDistance, "Haze Distance", 1000.0f);
        defineParam(hazeColour, "Haze Colour", float4(1, 1, 1, 1));

        defineParam(iterGlowAmount, "Iter Glow Amount", 0.0f);
        defineParam(iterGlowColour, "Iter Glow Colour", float4(1, 1, 1, 1));
    }


    // The init() function is run before any calls to process().
    // Local variables can be initialized here.
    void init()
    {
        bouncesPerRay = maxBounces <= 0 ? 1 : maxBounces;

        // TODO use angles to allow -ve focal length like for latlongs
        float aspect = aspectRatio(formatHeight, formatWidth);
        float4x4 cameraProjectionMatrix = projectionMatrix(
            focalLength,
            horizontalAperture,
            aspect,
            nearPlane,
            farPlane
        );
        inverseCameraProjectionMatrix = cameraProjectionMatrix.invert();

        int subPixelDivisions = pow(2, abs(subdivisions));
        subdividedPixelSize = 1.0f / (float) subPixelDivisions;
        numSubPixels = pow(subPixelDivisions, 2);

        skyBoxPixelSize = float2(skyFormatWidth / (2 * PI), skyFormatHeight / PI);
        skyBoxOffsetRadians = skyBoxOffsetAngle * PI / 180.0f;
    }


    /**
     * Get the value of sky the ray would hit at infinite distance
     */
    float4 readSkyValue(float3 rayDirection)
    {
        float2 angles = cartesionUnitVectorToSpherical(rayDirection, skyBoxOffsetRadians);

        SampleType(skyBox) skyBoxPixel = bilinear(
            skyBox,
            skyBoxPixelSize.x * angles.x,
            skyFormatHeight - (skyBoxPixelSize.y * angles.y)
        );

        return saturate(skyBoxPixel);
    }


    //
    // Render Engine
    //


    float3 transformRay(
        const float3 &rayOrigin,
        const float3 &position,
        const float3 &rotation,
        const int modifications,
        const float4 &modParameters0,
        const float4 &modParameters1)
    {
        float3x3 rotMatrix;
        float3 transformedRay;
        rotationMatrix(rotation, rotMatrix);
        matmul(
            rotMatrix.invert(),
            rayOrigin - position,
            transformedRay
        );
        performShapeModification(
            modifications,
            modParameters0,
            modParameters1,
            transformedRay
        );

        return transformedRay;
    }


    float getNextDistance(
        const float3 &rayOrigin,
        const int shape,
        const float4 &dimension,
        const float uniformScale,
        const int modifications,
        const float edgeRadius,
        const float wallThickness)
    {
        float nextDistance = distanceToObject(
            rayOrigin / uniformScale,
            shape,
            dimension
        ) * uniformScale;

        return performDistanceModification(
            modifications,
            edgeRadius,
            wallThickness,
            nextDistance
        );
    }


    /**
     * Compute the minimum distance to an object in the scene
     */
    float getMinDistanceToObjectInScene(
            const float3 &rayOrigin,
            float4 &colour,
            float4 &surface)
    {
        float distance = maxRayDistance;

        for (int i=0; i < objectTextureHeight; i++)
        {
            for (int j=0; j < objectTextureWidth; j++)
            {
                SampleType(positions) position = positions(j, i);
                SampleType(rotations) rotation = rotations(j, i);
                SampleType(dimensions) dimension = dimensions(j, i);
                SampleType(shapeProperties) shapeProperty = shapeProperties(j, i);
                SampleType(shapeModParameters0) modParameters0 = shapeModParameters0(j, i);
                SampleType(shapeModParameters1) modParameters1 = shapeModParameters1(j, i);

                const int modifications = (int) shapeProperty.y;
                const float scale = position.w;

                const float3 transformedRay = transformRay(
                    rayOrigin,
                    float3(position.x, position.y, position.z),
                    float3(rotation.x, rotation.y, rotation.z),
                    modifications,
                    modParameters0,
                    modParameters1
                );

                float nextDistance = getNextDistance(
                    transformedRay,
                    (int) shapeProperty.x,
                    dimension,
                    scale,
                    modifications,
                    modParameters1.w,
                    rotation.w
                );

                const int numChildren = (int) shapeProperty.z;
                const float blendStrength = shapeProperty.w;

                // TODO should be able to get rid of this duplication in a clever way
                // maybe cahce the parent values as you compute the child then pop back
                // and allow infinite child depth
                for (int child=j + 1; child < j + 1 + numChildren; child++)
                {
                    SampleType(positions) childPosition = positions(child, i);
                    SampleType(rotations) childRotation = rotations(child, i);
                    SampleType(dimensions) childDimension = dimensions(child, i);
                    SampleType(shapeProperties) childShapeProperty = shapeProperties(child, i);
                    SampleType(shapeModParameters0) childModParameters0 = shapeModParameters0(child, i);
                    SampleType(shapeModParameters1) childModParameters1 = shapeModParameters1(child, i);

                    const int childModifications = (int) childShapeProperty.y;
                    const float childScale = childPosition.w * scale;

                    const float3 childTransformedRay = transformRay(
                        transformedRay,
                        float3(childPosition.x, childPosition.y, childPosition.z),
                        float3(childRotation.x, childRotation.y, childRotation.z),
                        childModifications,
                        childModParameters0,
                        childModParameters1
                    );

                    const float childNextDistance = getNextDistance(
                        childTransformedRay,
                        (int) childShapeProperty.x,
                        childDimension,
                        childScale,
                        childModifications,
                        childModParameters1.w,
                        childRotation.w
                    );

                    nextDistance = performChildInteraction(
                        modifications,
                        childNextDistance,
                        nextDistance,
                        blendStrength
                    );
                }
                j += numChildren;

                if (nextDistance < distance)
                {
                    distance = nextDistance;

                    SampleType(colours) surfaceColour = colours(j, i);
                    SampleType(surfaceProperties) surfaceProperty = surfaceProperties(j, i);

                    colour = float4(surfaceColour);
                    surface = float4(surfaceProperty);
                }
            }
        }

        return distance;
    }


    float computeShadow(
            const float3 &rayDirection,
            const float distanceToShadePoint,
            float3 &rayOrigin)
    {
        float distanceTravelled = 0;
        float4 colour;
        float4 surface;
        int iterations = 0;
        while (distanceTravelled < distanceToShadePoint && iterations < maxRaySteps / 2)
        {
            float stepDistance = getMinDistanceToObjectInScene(rayOrigin, colour, surface);

            if (fabs(stepDistance) < hitTolerance)
            {
                return 0;
            }

            rayOrigin += rayDirection * stepDistance;
            distanceTravelled += stepDistance;
            iterations++;
        }

        return 1;
    }


    float2 lightIntensityOnSurface(
            const float3 &pointOnSurface,
            const float3 &surfaceNormal,
            const float3 &light,
            const int lightType,
            const float intensity)
    {
        float3 surfaceOffset;
        float distanceToLight;
        float3 lightDirection;
        float3 shadowOffsetLightDirection;
        float intensityAtPosition = getLightData(
            pointOnSurface,
            surfaceNormal,
            light,
            lightType,
            intensity,
            hitTolerance,
            maxRayDistance,
            shadowBias,
            distanceToLight,
            surfaceOffset,
            lightDirection,
            shadowOffsetLightDirection
        );

        float normalFactor = dot(surfaceNormal, normalize(lightDirection));

        return saturate(
            normalFactor * float2(
                intensityAtPosition,
                computeShadow(
                    normalize(shadowOffsetLightDirection),
                    distanceToLight,
                    surfaceOffset
                )
            )
        );
    }


    /**
     * Get the intensity of the light on the surface of an object
     *
     *
     */
    float computeLightIntensityOnSurface(const float3 &pointOnSurface, const float3 &surfaceNormal)
    {
        float2 lightIntensity = float2(0, 0);

        for (int i=0; i < lightTextureHeight; i++)
        {
            for (int j=0; j < lightTextureWidth; j++)
            {
                SampleType(lights) light = lights(j, i);
                SampleType(lightProperties) lightProperty = lightProperties(j, i);

                int lightType = (int) lightProperty.w;
                if (lightType < 0)
                {
                    lightIntensity += float2(light.w, 1);
                }
                else
                {
                    lightIntensity += lightIntensityOnSurface(
                        pointOnSurface,
                        surfaceNormal,
                        float3(light.x, light.y, light.z),
                        lightType,
                        light.w
                    );
                }
            }
        }

        return saturate(lightIntensity.x * lightIntensity.y);
    }


    float getHazeAmount(const float distance)
    {
        return hazeAmount * saturate((distance - hazeStart) / hazeDistance);
    }


    /**
     * Estimate the surface normal at the closest point on the closest
     * object to a point
     *
     * @arg point: The point near which to get the surface normal
     *
     * @returns: The normalized surface normal
     */
    float3 estimateSurfaceNormal(const float3 &point) {
        float4 colour;
        float4 surface;
        return normalize(
            float3(
                getMinDistanceToObjectInScene(
                    float3(
                        point.x + hitTolerance,
                        point.y,
                        point.z
                    ),
                    colour,
                    surface
                ) - getMinDistanceToObjectInScene(
                    float3(
                        point.x - hitTolerance,
                        point.y,
                        point.z
                    ),
                    colour,
                    surface
                ),
                getMinDistanceToObjectInScene(
                    float3(
                        point.x,
                        point.y + hitTolerance,
                        point.z
                    ),
                    colour,
                    surface
                ) - getMinDistanceToObjectInScene(
                    float3(
                        point.x,
                        point.y - hitTolerance,
                        point.z
                    ),
                    colour,
                    surface
                ),
                getMinDistanceToObjectInScene(
                    float3(
                        point.x,
                        point.y,
                        point.z+hitTolerance
                    ),
                    colour,
                    surface
                ) - getMinDistanceToObjectInScene(
                    float3(
                        point.x,
                        point.y,
                        point.z - hitTolerance
                    ),
                    colour,
                    surface
                )
        ));
    }


    /**
     * March a ray through the scene
     *
     * @returns: The ray colour
     */
    float4 marchRay(
            const float3 &rayOrigin,
            const float3 &rayDirection,
            const int numBounces,
            const float rayDistance)
    {
        float3 origin = rayOrigin;
        float3 direction = rayDirection;
        float4 colour;
        float4 surface;

        int bounces = 0;
        float distanceTravelled = 0;
        float lastHitDistance = distanceTravelled;

        float lightIntensity = 1;

        float4 rayColour = float4(0, 0, 0, 0);

        float rayStrength = 1;

        int iterations = 1;
        while (distanceTravelled < rayDistance && rayStrength > 0 && iterations <= maxRaySteps)
        {
            float stepDistance = getMinDistanceToObjectInScene(origin, colour, surface);
            distanceTravelled += stepDistance;
            origin += direction * stepDistance;

            if (fabs(stepDistance) < hitTolerance)
            {
                bounces++;

                float3 surfaceNormal = estimateSurfaceNormal(
                    origin - direction * hitTolerance
                );

                lightIntensity = computeLightIntensityOnSurface(
                    origin,
                    surfaceNormal
                );

                rayColour = blend(
                    iterGlowColour,
                    blend(
                        hazeColour,
                        blend(
                            colour,
                            rayColour,
                            rayStrength * (1 - surface.x) * lightIntensity
                        ),
                        getHazeAmount(distanceTravelled - lastHitDistance)
                    ),
                    saturate(iterGlowAmount * iterations)
                );

                if (bounces >= numBounces)
                {
                    rayColour.w = 1.0f;
                    return rayColour;
                }

                rayStrength *= surface.x;

                direction = reflectRayOffSurface(
                    direction,
                    surfaceNormal
                );
                origin = offsetPoint(
                    origin,
                    direction + surfaceNormal,
                    hitTolerance
                );

                lastHitDistance = distanceTravelled;
            }
            iterations++;
        }

        rayColour = blend(
            blend(
                iterGlowColour,
                blend(
                    hazeColour,
                    readSkyValue(direction),
                    getHazeAmount(distanceTravelled - lastHitDistance)
                ),
                saturate(iterGlowAmount * iterations)
            ),
            rayColour,
            rayStrength * lightIntensity
        );
        rayColour.w = bounces > 0;
        return rayColour;
    }


    /**
     * Compute a raymarched pixel value
     */
    void process(int2 pos)
    {
        float4 resultPixel(0, 0, 0, 0);

        float2 pixelLocation = float2(pos.x, pos.y);

        float2 pixelOffset;
        for (
            pixelOffset.x = 0.0f;
            pixelOffset.x < 1.0f;
            pixelOffset.x += subdividedPixelSize
        ) {
            for (
                pixelOffset.y = 0.0f;
                pixelOffset.y < 1.0f;
                pixelOffset.y += subdividedPixelSize
            ) {
                // Generate a ray from the camera
                float3 rayOrigin;
                float3 rayDirection;
                createCameraRay(
                    cameraWorldMatrix,
                    inverseCameraProjectionMatrix,
                    pixelsToUV(
                        pixelLocation + pixelOffset,
                        float2(formatWidth, formatHeight)
                    ),
                    rayOrigin,
                    rayDirection
                );

                resultPixel += marchRay(
                    rayOrigin,
                    rayDirection,
                    bouncesPerRay,
                    maxRayDistance
                );
            }
        }

        dst() = resultPixel / numSubPixels;
    }
};
