kernel RayMarchKernel : ImageComputationKernel<ePixelWise>
{
    Image<eRead, eAccessPoint, eEdgeNone> bg; // the input spheres positions.xyz radius.w
    Image<eRead, eAccessRandom, eEdgeNone> spheres; // the input spheres positions.xyz radius.w
    //Image<eRead, eAccessRandom, eEdgeNone> spheres;

    Image<eWrite> dst; // the output image

    param:
        // These parameters are made available to the user.

        // Camera params
        float focalLength;
        float horizontalAperture;
        float nearPlane;
        float farPlane;
        float4x4 cameraWorldMatrix;

        // Image params
        float formatWidth;
        float formatHeight;

        // Ray params
        float maxRayDistance;
        float hitTolerance;

        // Scene params
        int spheresTextureWidth;
        int spheresTextureHeight;

    local:
        // These local variables are not exposed to the user.
        float fieldOfView;
        float4x4 cameraProjectionMatrix;
        float4x4 inverseCameraProjectionMatrix;
        float3 cameraPosition;
        float aspect;


    // Invert a 4x4 matrix
    bool invert4x4(const float4x4 &m, float4x4 &invOut)
    {
        float4x4 inv;
        float det;

        inv[0][0] =
            m[1][1]  * m[2][2] * m[3][3] - 
            m[1][1]  * m[2][3] * m[3][2] - 
            m[2][1]  * m[1][2]  * m[3][3] + 
            m[2][1]  * m[1][3]  * m[3][2] +
            m[3][1] * m[1][2]  * m[2][3] - 
            m[3][1] * m[1][3]  * m[2][2];

        inv[1][0] =
            -m[1][0]  * m[2][2] * m[3][3] + 
            m[1][0]  * m[2][3] * m[3][2] + 
            m[2][0]  * m[1][2]  * m[3][3] - 
            m[2][0]  * m[1][3]  * m[3][2] - 
            m[3][0] * m[1][2]  * m[2][3] + 
            m[3][0] * m[1][3]  * m[2][2];

        inv[2][0] =
            m[1][0]  * m[2][1] * m[3][3] - 
            m[1][0]  * m[2][3] * m[3][1] - 
            m[2][0]  * m[1][1] * m[3][3] + 
            m[2][0]  * m[1][3] * m[3][1] + 
            m[3][0] * m[1][1] * m[2][3] - 
            m[3][0] * m[1][3] * m[2][1];

        inv[3][0] =
            -m[1][0]  * m[2][1] * m[3][2] + 
            m[1][0]  * m[2][2] * m[3][1] +
            m[2][0]  * m[1][1] * m[3][2] - 
            m[2][0]  * m[1][2] * m[3][1] - 
            m[3][0] * m[1][1] * m[2][2] + 
            m[3][0] * m[1][2] * m[2][1];

        inv[0][1] =
            -m[0][1]  * m[2][2] * m[3][3] + 
            m[0][1]  * m[2][3] * m[3][2] + 
            m[2][1]  * m[0][2] * m[3][3] - 
            m[2][1]  * m[0][3] * m[3][2] - 
            m[3][1] * m[0][2] * m[2][3] + 
            m[3][1] * m[0][3] * m[2][2];

        inv[1][1] =
            m[0][0]  * m[2][2] * m[3][3] - 
            m[0][0]  * m[2][3] * m[3][2] - 
            m[2][0]  * m[0][2] * m[3][3] + 
            m[2][0]  * m[0][3] * m[3][2] + 
            m[3][0] * m[0][2] * m[2][3] - 
            m[3][0] * m[0][3] * m[2][2];

        inv[2][1] = 
            m[0][0]  * m[2][1] * m[3][3] + 
            m[0][0]  * m[2][3] * m[3][1] + 
            m[2][0]  * m[0][1] * m[3][3] - 
            m[2][0]  * m[0][3] * m[3][1] - 
            m[3][0] * m[0][1] * m[2][3] + 
            m[3][0] * m[0][3] * m[2][1];

        inv[3][1] =
            m[0][0]  * m[2][1] * m[3][2] - 
            m[0][0]  * m[2][2] * m[3][1] - 
            m[2][0]  * m[0][1] * m[3][2] + 
            m[2][0]  * m[0][2] * m[3][1] + 
            m[3][0] * m[0][1] * m[2][2] - 
            m[3][0] * m[0][2] * m[2][1];

        inv[0][2] =
            m[0][1]  * m[1][2] * m[3][3] - 
            m[0][1]  * m[1][3] * m[3][2] - 
            m[1][1]  * m[0][2] * m[3][3] + 
            m[1][1]  * m[0][3] * m[3][2] + 
            m[3][1] * m[0][2] * m[1][3] - 
            m[3][1] * m[0][3] * m[1][2];

        inv[1][2] =
            -m[0][0]  * m[1][2] * m[3][3] + 
            m[0][0]  * m[1][3] * m[3][2] + 
            m[1][0]  * m[0][2] * m[3][3] - 
            m[1][0]  * m[0][3] * m[3][2] - 
            m[3][0] * m[0][2] * m[1][3] + 
            m[3][0] * m[0][3] * m[1][2];

        inv[2][2] =
            m[0][0]  * m[1][1] * m[3][3] - 
            m[0][0]  * m[1][3] * m[3][1] - 
            m[1][0]  * m[0][1] * m[3][3] + 
            m[1][0]  * m[0][3] * m[3][1] + 
            m[3][0] * m[0][1] * m[1][3] - 
            m[3][0] * m[0][3] * m[1][1];

        inv[3][2] =
            -m[0][0]  * m[1][1] * m[3][2] + 
            m[0][0]  * m[1][2] * m[3][1] + 
            m[1][0]  * m[0][1] * m[3][2] - 
            m[1][0]  * m[0][2] * m[3][1] - 
            m[3][0] * m[0][1] * m[1][2] + 
            m[3][0] * m[0][2] * m[1][1];

        inv[0][3] =
            -m[0][1] * m[1][2] * m[2][3] + 
            m[0][1] * m[1][3] * m[2][2] + 
            m[1][1] * m[0][2] * m[2][3] - 
            m[1][1] * m[0][3] * m[2][2] - 
            m[2][1] * m[0][2] * m[1][3] + 
            m[2][1] * m[0][3] * m[1][2];

        inv[1][3] =
            m[0][0] * m[1][2] * m[2][3] - 
            m[0][0] * m[1][3] * m[2][2] - 
            m[1][0] * m[0][2] * m[2][3] + 
            m[1][0] * m[0][3] * m[2][2] + 
            m[2][0] * m[0][2] * m[1][3] - 
            m[2][0] * m[0][3] * m[1][2];

        inv[2][3] =
            -m[0][0] * m[1][1] * m[2][3] + 
            m[0][0] * m[1][3] * m[2][1] + 
            m[1][0] * m[0][1] * m[2][3] - 
            m[1][0] * m[0][3] * m[2][1] - 
            m[2][0] * m[0][1] * m[1][3] + 
            m[2][0] * m[0][3] * m[1][1];

        inv[3][3] =
            m[0][0] * m[1][1] * m[2][2] - 
            m[0][0] * m[1][2] * m[2][1] - 
            m[1][0] * m[0][1] * m[2][2] + 
            m[1][0] * m[0][2] * m[2][1] + 
            m[2][0] * m[0][1] * m[1][2] - 
            m[2][0] * m[0][2] * m[1][1];

        det = m[0][0] * inv[0][0] + m[0][1] * inv[1][0] + m[0][2] * inv[2][0] + m[0][3] * inv[3][0];

        if (det == 0)
            return false;

        det = 1.0 / det;

        for (int i=0; i < 4; i++)
        {
            for (int j=0; j < 4; j++)
            {
                invOut[i][j] = inv[i][j] * det;
            }
        }

        return true;
    }

    void matmul(float4x4 m, float4 v, float4 &out)
    {
        for (int i=0; i < 4; i++)
        {
            out[i] = 0;

            for (int j=0; j < 4; j++)
            {
                out[i] += m[i][j] * v[j];
            }
        }
    }

    void positionFromWorldMatrix(float4x4 worldMatrix, float3 &position)
    {
        position = float3(
            worldMatrix[0][3],
            worldMatrix[1][3],
            worldMatrix[2][3]
        );
    }

    // In define(), parameters can be given labels and default values.
    void define()
    {
        // Camera params
        defineParam(focalLength, "Focal Length", 50.0f);
        defineParam(horizontalAperture, "Horizontal Aperture", 24.576f);
        defineParam(nearPlane, "Near Plane", 0.1f);
        defineParam(farPlane, "Far Plane", 10000.0f);
        defineParam(
            cameraWorldMatrix,
            "Camera World Matrix",
            float4x4(
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            )
        );

        // Image params
        defineParam(formatHeight, "Screen Height", 2160.0f);
        defineParam(formatWidth, "Screen Width", 3840.0f);

        // Ray params
        defineParam(maxRayDistance, "Max Ray Distance", 10000.0f);
        defineParam(hitTolerance, "Hit Tolerance", 0.0001f);

        // Scene params
        defineParam(spheresTextureHeight, "Spheres Texture Height", 0);
        defineParam(spheresTextureWidth, "Spheres Texture Width", 0);
    }


    // The init() function is run before any calls to process().
    // Local variables can be initialized here.
    void init()
    {
        // TODO use angles to allow -ve focal length like for latlongs
        aspect = formatHeight / formatWidth;
        fieldOfView = 2 * atan(1 / focalLength);
        cameraProjectionMatrix = float4x4(
            2 * focalLength / horizontalAperture,
            0,
            0,
            0,
            0,
            2 * focalLength / horizontalAperture / aspect,
            0,
            0,
            0,
            0,
            -(farPlane + nearPlane) / (farPlane - nearPlane),
            -2 * (farPlane * nearPlane) / (farPlane - nearPlane),
            0,
            0,
            -1,
            0
        );
        invert4x4(cameraProjectionMatrix, inverseCameraProjectionMatrix);
        positionFromWorldMatrix(cameraWorldMatrix, cameraPosition);
    }


    void createCameraRay(float2 pos, float3 &rayOrigin, float3 &rayDirection)
    {
        rayOrigin = cameraPosition;
        float4 direction;
        matmul(
            inverseCameraProjectionMatrix,
            float4(pos.x, pos.y, 0, 1),
            direction
        );
        matmul(
            cameraWorldMatrix,
            float4(direction.x, direction.y, direction.z, 0),
            direction
        );
        rayDirection = normalize(float3(direction.x, direction.y, direction.z));
    }


    float distanceToSphere(float3 spherePosition, float radius, float3 toPosition) {
        return length(spherePosition - toPosition) - radius;
    }


    float getMinDistanceToObjectInScene(float3 rayOrigin)
    {

        float distance = maxRayDistance;

        for (int i=0; i < spheresTextureHeight; i++)
        {
            for (int j=0; j < spheresTextureWidth; j++)
            {
                SampleType(spheres) sphere = spheres(j, i);
                distance = min(
                    distance,
                    distanceToSphere(
                        float3(sphere.x, sphere.y, sphere.z),
                        sphere.w,
                        rayOrigin
                    )
                );
            }
        }
        return distance;
    }


    void process(int2 pos)
    {
        // Convert to UV coords
        float2 uv = float2(
            2 * pos.x / formatWidth - 1,
            2 * pos.y / formatHeight - 1
        );

        // Read the input to pass through
        SampleType(bg) input = bg();
        float4 resultPixel(input.x, input.y, input.z, input.w);

        // Generate a ray from the camera
        float3 rayOrigin;
        float3 rayDirection;
        createCameraRay(uv, rayOrigin, rayDirection);

        float totalDistance = 0;
        while (totalDistance < maxRayDistance)
        {
            float stepDistance = getMinDistanceToObjectInScene(rayOrigin);
            if (stepDistance <= hitTolerance)
            {
                resultPixel = float4(1, 0, 0, 1);
                break;
            }

            rayOrigin += rayDirection * stepDistance;
            totalDistance += stepDistance;
        }


        dst() = resultPixel;
    }
};
