#! /usr/local/Nuke13.2v2/libnuke-13.2.2.so -nx
#write_info Write1 file:"/home/ob1/software/nuke/dev/raymarch/images/volumetric_caustics/volumetric_caustics.%04d.exr" format:"1280 720 1" chans:":rgba.red:rgba.green:rgba.blue:rgba.alpha:" framerange:"1001 1111" fps:"0" colorspace:"default (linear)" datatype:"32 bit float" transfer:"unknown" views:"main" colorManagement:"Nuke"
version 13.2 v2
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="1976" y="188" w="2504" h="1376" maximized="1" screen="0">
        <splitter orientation="1">
            <split size="40"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="1516" stretch="1"/>
            <splitter orientation="2">
                <split size="783"/>
                <dock id="" activePageId="Viewer.1">
                    <page id="Viewer.2"/>
                    <page id="Viewer.1"/>
                </dock>
                <split size="550"/>
                <dock id="" activePageId="DAG.1" focus="true">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                    <page id="DAG.2"/>
                </dock>
            </splitter>
            <split size="940"/>
            <dock id="" activePageId="Properties.1">
                <page id="Properties.1"/>
                <page id="uk.co.thefoundry.backgroundrenderview.1"/>
            </dock>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name /home/ob1/software/nuke/dev/raymarch/examples/pathmarch_test.nk
 frame 1085
 first_frame 1001
 last_frame 1111
 format "1280 720 0 0 1280 720 1 HD_720"
 colorManagement Nuke
 workingSpaceLUT linear
 monitorLut sRGB
 monitorOutLUT rec709
 int8Lut sRGB
 int16Lut sRGB
 logLut Cineon
 floatLut linear
}
Group {
 inputs 0
 name sdf_noise
 tile_color 0xffffffff
 xpos 857
 ypos 291
 addUserKnob {20 User l "SDF Primitive"}
 addUserKnob {7 size R 1 300}
 size 5
 addUserKnob {4 type M {fBm turbulence}}
 type turbulence
 addUserKnob {13 translation}
 translation {-1 0 0}
 addUserKnob {3 octaves}
 octaves 7
 addUserKnob {7 lacunarity R 1 10}
 lacunarity 4
 addUserKnob {7 gain}
 gain 0.37
 addUserKnob {7 gamma}
 gamma 0.42
 addUserKnob {7 black_point l "black point"}
 black_point 0.01
 addUserKnob {7 white_point l "white point"}
 white_point 1
 addUserKnob {7 lift}
 addUserKnob {6 invert +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {6 diffuse +STARTLINE}
 addUserKnob {6 specular -STARTLINE}
 addUserKnob {6 transmission -STARTLINE}
 addUserKnob {6 emission -STARTLINE}
 addUserKnob {6 specular_roughness l "specular roughness" +STARTLINE}
 addUserKnob {6 transmission_roughness l "transmission roughness" -STARTLINE}
 addUserKnob {6 refractive_index l "refractive index" +STARTLINE}
 addUserKnob {6 scattering +STARTLINE}
 scattering true
 addUserKnob {6 extinction -STARTLINE}
 extinction true
 addUserKnob {26 div0 l "" +STARTLINE}
 addUserKnob {26 info l "" +STARTLINE T "v2.0.0 - (c) Owen Bulka - 2022"}
}
add_layer {sdf_noise_params0 sdf_noise_params0.options sdf_noise_params0.x sdf_noise_params0.y sdf_noise_params0.z}
 Constant {
  inputs 0
  channels sdf_noise_params0
  color {{"(parent.extinction << 11) | (parent.scattering << 10) | (parent.invert << 9) | (parent.specular_roughness << 8) | (parent.transmission_roughness << 7) | (parent.refractive_index << 6) | (parent.emission << 5) | (parent.transmission << 4) | (parent.specular << 3) | (parent.diffuse << 2) | (parent.type << 1) | 1"} {parent.translation.x} {parent.translation.y} {parent.translation.z}}
  format "1 1 0 0 1 1 1 1x1"
  name noise_params0
  xpos 841
  ypos 447
 }
 Dot {
  name Dot3
  xpos 875
  ypos 646
 }
add_layer {sdf_noise_params1 sdf_noise_params1.octaves sdf_noise_params1.lacunarity sdf_noise_params1.gain sdf_noise_params1.gamma}
 Constant {
  inputs 0
  channels sdf_noise_params1
  color {{parent.octaves} {parent.lacunarity} {parent.gain} {parent.gamma}}
  format "1 1 0 0 1 1 1 1x1"
  name noise_params1
  xpos 966
  ypos 447
 }
 Copy {
  inputs 2
  channels all
  name Copy8
  xpos 966
  ypos 714
 }
add_layer {sdf_noise_params2 sdf_noise_params2.size sdf_noise_params2.white_point sdf_noise_params2.black_point sdf_noise_params2.lift}
 Constant {
  inputs 0
  channels sdf_noise_params2
  color {{parent.size} {parent.white_point} {parent.black_point} {parent.lift}}
  format "1 1 0 0 1 1 1 1x1"
  name noise_params2
  xpos 1082
  ypos 449
 }
 Copy {
  inputs 2
  channels all
  name Copy1
  xpos 1082
  ypos 714
 }
 Output {
  name Output1
  xpos 1082
  ypos 826
 }
end_group
Dot {
 name Dot1
 xpos 891
 ypos 368
}
Dot {
 inputs 0
 name Dot2
 xpos 535
 ypos 304
}
push 0
Dot {
 inputs 0
 name Dot6
 xpos 764
 ypos 234
}
Reformat {
 format "2048 1024 0 0 2048 1024 1 2K_LatLong"
 name Reformat1
 xpos 730
 ypos 344
}
Axis2 {
 inputs 0
 rotate {0 -5 0}
 name Axis2
 xpos 625
 ypos 142
}
Camera3 {
 translate {0 0 6}
 focal 19.4
 name Camera1
 xpos 625
 ypos 224
}
Dot {
 name Dot4
 xpos 649
 ypos 306
}
sdf_noise {
 inputs 0
 name sdf_noise1
 xpos 123
 ypos 277
 octaves 8
 lacunarity 5.7
 white_point 0.65
 diffuse true
 specular true
 scattering true
 extinction true
}
Group {
 name sdf_material
 knobChanged "__import__('sdf.material', fromlist='SDFMaterial').SDFMaterial().handle_knob_changed()"
 tile_color 0xffffffff
 xpos 117
 ypos 343
 addUserKnob {20 User l "SDF Primitive"}
 addUserKnob {18 colour l "diffuse colour" t "The diffuse colour of the shape."}
 colour {1 1 1}
 addUserKnob {6 colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 diffuse_use_trap_colour l "use trap colour" t "When enabled the surface of the mandelbox will be coloured algorithmically, rather than using the specified surface colour. However, reducing the surface colour channels will remove colour from the corresponding trap colour channel." -STARTLINE}
 diffuse_use_trap_colour true
 addUserKnob {26 ""}
 addUserKnob {7 specular t "The amount of light that is reflected off the shape's surface. This plus 'transmission' should be less than or equal to one."}
 addUserKnob {7 specular_roughness l "specular roughness" t "The object's surface will scatter the specularly reflected light more the higher this value is."}
 addUserKnob {18 specular_colour l "specular colour" t "The specular colour."}
 specular_colour {0.1 0.7 1}
 addUserKnob {6 specular_colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 specular_use_trap_colour l "use trap colour" t "Use the trap colour for specualrly reflected light." -STARTLINE}
 specular_use_trap_colour true
 addUserKnob {26 ""}
 addUserKnob {7 transmission t "The amount of light that is transmitted through the shape's surface. This plus 'reflection' should be less than or equal to one."}
 addUserKnob {7 transmission_roughness l "transmission roughness" t "The object's surface will scatter the transmitted light more the higher this value is."}
 addUserKnob {7 refractive_index l "refractive index" t "The index of refraction of the object." R 1 4}
 refractive_index 1.33
 addUserKnob {6 do_refraction l "do refraction" -STARTLINE}
 do_refraction true
 addUserKnob {18 extinction_colour l "extinction colour" t "The colour absorbed as light travels through the material."}
 extinction_colour {0.9 0.3 0}
 addUserKnob {6 extinction_colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 extinction_use_trap_colour l "use trap colour" t "Absorb the trap colour during transmission." -STARTLINE}
 extinction_use_trap_colour true
 addUserKnob {7 extinction_coefficient l "extinction coefficient" t "The amount of energy lost as the light travells through the material." R 0 10}
 addUserKnob {18 scattering_colour l "scattering colour"}
 scattering_colour {1 1 1}
 addUserKnob {6 scattering_colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 scattering_use_trap_colour l "use trap colour" t "Scatter the trap colour during transmission." -STARTLINE}
 scattering_use_trap_colour true
 addUserKnob {7 scattering_coefficient l "scattering coefficient"}
 addUserKnob {26 ""}
 addUserKnob {7 emission t "The amount of light emitted by the object. Increase the 'hdri lighting samples' to give it less noise. This is more of a placeholder for when the path marched version is released :)" R 0 100}
 addUserKnob {18 emission_colour l "emission colour" t "The emission colour."}
 emission_colour {1 0.8 0.5}
 addUserKnob {6 emission_colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 emission_use_trap_colour l "use trap colour" t "Use the trap colour for emitted light." -STARTLINE}
 emission_use_trap_colour true
 addUserKnob {26 div0 l "" +STARTLINE}
 addUserKnob {26 info l "" +STARTLINE T "v2.0.0 - (c) Owen Bulka - 2022"}
}
 Input {
  inputs 0
  name noise
  xpos 1170
  ypos 446
 }
add_layer {sdf_colour sdf_colour.colour_r sdf_colour.colour_g sdf_colour.colour_b sdf_colour.colour_a}
 Constant {
  inputs 0
  channels sdf_colour
  color {{parent.colour.r} {parent.colour.g} {parent.colour.b} {parent.specular_roughness}}
  format "1 1 0 0 1 1 1 1x1"
  name diffuse_colour
  xpos 510
  ypos 417
 }
 Dot {
  name Dot3
  xpos 544
  ypos 618
 }
add_layer {sdf_spec_colour sdf_spec_colour.r sdf_spec_colour.g sdf_spec_colour.b sdf_spec_colour.x}
 Constant {
  inputs 0
  channels sdf_spec_colour
  color {{parent.specular_colour.r} {parent.specular_colour.g} {parent.specular_colour.b} {parent.specular}}
  format "1 1 0 0 1 1 1 1x1"
  name spec_colour
  xpos 620
  ypos 417
 }
 Copy {
  inputs 2
  channels all
  name Copy8
  xpos 620
  ypos 674
 }
add_layer {sdf_trans_colour sdf_trans_colour.r sdf_trans_colour.g sdf_trans_colour.b sdf_trans_colour.x}
 Constant {
  inputs 0
  channels sdf_trans_colour
  color {{"(1 - clamp(parent.extinction_colour.r, 0, 1)) * parent.extinction_coefficient"} {"(1 - clamp(parent.extinction_colour.g, 0, 1))  * parent.extinction_coefficient"} {"(1 - clamp(parent.extinction_colour.b, 0, 1))  * parent.extinction_coefficient"} {parent.transmission}}
  format "1 1 0 0 1 1 1 1x1"
  name trans_colour
  xpos 730
  ypos 417
 }
 Copy {
  inputs 2
  channels all
  name Copy9
  xpos 730
  ypos 674
 }
add_layer {sdf_scattering_colour sdf_scattering_colour.red sdf_scattering_colour.green sdf_scattering_colour.blue}
 Constant {
  inputs 0
  channels sdf_scattering_colour
  color {{"parent.scattering_colour.r * parent.scattering_coefficient"} {"parent.scattering_colour.g * parent.scattering_coefficient"} {"parent.scattering_colour.b * parent.scattering_coefficient"} 0}
  format "1 1 0 0 1 1 1 1x1"
  name scattering_colour
  xpos 840
  ypos 417
 }
 Copy {
  inputs 2
  channels all
  name Copy1
  xpos 840
  ypos 674
 }
add_layer {sdf_emm_colour sdf_emm_colour.r sdf_emm_colour.g sdf_emm_colour.b sdf_emm_colour.x}
 Constant {
  inputs 0
  channels sdf_emm_colour
  color {{"parent.emission_colour.r * parent.emission"} {"parent.emission_colour.g * parent.emission"} {"parent.emission_colour.b * parent.emission"} {parent.emission}}
  format "1 1 0 0 1 1 1 1x1"
  name emm_colour
  xpos 950
  ypos 417
 }
 Copy {
  inputs 2
  channels all
  name Copy10
  xpos 950
  ypos 674
 }
add_layer {sdf_surface sdf_surface.reflection sdf_surface.transmission sdf_surface.emission sdf_surface.roughness}
 Constant {
  inputs 0
  channels sdf_surface
  color {{parent.refractive_index} {"(parent.diffuse_use_trap_colour ? 8192 : 0)  | (parent.specular_use_trap_colour ? 16384 : 0) | (parent.extinction_use_trap_colour ? 32768 : 0) | (parent.emission_use_trap_colour ? 65536 : 0) | (parent.scattering_use_trap_colour ? 131072 : 0) | (parent.do_refraction ? 262144 : 0)"} {parent.transmission_roughness} 0}
  format "1 1 0 0 1 1 1 1x1"
  name surface
  xpos 1060
  ypos 417
 }
 Copy {
  inputs 2
  channels all
  name Copy5
  xpos 1060
  ypos 674
 }
 Copy {
  inputs 2
  channels all
  name Copy3
  xpos 1170
  ypos 674
 }
 Output {
  name Output1
  xpos 1170
  ypos 782
 }
end_group
sdf_material {
 inputs 0
 name sdf_material1
 xpos 185
 ypos 193
 emission 1000
}
push 0
push 0
sdf_primitive {
 inputs 3
 name sdf_primitive1
 label sphere
 xpos 353
 ypos 187
 dimension_x 0.4
 dimension_y 10
 dimension_z 4
 translate {-2.5 0 0}
 uniform_scale 0.1
 blend_type union
 blend_strength 0.805
 is_bound true
}
push 0
Group {
 inputs 3
 name Group1
 onCreate "__import__('sdf.primitive', fromlist='SDFPrimitive').SDFPrimitive().handle_node_created()"
 knobChanged "__import__('sdf.primitive', fromlist='SDFPrimitive').SDFPrimitive().handle_knob_changed()"
 tile_color 0xffffffff
 label sphere
 xpos 353
 ypos 337
 addUserKnob {20 User l "SDF Primitive"}
 addUserKnob {4 shape t "The shape of the object." M {sphere ellipsoid "cut sphere" "hollow sphere" "death star" "solid angle" "rectangular prism" "rectangular prism frame" rhombus "triangular prism" cylinder "infinite cylinder" plane capsule cone "infinite cone" "capped cone" "rounded cone" torus "capped torus" link "hexagonal prism" octahedron mandelbulb mandelbox ""}}
 addUserKnob {7 dimension_x l radius t "The radius of the sphere." R 0 10}
 dimension_x 1
 addUserKnob {7 dimension_y l "y radius" t "The radius along the y-axis of the ellipsoid." +HIDDEN R 0 10}
 dimension_y 10
 addUserKnob {7 dimension_z l "z radius" t "The radius along the z-axis of the ellipsoid." +HIDDEN R 0 10}
 dimension_z 4
 addUserKnob {7 dimension_w l "folding limit" t "Clamp the position between +/- this value when performing the box fold. Higher values will result in a denser fractal." +HIDDEN R 0.01 2}
 dimension_w 0.8
 addUserKnob {7 wall_thickness l "wall thickness" t "The thickness of the walls of the shape, if the shape is hollow." +DISABLED}
 wall_thickness 0.01
 addUserKnob {6 hollow t "If enabled, the object will be hollow, with a thickness of 'wall thickness'." -STARTLINE}
 addUserKnob {7 edge_radius l "edge radius" t "This parameter increases the hit tolerance by the specified amount for this specific object, having the effect of rounding off the edges."}
 addUserKnob {6 mirror_x l "mirror x" t "Mirror the shape in the yz-plane." +STARTLINE}
 addUserKnob {6 mirror_y l "mirror y" t "Mirror the shape in the xz-plane." -STARTLINE}
 addUserKnob {6 mirror_z l "mirror z" t "Mirror the shape in the xy-plane." -STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {13 translate t "The translation of the object in its local coordinate space."}
 translate {1 0 0}
 addUserKnob {13 rotate t "The rotation of the object in its local coordinate space."}
 addUserKnob {13 elongation t "The elongation of the object along the respective axes." +DISABLED}
 elongation {0.1 0 0}
 addUserKnob {6 elongate t "Enable the elongation of the object." -STARTLINE}
 addUserKnob {7 uniform_scale l "uniform scale" t "The scale of the object in its local coordinate space, along all axes." R 0 10}
 uniform_scale 1
 addUserKnob {26 div1 l "" +STARTLINE}
 addUserKnob {4 repetition t "Repeat objects in the scene with no extra memory consumption. Note that if the repeated objects overlap some strange things can occur." -STARTLINE M {none finite infinite "" ""}}
 addUserKnob {13 repetition_params l spacing t "The spacing along each positive axis to repeat the objects." +HIDDEN}
 repetition_params {1.1 1.1 100}
 addUserKnob {7 repetition_spacing l spacing t "The spacing between the objects." +HIDDEN R 0 10}
 repetition_spacing 1.1
 addUserKnob {26 ""}
 addUserKnob {4 blend_type l "blend type" t "The type of interaction this object will have with its children.\n    Union: All objects will appear as normal.\n    Subtraction: This object will be subtracted from all of its\n        children, leaving holes.\n    Intersection: Only the region where this object and its\n        children overlap will remain.\n    Smooth Union: All children will smoothly blend together\n        with this object according to the 'blend strength'.\n    Smooth Subtraction:This object will be subtracted from all\n        of its children,  leaving holes that are smoothed\n        according to the 'blend strength'.\n    Smooth Intersection: Only the region where this object\n        and its children overlap will remain, and the remaining\n        regions will be smoothed according to the 'blend\n        strength'." M {union subtraction intersection "smooth union" "smooth subtraction" "smooth intersection" "" "" ""}}
 addUserKnob {7 blend_strength l "blend strength" t "The amount to blend between this and its child objects if one of the 'Smooth' blend types are selected." +DISABLED}
 blend_strength 0.1
 addUserKnob {6 is_bound l "is bound" t "If enabled, this object will act as a bounding volume for all its children. This means that until a ray hits the bounding volume, none of the child object's signed distance fields will be computed. This can vastly improve performance, especially when many complex objects are far from the camera. This option does not always play well with lighting effects that depend on the number of iterations in the computation such as 'ambient occlusion' and 'softened shadows' due to the variation near the surface of the bounding object." +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 info l "" +STARTLINE T "v2.0.0 - (c) Owen Bulka - 2022"}
}
 Input {
  inputs 0
  name siblings
  xpos 1484
  ypos 476
 }
 Dot {
  name Dot2
  xpos 1518
  ypos 904
 }
 Input {
  inputs 0
  name children
  xpos 1357
  ypos 475
  number 1
 }
 Dot {
  name Dot1
  xpos 1391
  ypos 826
 }
 Input {
  inputs 0
  name material
  xpos 1183
  ypos 479
  number 2
 }
add_layer {sdf_position_scale sdf_position_scale.position_x sdf_position_scale.position_y sdf_position_scale.position_z sdf_position_scale.uniform_scale}
 Constant {
  inputs 0
  channels sdf_position_scale
  color {{parent.translate.x} {parent.translate.y} {parent.translate.z} {parent.uniform_scale}}
  format "1 1 0 0 1 1 1 1x1"
  name position_scale
  xpos 387
  ypos 444
 }
 Dot {
  name Dot17
  xpos 421
  ypos 636
 }
add_layer {sdf_rotation_wall_thickness sdf_rotation_wall_thickness.rotation_x sdf_rotation_wall_thickness.rotation_y sdf_rotation_wall_thickness.rotation_z sdf_rotation_wall_thickness.wall_thickness}
 Constant {
  inputs 0
  channels sdf_rotation_wall_thickness
  color {{"parent.rotate.x * pi / 180"} {"parent.rotate.y * pi / 180"} {"parent.rotate.z * pi / 180"} {parent.wall_thickness}}
  format "1 1 0 0 1 1 1 1x1"
  name rotation
  xpos 510
  ypos 446
 }
 Copy {
  inputs 2
  channels all
  name Copy1
  xpos 510
  ypos 715
 }
add_layer {sdf_dimensions sdf_dimensions.dimension_x sdf_dimensions.dimension_y sdf_dimensions.dimension_z sdf_dimensions.dimension_w}
 Constant {
  inputs 0
  channels sdf_dimensions
  color {{parent.dimension_x} {parent.dimension_y} {parent.dimension_z} {parent.dimension_w}}
  format "1 1 0 0 1 1 1 1x1"
  name dimensions
  xpos 647
  ypos 449
 }
 Copy {
  inputs 2
  channels all
  name Copy2
  xpos 647
  ypos 715
 }
add_layer {sdf_shape sdf_shape.shape_type sdf_shape.shape_operations sdf_shape.num_children sdf_shape.blend_strength}
 Constant {
  inputs 0
  channels sdf_shape
  color {{parent.shape} {"parent.repetition | (parent.elongate ? 4 : 0) | (parent.mirror_x ? 8 : 0) | (parent.mirror_y ? 16 : 0) | (parent.mirror_z ? 32 : 0) | (parent.hollow ? 64 : 0) | (parent.blend_type > 0 && !parent.is_bound ? (1 << (parent.blend_type + 6)) : 0) | (parent.is_bound ? 4096 : 0) "} {"parent.sdf_merge.disable ? 0 : parent.sdf_merge.input1.width"} {parent.blend_strength}}
  format "1 1 0 0 1 1 1 1x1"
  name shape
  xpos 789
  ypos 450
 }
 Copy {
  inputs 2
  channels all
  name Copy4
  xpos 789
  ypos 715
 }
add_layer {sdf_shape_mods_0 sdf_shape_mods_0.repetion_x sdf_shape_mods_0.repetion_y sdf_shape_mods_0.repetion_z sdf_shape_mods_0.repetion_w}
 Constant {
  inputs 0
  channels sdf_shape_mods_0
  color {{parent.repetition_params.x} {parent.repetition_params.y} {parent.repetition_params.z} {parent.repetition_spacing}}
  format "1 1 0 0 1 1 1 1x1"
  name shape_mods
  xpos 910
  ypos 452
 }
 Copy {
  inputs 2
  channels all
  name Copy6
  xpos 910
  ypos 715
 }
add_layer {sdf_shape_mods_1 sdf_shape_mods_1.elongation_x sdf_shape_mods_1.elongation_y sdf_shape_mods_1.elongation_z sdf_shape_mods_1.edge_radius}
 Constant {
  inputs 0
  channels sdf_shape_mods_1
  color {{parent.elongation.x} {parent.elongation.y} {parent.elongation.z} {parent.edge_radius}}
  format "1 1 0 0 1 1 1 1x1"
  name shape_mods1
  xpos 1037
  ypos 454
 }
 Copy {
  inputs 2
  channels all
  name Copy7
  xpos 1037
  ypos 715
 }
 Copy {
  inputs 2
  channels all
  name Copy3
  xpos 1183
  ypos 715
 }
 Group {
  inputs 2
  name sdf_merge
  xpos 1183
  ypos 822
  disable {{"!(\[exists parent.input1] && !input1.parent.input1.disable)"}}
  addUserKnob {20 User}
  addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
 }
  Reformat {
   inputs 0
   type "to box"
   box_width 1
   box_height 1
   box_fixed true
   name Reformat1
   xpos -119
   ypos 440
  }
  Input {
   inputs 0
   name Input2
   xpos 158
   ypos -28
   number 1
  }
  Dot {
   name Dot2
   xpos 192
   ypos -2
  }
set N804a9d0 [stack 0]
  Dot {
   name Dot3
   xpos 329
   ypos -2
  }
  Dot {
   name Dot4
   xpos 329
   ypos 391
  }
  Input {
   inputs 0
   name Input1
   xpos 0
   ypos -32
  }
  Dot {
   name Dot1
   xpos 34
   ypos -6
  }
set N805e560 [stack 0]
  Dot {
   name Dot6
   xpos -98
   ypos -6
  }
  Dot {
   name Dot5
   xpos -98
   ypos 336
  }
push $N804a9d0
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop3
   xpos 158
   ypos 69
  }
  Crop {
   box {0 0 {parent.Dot2.width} 1}
   name Crop4
   xpos 158
   ypos 95
  }
  Transform {
   translate {{parent.Dot1.width} 0}
   center {1 0.5}
   name Transform2
   xpos 158
   ypos 121
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop5
   xpos 158
   ypos 167
  }
push $N805e560
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop6
   xpos 0
   ypos 66
  }
  Crop {
   box {0 0 {parent.Dot1.width} 1}
   name Crop7
   xpos 0
   ypos 92
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop8
   xpos 0
   ypos 164
  }
  Merge2 {
   inputs 2
   also_merge all
   name Merge1
   xpos 0
   ypos 262
   disable {{"\[exists parent.input1] ? 0:1"}}
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input1] ? 0:1"}}
   name Switch2
   xpos 0
   ypos 332
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:1"}}
   name Switch1
   xpos 0
   ypos 387
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
   name Switch3
   xpos 0
   ypos 456
  }
  Dot {
   name out_dot
   xpos 36
   ypos 518
  }
  Output {
   name Output1
   xpos 2
   ypos 661
  }
 end_group
 Group {
  inputs 2
  name sdf_merge1
  xpos 1183
  ypos 900
  disable {{"!(\[exists parent.input0] && !(parent.input0.disable && !\[exists parent.input0.input0]))"}}
  addUserKnob {20 User}
  addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
 }
  Reformat {
   inputs 0
   type "to box"
   box_width 1
   box_height 1
   box_fixed true
   name Reformat1
   xpos -119
   ypos 440
  }
  Input {
   inputs 0
   name Input2
   xpos 158
   ypos -28
   number 1
  }
  Dot {
   name Dot2
   xpos 192
   ypos -2
  }
set N8561310 [stack 0]
  Dot {
   name Dot3
   xpos 329
   ypos -2
  }
  Dot {
   name Dot4
   xpos 329
   ypos 391
  }
  Input {
   inputs 0
   name Input1
   xpos 0
   ypos -32
  }
  Dot {
   name Dot1
   xpos 34
   ypos -6
  }
set N8574ea0 [stack 0]
  Dot {
   name Dot6
   xpos -98
   ypos -6
  }
  Dot {
   name Dot5
   xpos -98
   ypos 336
  }
push $N8561310
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop3
   xpos 158
   ypos 69
  }
  Crop {
   box {0 0 {parent.Dot2.width} 1}
   name Crop4
   xpos 158
   ypos 95
  }
  Transform {
   translate {{parent.Dot1.width} 0}
   center {1 0.5}
   name Transform2
   xpos 158
   ypos 121
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop5
   xpos 158
   ypos 167
  }
push $N8574ea0
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop6
   xpos 0
   ypos 66
  }
  Crop {
   box {0 0 {parent.Dot1.width} 1}
   name Crop7
   xpos 0
   ypos 92
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop8
   xpos 0
   ypos 164
  }
  Merge2 {
   inputs 2
   also_merge all
   name Merge1
   xpos 0
   ypos 262
   disable {{"\[exists parent.input1] ? 0:1"}}
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input1] ? 0:1"}}
   name Switch2
   xpos 0
   ypos 332
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:1"}}
   name Switch1
   xpos 0
   ypos 387
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
   name Switch3
   xpos 0
   ypos 456
  }
  Dot {
   name out_dot
   xpos 36
   ypos 518
  }
  Output {
   name Output1
   xpos 2
   ypos 661
  }
 end_group
 Output {
  name Output1
  xpos 1183
  ypos 1002
 }
end_group
Dot {
 name Dot3
 xpos 497
 ypos 450
}
Group {
 inputs 6
 name ray_march
 knobChanged "__import__('sdf.path_march', fromlist='PathMarch').PathMarch().handle_knob_changed()"
 xpos 730
 ypos 446
 addUserKnob {20 User l "Ray March"}
 addUserKnob {3 min_paths_per_pixel l "min paths per pixel"}
 min_paths_per_pixel 1
 addUserKnob {3 max_paths_per_pixel l "max paths per pixel"}
 max_paths_per_pixel 1
 addUserKnob {6 roulette t "Randomly terminate rays with a probability proportional to the remaining strength, or throughput of a ray." +STARTLINE}
 roulette true
 addUserKnob {26 ""}
 addUserKnob {7 ray_distance l "max distance" t "Each ray, once spawned is only allowed to travel this distance before it is culled." R 10 10000}
 ray_distance 50
 addUserKnob {3 max_ray_steps l "max ray steps" t "Limit the number of steps a ray can be marched before it is culled. Shadow rays are given half this number of steps."}
 max_ray_steps 1000
 addUserKnob {3 max_bounces l "max bounces" t "Limits the number of times the rays can intersect an object per subpixel."}
 max_bounces 7
 addUserKnob {7 hit_tolerance l "hit tolerance" t "The ray will be considered to have hit an object when it is within this distance of its surface" R 1e-06 0.01}
 hit_tolerance 0.0001
 addUserKnob {7 shadow_bias l "shadow bias" R 1 5}
 shadow_bias 1
 addUserKnob {7 max_brightness l "max brightness" t "The maximum brightness of a pixel. This protects against overflowing to infinity." R 1 1e+08}
 max_brightness 100000000
 addUserKnob {26 ""}
 addUserKnob {13 seeds t "The seeds used to generate per-pixel noise."}
 seeds {1 2 3}
 addUserKnob {6 enable_dof l "enable depth of field" t "Enable the use of depth of field." +STARTLINE}
 addUserKnob {6 level_of_detail l "dynamic level of detail" +STARTLINE}
 level_of_detail true
 addUserKnob {26 ""}
 addUserKnob {3 max_light_sampling_bounces l "max light sampling bounces"}
 max_light_sampling_bounces 7
 addUserKnob {6 sample_hdri l "sample hdri" t "Sample the HDRI during light sampling." -STARTLINE}
 addUserKnob {6 sample_all_lights l "sample all lights" t "Sample every light in the scene on each bounce." -STARTLINE}
 addUserKnob {7 light_sampling_bias l "light sampling bias"}
 light_sampling_bias 1
 addUserKnob {6 secondary_sampling l "secondary sampling" t "Sample the artificial lights while casting shadow rays for light sampling." +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {3 equiangular_samples l "equi-angular samples"}
 equiangular_samples 7
 addUserKnob {6 sample_hdri_equiangular l "sample hdri" t "Sample the HDRI during equi-angular sampling." -STARTLINE}
 addUserKnob {7 refractive_index l "refractive index" t "The index of refraction of the medium that the camera is currently in." R 1 4}
 refractive_index 1
 addUserKnob {18 extinction_colour l "extinction colour" t "The colour absorbed as light travels through the material that the camera is in."}
 extinction_colour {1 1 1}
 addUserKnob {6 extinction_colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 extinction_coefficient l "extinction coefficient" t "The amount of energy lost as the light travells through the material." R 0 10}
 extinction_coefficient 0.45
 addUserKnob {18 scattering_colour l "scattering colour" t "The colour being scattered."}
 scattering_colour {1 1 1}
 addUserKnob {6 scattering_colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 scattering_coefficient l "scattering coefficient"}
 scattering_coefficient 1
 addUserKnob {26 ""}
 addUserKnob {7 hdri_offset_angle l "hdri offset angle" t "Rotate the hdri image by this amount around the y-axis." R 0 360}
 hdri_offset_angle 90
 addUserKnob {26 ""}
 addUserKnob {6 use_precomputed_irradiance l "use precomputed irradiance" +STARTLINE}
 addUserKnob {7 hdri_lighting_scale l "hdri irradiance scale" R 0.1 1}
 hdri_lighting_scale 0.25
 addUserKnob {3 hdri_irradiance_samples l "hdri irradiance samples"}
 hdri_irradiance_samples 100
 addUserKnob {7 hdri_lighting_blur l "hdri irradiance blur" R 0 10}
 hdri_lighting_blur 10
 addUserKnob {26 ""}
 addUserKnob {3 variance_range l "variance range"}
 variance_range 1
 addUserKnob {26 ""}
 addUserKnob {4 output_type l output t "The AOV type to output.\n\nThe stats AOV has the average number of steps in the red channel, the average number of bounces in the green channel, and the total number of paths that have been traced for a pixel in the blue channel." M {Beauty "World Position" "Local Position" Normal Depth Stats "" "" "" "" "" "" "" ""}}
 addUserKnob {41 format T format_.format}
 addUserKnob {6 latlong l LatLong t "Output a LatLong." +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 info l "" +STARTLINE T "v2.0.0 - (c) Owen Bulka - 2022"}
}
 BackdropNode {
  inputs 0
  name Lights
  xpos -1085
  ypos -1626
  bdwidth 410
  bdheight 851
 }
 BackdropNode {
  inputs 0
  name Objects
  xpos -639
  ypos -1625
  bdwidth 1939
  bdheight 850
 }
 Input {
  inputs 0
  name camera
  xpos 1390
  ypos -1570
  number 1
 }
 Camera {
  projection_mode {{"\[expression \[value the_cam]projection_mode(\[value the_frame])]"}}
  focal {{"\[expression \[value the_cam]focal(\[value the_frame])]"}}
  haperture {{"\[expression \[value the_cam]haperture(\[value the_frame])]"}}
  vaperture {{"\[expression \[value the_cam]vaperture(\[value the_frame])]"}}
  near {{"\[expression \[value the_cam]near(\[value the_frame])]"}}
  far {{"\[expression \[value the_cam]far(\[value the_frame])]"}}
  win_translate {{"\[expression \[value the_cam]win_translate.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_translate.v(\[value the_frame])]"}}
  win_scale {{"\[expression \[value the_cam]win_scale.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_scale.v(\[value the_frame])]"}}
  winroll {{"\[expression \[value the_cam]winroll(\[value the_frame])]"}}
  focal_point {{"\[expression \[value the_cam]focal_point(\[value the_frame])]"}}
  fstop {{"\[expression \[value the_cam]fstop(\[value the_frame])]"}}
  name DummyCam
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if no Camera connected. Can also be used inside of groups and gizmos, as many levels deep as you want :D All using live and super fast TCL.\n\nUpdated v1.1: Now grabs the correct frame too (thanks Erwan Leroy for the idea).\n\nUpdated v1.3: Now accepts Nuke13's Camera3\n\nadrianpueyo.com, 2019-2021"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  xpos 1400
  ypos -1470
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\n#DummyCam v1.3 - Updated 5 May 2021.\nset starting_point \"this.input0\"\nset default \"this.d_\"\n\n# If cam has no inputs, return the default.\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera3\" && \[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera3\"||\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{ \[class \$x]==\"Input\" \} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{ \[exists \$inp] \} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {43 the_frame +INVISIBLE}
  the_frame "\[\nset the_camera \[string trimright \[value the_cam] .]\nif \{\[exists \$the_camera]\} \{\n    return \[value \$the_camera.frame]\n\} \{ \n    return \[frame]\n\}\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l "focal length" R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {30 d_win_translate l "window translate"}
  addUserKnob {30 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 version l " " t "Updated 5 May 2021" T "<span style=\"color:#666\"><br/><b>DummyCam v1.3</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019-2021</span>"}
 }
 Constant {
  inputs 0
  format "2 1 0 0 2 1 1 lights"
  name Constant3
  xpos 1500
  ypos -1545
 }
 Input {
  inputs 0
  name hdri
  xpos 1610
  ypos -1594
  number 2
 }
 Merge2 {
  inputs 2
  name Merge1
  xpos 1610
  ypos -1522
 }
 Reformat {
  type scale
  format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  black_outside true
  name Reformat5
  xpos 1610
  ypos -1498
 }
 Dot {
  name hdri_dot
  xpos 1644
  ypos -1453
 }
set N8c8dfc0 [stack 0]
 Reformat {
  type scale
  scale {{"floor(min(parent.hdri_dot.height, parent.hdri_dot.width) * parent.hdri_lighting_scale) > 0 ? parent.hdri_lighting_scale : 1"}}
  resize fill
  name Reformat
  xpos 1720
  ypos -1457
 }
 Blur {
  size {{parent.hdri_lighting_blur}}
  name Blur2
  xpos 1720
  ypos -1415
 }
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/kernels/hdri_irradiance.blink
  recompileCount 124
  ProgramGroup 1
  KernelDescription "2 \"HDRIrradiance\" iterate pixelWise 4fa4ec41cd2454b183501b9818f4ffb89ac8c635382155a0db4a6ab53708bae2 2 \"hdri\" Read Random \"dst\" Write Point 1 \"Samples\" Int 2 ZAAAADIAAAA= 1 \"_samples\" 2 1 3 \"__hdriPixelSize\" Float 2 1 AAAAAAAAAAA= \"__up\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"__sampleStep\" Float 2 1 AAAAAAAAAAA="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n#include \"math.h\"\n\n\nkernel HDRIrradiance : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessRandom, eEdgeClamped> hdri; // the input image\n    Image<eWrite> dst; // the output image\n\n    param:\n        int2 _samples;\n\n    local:\n        float2 __hdriPixelSize;\n        float3 __up;\n        float2 __sampleStep;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        defineParam(_samples, \"Samples\", int2(100, 50));\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        __hdriPixelSize = float2(hdri.bounds.width() / (2.0f * PI), hdri.bounds.height() / PI);\n        __up = float3(0, 1, 0);\n\n        __sampleStep = float2(\n            2.0f * PI / (float) _samples.x,\n            PI / (2.0f * (float) _samples.y)\n        );\n    \}\n\n\n    /**\n     * Get the value of hdri the ray would hit at infinite distance\n     *\n     * @arg rayDirection: The direction of the ray.\n     *\n     * @returns: The colour of the pixel in the direction of the ray.\n     */\n    float4 readHDRIValue(float3 rayDirection)\n    \{\n        const float2 angles = cartesionUnitVectorToSpherical(rayDirection);\n\n        // Why does bilinear give nans? :(\n        return hdri(\n            round(__hdriPixelSize.x * angles.x) - 1,\n            round(hdri.bounds.height() - (__hdriPixelSize.y * angles.y)) - 1\n        );\n    \}\n\n\n    /**\n     * Compute the irradiance of a pixel.\n     *\n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        const float2 uvPosition = pixelsToUV(\n            float2(pos.x, pos.y),\n            float2(hdri.bounds.width(), hdri.bounds.height())\n        );\n        const float3 direction = sphericalUnitVectorToCartesion(\n            uvPositionToAngles(uvPosition)\n        );\n\n        const float3 tangentRight = normalize(cross(__up, direction));\n        const float3 tangentUp = normalize(cross(direction, tangentRight));\n\n        float4 irradiance = float4(0);\n\n        for (float theta = 0.0f; theta < 2.0f * PI; theta += __sampleStep.x)\n        \{\n            for (float phi = PI / 2.0f; phi > 0.0f; phi -= __sampleStep.y)\n            \{\n                const float3 tangent = sphericalUnitVectorToCartesion(float2(theta, phi));\n                const float3 sampleDirection = (\n                    tangent.x * tangentRight\n                    + tangent.z * tangentUp\n                    + tangent.y * direction\n                );\n\n                irradiance += readHDRIValue(sampleDirection) * cos(phi) * sin(phi);\n            \}\n        \}\n\n        dst() = PI * irradiance / (float) (_samples.x * _samples.y);\n    \}\n\};\n"
  rebuild ""
  HDRIrradiance_Samples {{parent.hdri_irradiance_samples} {parent.hdri_irradiance_samples/2}}
  rebuild_finalise ""
  name HDRIrradiance
  xpos 1720
  ypos -1363
 }
 Reformat {
  type scale
  format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  black_outside true
  name Reformat3
  xpos 1720
  ypos -1305
 }
 Dot {
  name Dot33
  xpos 1754
  ypos -558
 }
 Constant {
  inputs 0
  format "1 1 0 0 1 1 1 1x1"
  name Constant4
  xpos -1580
  ypos -1713
 }
 Dot {
  name Dot7
  xpos -1546
  ypos -1542
 }
set N8ceaee0 [stack 0]
 Dot {
  name Dot25
  xpos -1106
  ypos -1542
 }
set N8cefed0 [stack 0]
 Dot {
  name Dot15
  xpos -1106
  ypos -1446
 }
push $N8cefed0
 Input {
  inputs 0
  name lights
  xpos -1030
  ypos -1594
  number 4
 }
 Merge2 {
  inputs 2
  name light_merge
  xpos -1030
  ypos -1498
 }
 Group {
  inputs 2
  name light_input_protection
  xpos -1030
  ypos -1450
  disable {{"width > 1"}}
  addUserKnob {20 User}
  addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
 }
  Reformat {
   inputs 0
   type "to box"
   box_width 1
   box_height 1
   box_fixed true
   name Reformat1
   xpos -119
   ypos 440
  }
  Input {
   inputs 0
   name Input2
   xpos 158
   ypos -28
   number 1
  }
  Dot {
   name Dot2
   xpos 192
   ypos -2
  }
set N8d2cc90 [stack 0]
  Dot {
   name Dot3
   xpos 329
   ypos -2
  }
  Dot {
   name Dot4
   xpos 329
   ypos 391
  }
  Input {
   inputs 0
   name Input1
   xpos 0
   ypos -32
  }
  Dot {
   name Dot1
   xpos 34
   ypos -6
  }
set N8d40820 [stack 0]
  Dot {
   name Dot6
   xpos -98
   ypos -6
  }
  Dot {
   name Dot5
   xpos -98
   ypos 336
  }
push $N8d2cc90
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop3
   xpos 158
   ypos 69
  }
  Crop {
   box {0 0 {parent.Dot2.width} 1}
   name Crop4
   xpos 158
   ypos 95
  }
  Transform {
   translate {{parent.Dot1.width} 0}
   center {1 0.5}
   name Transform2
   xpos 158
   ypos 121
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop5
   xpos 158
   ypos 167
  }
push $N8d40820
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop6
   xpos 0
   ypos 66
  }
  Crop {
   box {0 0 {parent.Dot1.width} 1}
   name Crop7
   xpos 0
   ypos 92
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop8
   xpos 0
   ypos 164
  }
  Merge2 {
   inputs 2
   also_merge all
   name Merge1
   xpos 0
   ypos 262
   disable {{"\[exists parent.input1] ? 0:1"}}
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input1] ? 0:1"}}
   name Switch2
   xpos 0
   ypos 332
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:1"}}
   name Switch1
   xpos 0
   ypos 387
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
   name Switch3
   xpos 0
   ypos 456
  }
  Dot {
   name out_dot
   xpos 36
   ypos 518
  }
  Output {
   name Output1
   xpos 2
   ypos 661
  }
 end_group
 Dot {
  name light_dot
  xpos -996
  ypos -1302
 }
set N8dd01a0 [stack 0]
add_layer {sdf_light_properties1 sdf_light_properties1.shadow_hardness sdf_light_properties1.falloff}
 Shuffle {
  in sdf_light_properties1
  blue green
  alpha green
  name light_props1
  xpos -810
  ypos -994
 }
 Dot {
  name Dot22
  xpos -776
  ypos -822
 }
push $N8dd01a0
add_layer {sdf_light_properties sdf_light_properties.colour_r sdf_light_properties.colour_g sdf_light_properties.colour_b sdf_light_properties.type}
 Shuffle {
  in sdf_light_properties
  name light_props
  xpos -920
  ypos -994
 }
 Dot {
  name Dot23
  xpos -886
  ypos -822
 }
push $N8dd01a0
add_layer {sdf_light sdf_light.light_pos_dir_x sdf_light.light_pos_dir_y sdf_light.light_pos_dir_z sdf_light.intensity}
 Shuffle {
  in sdf_light
  name light
  xpos -1030
  ypos -994
 }
 Dot {
  name Dot24
  xpos -996
  ypos -822
 }
push $N8cefed0
 Dot {
  name Dot16
  xpos -556
  ypos -1542
 }
set N8e15d80 [stack 0]
 Dot {
  name Dot36
  xpos 874
  ypos -1542
 }
 Input {
  inputs 0
  name noise
  xpos 950
  ypos -1594
  number 5
 }
 Merge2 {
  inputs 2
  name noise_merge
  xpos 950
  ypos -1498
 }
push $N8e15d80
 Input {
  inputs 0
  name scene
  xpos -480
  ypos -1594
 }
 Merge2 {
  inputs 2
  name object_merge
  xpos -480
  ypos -1498
 }
 Dot {
  name Dot37
  xpos -446
  ypos -1446
 }
set N8e4ade0 [stack 0]
 Group {
  inputs 2
  name noise_sdf_merge
  xpos 950
  ypos -1450
  addUserKnob {20 User}
  addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
 }
  Reformat {
   inputs 0
   type "to box"
   box_width 1
   box_height 1
   box_fixed true
   name Reformat1
   xpos -119
   ypos 440
  }
  Input {
   inputs 0
   name Input2
   xpos 158
   ypos -28
   number 1
  }
  Dot {
   name Dot2
   xpos 192
   ypos -2
  }
set N8e6d020 [stack 0]
  Dot {
   name Dot3
   xpos 329
   ypos -2
  }
  Dot {
   name Dot4
   xpos 329
   ypos 391
  }
  Input {
   inputs 0
   name Input1
   xpos 0
   ypos -32
  }
  Dot {
   name Dot1
   xpos 34
   ypos -6
  }
set N8e80bb0 [stack 0]
  Dot {
   name Dot6
   xpos -98
   ypos -6
  }
  Dot {
   name Dot5
   xpos -98
   ypos 336
  }
push $N8e6d020
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop3
   xpos 158
   ypos 69
  }
  Crop {
   box {0 0 {parent.Dot2.width} 1}
   name Crop4
   xpos 158
   ypos 95
  }
  Transform {
   translate {{parent.Dot1.width} 0}
   center {1 0.5}
   name Transform2
   xpos 158
   ypos 121
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop5
   xpos 158
   ypos 167
  }
push $N8e80bb0
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop6
   xpos 0
   ypos 66
  }
  Crop {
   box {0 0 {parent.Dot1.width} 1}
   name Crop7
   xpos 0
   ypos 92
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop8
   xpos 0
   ypos 164
  }
  Merge2 {
   inputs 2
   also_merge all
   name Merge1
   xpos 0
   ypos 262
   disable {{"\[exists parent.input1] ? 0:1"}}
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input1] ? 0:1"}}
   name Switch2
   xpos 0
   ypos 332
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:1"}}
   name Switch1
   xpos 0
   ypos 387
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
   name Switch3
   xpos 0
   ypos 456
  }
  Dot {
   name out_dot
   xpos 36
   ypos 518
  }
  Output {
   name Output1
   xpos 2
   ypos 661
  }
 end_group
 Dot {
  name Dot35
  xpos 984
  ypos -1230
 }
set N8f10f50 [stack 0]
 Shuffle {
  in sdf_noise_params2
  name noise_params2
  xpos 1170
  ypos -994
 }
 Dot {
  name Dot28
  xpos 1204
  ypos -822
 }
push $N8f10f50
 Shuffle {
  in sdf_noise_params1
  name noise_params1
  xpos 1060
  ypos -994
 }
 Dot {
  name Dot26
  xpos 1094
  ypos -822
 }
push $N8f10f50
 Shuffle {
  in sdf_noise_params0
  name noise_params0
  xpos 950
  ypos -994
 }
 Dot {
  name Dot27
  xpos 984
  ypos -822
 }
push $N8e15d80
 Dot {
  name Dot1
  xpos -556
  ypos -1374
 }
push $N8e4ade0
 Group {
  inputs 2
  name object_input_protection
  xpos -480
  ypos -1378
  disable {{"width > 1"}}
  addUserKnob {20 User}
  addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
 }
  Reformat {
   inputs 0
   type "to box"
   box_width 1
   box_height 1
   box_fixed true
   name Reformat1
   xpos -119
   ypos 440
  }
  Input {
   inputs 0
   name Input2
   xpos 158
   ypos -28
   number 1
  }
  Dot {
   name Dot2
   xpos 192
   ypos -2
  }
set N8f79c60 [stack 0]
  Dot {
   name Dot3
   xpos 329
   ypos -2
  }
  Dot {
   name Dot4
   xpos 329
   ypos 391
  }
  Input {
   inputs 0
   name Input1
   xpos 0
   ypos -32
  }
  Dot {
   name Dot1
   xpos 34
   ypos -6
  }
set N8f8d7f0 [stack 0]
  Dot {
   name Dot6
   xpos -98
   ypos -6
  }
  Dot {
   name Dot5
   xpos -98
   ypos 336
  }
push $N8f79c60
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop3
   xpos 158
   ypos 69
  }
  Crop {
   box {0 0 {parent.Dot2.width} 1}
   name Crop4
   xpos 158
   ypos 95
  }
  Transform {
   translate {{parent.Dot1.width} 0}
   center {1 0.5}
   name Transform2
   xpos 158
   ypos 121
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop5
   xpos 158
   ypos 167
  }
push $N8f8d7f0
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop6
   xpos 0
   ypos 66
  }
  Crop {
   box {0 0 {parent.Dot1.width} 1}
   name Crop7
   xpos 0
   ypos 92
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop8
   xpos 0
   ypos 164
  }
  Merge2 {
   inputs 2
   also_merge all
   name Merge1
   xpos 0
   ypos 262
   disable {{"\[exists parent.input1] ? 0:1"}}
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input1] ? 0:1"}}
   name Switch2
   xpos 0
   ypos 332
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:1"}}
   name Switch1
   xpos 0
   ypos 387
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
   name Switch3
   xpos 0
   ypos 456
  }
  Dot {
   name out_dot
   xpos 36
   ypos 518
  }
  Output {
   name Output1
   xpos 2
   ypos 661
  }
 end_group
 Dot {
  name obj_dot
  xpos -446
  ypos -1326
 }
set N901dea0 [stack 0]
 Shuffle {
  in sdf_surface
  name surface
  xpos 730
  ypos -994
 }
 Dot {
  name Dot2
  xpos 764
  ypos -822
 }
push $N901dea0
 Shuffle {
  in sdf_shape_mods_1
  name shape_mods_1
  xpos 620
  ypos -994
 }
 Dot {
  name Dot12
  xpos 654
  ypos -822
 }
push $N901dea0
 Shuffle {
  in sdf_shape_mods_0
  name shape_mods_0
  xpos 510
  ypos -994
 }
 Dot {
  name Dot3
  xpos 544
  ypos -822
 }
push $N901dea0
 Shuffle {
  in sdf_shape
  name shape
  xpos 400
  ypos -994
 }
 Dot {
  name Dot4
  xpos 434
  ypos -822
 }
push $N901dea0
 Shuffle {
  in sdf_scattering_colour
  name scattering_colour
  xpos 290
  ypos -994
 }
 Dot {
  name Dot38
  xpos 324
  ypos -822
 }
push $N901dea0
 Shuffle {
  in sdf_emm_colour
  name emm_colour
  xpos 180
  ypos -994
 }
 Dot {
  name Dot20
  xpos 214
  ypos -822
 }
push $N901dea0
 Shuffle {
  in sdf_trans_colour
  name trans_colour
  xpos 70
  ypos -994
 }
 Dot {
  name Dot19
  xpos 104
  ypos -822
 }
push $N901dea0
 Shuffle {
  in sdf_spec_colour
  name spec_colour
  xpos -40
  ypos -994
 }
 Dot {
  name Dot18
  xpos -6
  ypos -822
 }
push $N901dea0
 Shuffle {
  in sdf_colour
  name diff_colour
  xpos -150
  ypos -994
 }
 Dot {
  name Dot5
  xpos -116
  ypos -822
 }
push $N901dea0
 Shuffle {
  in sdf_dimensions
  name dimensions
  xpos -260
  ypos -994
 }
 Dot {
  name Dot10
  xpos -226
  ypos -822
 }
push $N901dea0
 Shuffle {
  in sdf_rotation_wall_thickness
  name rotation_wall_thickness
  xpos -370
  ypos -994
 }
 Dot {
  name Dot9
  xpos -336
  ypos -822
 }
push $N901dea0
 Shuffle {
  in sdf_position_scale
  name position_scale
  xpos -480
  ypos -994
 }
 Dot {
  name Dot6
  xpos -446
  ypos -822
 }
push $N8c8dfc0
push $N8ceaee0
 Reformat {
  format {{{parent.format_.format}}}
  name Reformat2
  xpos -1580
  ypos -1498
 }
set N9128440 [stack 0]
 Input {
  inputs 0
  name previous
  xpos -1470
  ypos -1618
  number 3
 }
 Merge2 {
  inputs 2
  name previous_merge
  xpos -1470
  ypos -1498
 }
 Dot {
  name Dot14
  xpos -1436
  ypos -1374
 }
set N914d420 [stack 0]
add_layer {variance variance.red variance.green variance.blue variance.num_paths}
 Shuffle {
  in variance
  name Shuffle1
  xpos -1470
  ypos -1330
 }
push $N9128440
 Invert {
  channels rgb
  name Invert2
  xpos -1580
  ypos -1306
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input3]"}}
  name Switch2
  xpos -1470
  ypos -1306
 }
 Dot {
  name Dot13
  xpos -1436
  ypos -462
 }
push $N914d420
 Dot {
  name Dot34
  xpos -1326
  ypos -1374
 }
 Dot {
  name Dot21
  xpos -1326
  ypos -606
 }
 Constant {
  inputs 0
  channels {rgba.red rgba.green rgba.blue -rgba.alpha}
  name format_
  xpos 1830
  ypos -707
 }
 Noise {
  output {rgba.red -rgba.green -rgba.blue -rgba.alpha}
  type turbulence
  size 1
  zoffset {{parent.seeds.x}}
  lacunarity 1.6
  center {512 389}
  name Noise1
  xpos 1830
  ypos -636
 }
 Noise {
  output {-rgba.red rgba.green -rgba.blue -rgba.alpha}
  type turbulence
  size 1
  zoffset {{parent.seeds.y}}
  center {512 389}
  name Noise2
  xpos 1830
  ypos -612
 }
 Noise {
  output {-rgba.red -rgba.green rgba.blue -rgba.alpha}
  type turbulence
  size 1
  zoffset {{parent.seeds.z}}
  lacunarity 2.14
  center {512 389}
  name Noise3
  xpos 1830
  ypos -588
 }
 Noise {
  output {-rgba.red -rgba.green -rgba.blue rgba.alpha}
  type turbulence
  size 1
  zoffset {{parent.seeds.z}}
  lacunarity 2.14
  center {512 389}
  name Noise4
  xpos 1830
  ypos -562
 }
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/kernels/random.blink
  recompileCount 8
  ProgramGroup 1
  KernelDescription "2 \"Random\" iterate pixelWise f51a1ffdf1b096c3af17073edd1520221f207854b2f525ed29f01e133fbdefd4 2 \"seed\" Read Point \"dst\" Write Point 1 \"Inclusive Range\" Float 2 AAAAAAAAgD8= 1 \"_inclusiveRange\" 2 1 1 \"__rangeLength\" Float 1 1 AAAAAA=="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n#include \"math.h\"\n#include \"random.h\"\n\n\nkernel Random : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessPoint, eEdgeNone> seed; // the input image\n    Image<eWrite> dst; // the output image\n\n\n    param:\n        float2 _inclusiveRange;\n\n    local:\n        float __rangeLength;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        defineParam(_inclusiveRange, \"Inclusive Range\", float2(0, 1));\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        __rangeLength = _inclusiveRange.y - _inclusiveRange.x;\n    \}\n\n\n    /**\n     * Compute a random pixel value.\n     */\n    void process()\n    \{\n        dst() = __rangeLength * random(seed()) + _inclusiveRange.x;\n    \}\n\};\n"
  rebuild ""
  rebuild_finalise ""
  name BlinkScript7
  xpos 1830
  ypos -524
 }
 Dot {
  name resolution_dot
  xpos 1864
  ypos -462
 }
 BlinkScript {
  inputs 23
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/kernels/ray_march.blink
  recompileCount 3210
  ProgramGroup 1
  KernelDescription "2 \"RayMarchKernel\" iterate pixelWise feab6167565d9a9c6155bfb1f20616f82c8bd16150d4b0074cb14a40c6856a63 24 \"noise\" Read Point \"src\" Read Point \"variance\" Read Point \"hdri\" Read Random \"positions\" Read Random \"rotations\" Read Random \"dimensions\" Read Random \"diffusivities\" Read Random \"specularities\" Read Random \"transmittances\" Read Random \"emittances\" Read Random \"scatteringCoefficients\" Read Random \"shapeProperties\" Read Random \"shapeModParameters0\" Read Random \"shapeModParameters1\" Read Random \"surfaceProperties\" Read Random \"noiseParams0\" Read Random \"noiseParams1\" Read Random \"noiseParams2\" Read Random \"lights\" Read Random \"lightProperties\" Read Random \"lightProperties1\" Read Random \"irradiance\" Read Random \"dst\" Write Point 36 \"Focal Length\" Float 1 AABIQg== \"Horizontal Aperture\" Float 1 ppvEQQ== \"Near Plane\" Float 1 zczMPQ== \"Far Plane\" Float 1 AEAcRg== \"Camera World Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"Focal Distance\" Float 1 AACAQA== \"fstop\" Float 1 AACAQQ== \"Enable Depth Of Field\" Bool 1 AQ== \"Screen Width\" Float 1 AABwRQ== \"Screen Height\" Float 1 AAAHRQ== \"HDRI Offset Angle\" Float 1 AAAAAA== \"Use Precomputed Irradiance\" Bool 1 AQ== \"Min Paths Per Pixel\" Int 1 AQAAAA== \"Max Paths Per Pixel\" Int 1 AQAAAA== \"Roulette\" Bool 1 AQ== \"Max Bounces\" Int 1 AQAAAA== \"Max Light Sampling Bounces\" Int 1 AAAAAA== \"Sample HDRI\" Bool 1 AQ== \"Sample All Lights\" Bool 1 AA== \"Secondary Light Sampling\" Bool 1 AA== \"Light Sampling Bias\" Float 1 AAAAAA== \"Max Ray Distance\" Float 1 AAB6RA== \"Max Ray Steps\" Int 1 gAAAAA== \"Level of Detail\" Bool 1 AQ== \"Hit Tolerance\" Float 1 bxKDOg== \"Shadow Bias\" Float 1 AACAPw== \"Maximum Brightness\" Float 1 /iN0SQ== \"Index of Refraction\" Float 1 AACAPw== \"Scattering Coefficient\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Extinction Coefficient\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"Equi-Angular Samples\" Int 1 BQAAAA== \"Sample HDRI Equi-Angular\" Bool 1 AQ== \"Object Texture Width\" Int 1 AAAAAA== \"Light Texture Width\" Int 1 AAAAAA== \"Output Type\" Int 1 AAAAAA== \"Output LatLong\" Bool 1 AA== 36 \"_focalLength\" 1 1 \"_horizontalAperture\" 1 1 \"_nearPlane\" 1 1 \"_farPlane\" 1 1 \"_cameraWorldMatrix\" 16 1 \"_focalDistance\" 1 1 \"_fStop\" 1 1 \"_depthOfFieldEnabled\" 1 1 \"_formatWidth\" 1 1 \"_formatHeight\" 1 1 \"_hdriOffsetAngle\" 1 1 \"_usePrecomputedIrradiance\" 1 1 \"_minPathsPerPixel\" 1 1 \"_maxPathsPerPixel\" 1 1 \"_roulette\" 1 1 \"_maxBounces\" 1 1 \"_maxLightSamplingBounces\" 1 1 \"_sampleHDRI\" 1 1 \"_sampleAllLights\" 1 1 \"_doSecondaryLightSampling\" 1 1 \"_lightSamplingBias\" 1 1 \"_maxRayDistance\" 1 1 \"_maxRaySteps\" 1 1 \"_levelOfDetail\" 1 1 \"_hitTolerance\" 1 1 \"_shadowBias\" 1 1 \"_maxBrightness\" 1 1 \"_refractiveIndex\" 1 1 \"_scatteringCoefficient\" 4 1 \"_extinctionCoefficient\" 4 1 \"_equiangularSamples\" 1 1 \"_sampleHDRIEquiangular\" 1 1 \"_objectTextureWidth\" 1 1 \"_lightTextureWidth\" 1 1 \"_outputType\" 1 1 \"_latLong\" 1 1 13 \"__inverseCameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"__aperture\" Float 1 1 AAAAAA== \"__bouncesPerRay\" Int 1 1 AAAAAA== \"__lightSamplingEnabled\" Bool 1 1 AA== \"__lightSamplingAngle\" Float 1 1 AAAAAA== \"__equiangularSamplingEnabled\" Bool 1 1 AA== \"__hdriPixelSize\" Float 2 1 AAAAAAAAAAA= \"__irradiancePixelSize\" Float 2 1 AAAAAAAAAAA= \"__hdriOffsetRadians\" Float 1 1 AAAAAA== \"__offset0\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"__offset1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"__offset2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"__offset3\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n//\n// BlinkScript Ray Marcher\n//\n\n#include \"math.h\"\n#include \"random.h\"\n#include \"noise.h\"\n#include \"conversion.h\"\n#include \"aovs.h\"\n#include \"lights.h\"\n#include \"material.h\"\n#include \"camera.h\"\n#include \"objectInteraction.h\"\n#include \"sdfModifications.h\"\n#include \"sdfs.h\"\n\n\n// Increase this if you want more than MAX_CHILD_DEPTH direct children\n#define MAX_CHILD_DEPTH 32\n#define MAX_MIS_EMISSIVE_SHAPES 32\n\n// Number of parameters needed in the parent stacks\n#define PARENT_STACK_PARAMS 8\n#define FULL_PARENT_STACK_PARAMS 29\n\n// Indices to store parent stack data\n#define NUM_CHILDREN 0\n#define TRANSFORM_X 1\n#define TRANSFORM_Y 2\n#define TRANSFORM_Z 3\n#define SCALE 4\n#define MODIFICATIONS 5\n#define BLEND_STRENGTH 6\n#define DISTANCE 7\n#define DIFFUSE_COLOUR_R 8\n#define DIFFUSE_COLOUR_G 9\n#define DIFFUSE_COLOUR_B 10\n#define SPECULAR_ROUGHNESS 11\n#define SPECULAR_COLOUR_R 12\n#define SPECULAR_COLOUR_G 13\n#define SPECULAR_COLOUR_B 14\n#define SPECULAR 15\n#define EXTINCTION_R 16\n#define EXTINCTION_G 17\n#define EXTINCTION_B 18\n#define TRANSMISSION 19\n#define EMISSION_R 20\n#define EMISSION_G 21\n#define EMISSION_B 22\n#define SCATTERING_R 23\n#define SCATTERING_G 24\n#define SCATTERING_B 25\n#define TRANSMISSION_ROUGHNESS 26\n#define PARENT_REFRACTIVE_INDEX 27\n#define PARENT_OBJECT_ID 28\n\n// Maximum recursion depth for ray marching\n#define MAX_RAYS_PER_SUBPIXEL 100\n\n#define IS_BOUND 4096\n\n#define IS_NOT_UNION 3968\n\n\nkernel RayMarchKernel : ImageComputationKernel<ePixelWise>\n\{\n    // the input which specifies the format, process is called once per pixel\n    // in this image, which also provides random seeds\n    Image<eRead, eAccessPoint, eEdgeNone> noise;\n    Image<eRead, eAccessPoint, eEdgeNone> src;\n    Image<eRead, eAccessPoint, eEdgeNone> variance;\n\n    // the hdri in latlong format\n    Image<eRead, eAccessRandom, eEdgeNone> hdri;\n\n\n    // the shape positons.xyz, scale.w\n    Image<eRead, eAccessRandom, eEdgeNone> positions;\n\n    // the shape rotations.xyz, wall thickness.w\n    Image<eRead, eAccessRandom, eEdgeNone> rotations;\n\n    // the shape dimensions.xyzw (some shapes may not use all channels)\n    Image<eRead, eAccessRandom, eEdgeNone> dimensions;\n\n    // the shape diffusivities.xyz, specular roughness.w\n    Image<eRead, eAccessRandom, eEdgeNone> diffusivities;\n\n    Image<eRead, eAccessRandom, eEdgeNone> specularities;\n\n    Image<eRead, eAccessRandom, eEdgeNone> transmittances;\n\n    Image<eRead, eAccessRandom, eEdgeNone> emittances;\n\n    Image<eRead, eAccessRandom, eEdgeNone> scatteringCoefficients;\n\n\n    // shape type.x, operation.y, numChildren.z, blend strength.w\n    Image<eRead, eAccessRandom, eEdgeNone> shapeProperties;\n\n    // repetition params.xyzw\n    Image<eRead, eAccessRandom, eEdgeNone> shapeModParameters0;\n\n    // elongation.xyz edgeRadius.w\n    Image<eRead, eAccessRandom, eEdgeNone> shapeModParameters1;\n\n    // reflection.x, transmission.y, emission.z, roughness.w\n    Image<eRead, eAccessRandom, eEdgeNone> surfaceProperties;\n\n    // noise options.x translation.yzw\n    Image<eRead, eAccessRandom, eEdgeNone> noiseParams0;\n\n    // octaves.x, lacunarity.y, gain.z, gamma.w\n    Image<eRead, eAccessRandom, eEdgeNone> noiseParams1;\n\n    // size.x\n    Image<eRead, eAccessRandom, eEdgeNone> noiseParams2;\n\n    // the input lights direction/position.xyz intensity.w\n    Image<eRead, eAccessRandom, eEdgeNone> lights;\n\n    // colour.xyz, type.w\n    // w in \[0, 1) = directional, \[1, inf) = point\n    Image<eRead, eAccessRandom, eEdgeNone> lightProperties;\n\n    // shadow hardness.x\n    Image<eRead, eAccessRandom, eEdgeNone> lightProperties1;\n\n    // the precomputed irradiance of the hdri\n    Image<eRead, eAccessRandom, eEdgeClamped> irradiance;\n\n\n    // the output image\n    Image<eWrite> dst;\n\n\n    param:\n        // These parameters are made available to the user.\n\n        // Camera params\n        float _focalLength;\n        float _horizontalAperture;\n        float _nearPlane;\n        float _farPlane;\n        float4x4 _cameraWorldMatrix;\n        float _focalDistance;\n        float _fStop;\n        bool _depthOfFieldEnabled;\n\n        // Image params\n        float _formatWidth;\n        float _formatHeight;\n\n        float _hdriOffsetAngle;\n        bool _usePrecomputedIrradiance;\n\n        // Ray params\n        int _minPathsPerPixel;\n        int _maxPathsPerPixel;\n        bool _roulette;\n        int _maxBounces;\n        int _maxLightSamplingBounces;\n        bool _sampleHDRI;\n        bool _sampleAllLights;\n        bool _doSecondaryLightSampling;\n        float _lightSamplingBias;\n        float _maxRayDistance;\n        int _maxRaySteps;\n        bool _levelOfDetail;\n        float _hitTolerance;\n        float _shadowBias;\n        float _maxBrightness;\n\n        // Scene params\n        float _refractiveIndex;\n        float4 _scatteringCoefficient;\n        float4 _extinctionCoefficient;\n        int _equiangularSamples;\n        bool _sampleHDRIEquiangular;\n\n        // Shape Textures\n        int _objectTextureWidth;\n        int _lightTextureWidth;\n\n        int _outputType;\n\n        bool _latLong;\n\n\n    local:\n        // These local variables are not exposed to the user.\n\n        float4x4 __inverseCameraProjectionMatrix;\n        float __aperture;\n\n        int __bouncesPerRay;\n        bool __lightSamplingEnabled;\n        float __lightSamplingAngle;\n        bool __equiangularSamplingEnabled;\n\n        float2 __hdriPixelSize;\n        float2 __irradiancePixelSize;\n        float __hdriOffsetRadians;\n\n        float3 __offset0;\n        float3 __offset1;\n        float3 __offset2;\n        float3 __offset3;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        // Camera params\n        defineParam(_focalLength, \"Focal Length\", 50.0f);\n        defineParam(_horizontalAperture, \"Horizontal Aperture\", 24.576f);\n        defineParam(_nearPlane, \"Near Plane\", 0.1f);\n        defineParam(_farPlane, \"Far Plane\", 10000.0f);\n        defineParam(\n            _cameraWorldMatrix,\n            \"Camera World Matrix\",\n            float4x4(\n                1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1\n            )\n        );\n        defineParam(_focalDistance, \"Focal Distance\", 4.0f);\n        defineParam(_fStop, \"fstop\", 16.0f);\n        defineParam(_depthOfFieldEnabled, \"Enable Depth Of Field\", true);\n\n        // Image params\n        defineParam(_formatHeight, \"Screen Height\", 2160.0f);\n        defineParam(_formatWidth, \"Screen Width\", 3840.0f);\n        defineParam(_hdriOffsetAngle, \"HDRI Offset Angle\", 0.0f);\n        defineParam(_usePrecomputedIrradiance, \"Use Precomputed Irradiance\", true);\n\n        // Ray params\n        defineParam(_minPathsPerPixel, \"Min Paths Per Pixel\", 1);\n        defineParam(_maxPathsPerPixel, \"Max Paths Per Pixel\", 1);\n        defineParam(_roulette, \"Roulette\", true);\n        defineParam(_maxRayDistance, \"Max Ray Distance\", 1000.0f);\n        defineParam(_maxRaySteps, \"Max Ray Steps\", 128);\n        defineParam(_maxBounces, \"Max Bounces\", 1);\n        defineParam(_maxLightSamplingBounces, \"Max Light Sampling Bounces\", 0);\n        defineParam(_sampleHDRI, \"Sample HDRI\", true);\n        defineParam(_sampleAllLights, \"Sample All Lights\", false);\n        defineParam(_doSecondaryLightSampling, \"Secondary Light Sampling\", false);\n        defineParam(_lightSamplingBias, \"Light Sampling Bias\", 0.0f);\n        defineParam(_levelOfDetail, \"Level of Detail\", true);\n        defineParam(_hitTolerance, \"Hit Tolerance\", 0.001f);\n        defineParam(_shadowBias, \"Shadow Bias\", 1.0f);\n        defineParam(_maxBrightness, \"Maximum Brightness\", 999999.9f);\n\n        // Scene params\n        defineParam(_refractiveIndex, \"Index of Refraction\", 1.0f);\n        defineParam(_scatteringCoefficient, \"Scattering Coefficient\", float4(0));\n        defineParam(_extinctionCoefficient, \"Extinction Coefficient\", float4(1));\n        defineParam(_equiangularSamples, \"Equi-Angular Samples\", 5);\n        defineParam(_sampleHDRIEquiangular, \"Sample HDRI Equi-Angular\", true);\n\n        // Shape Counts\n        defineParam(_objectTextureWidth, \"Object Texture Width\", 0);\n        defineParam(_lightTextureWidth, \"Light Texture Width\", 0);\n\n        defineParam(_outputType, \"Output Type\", 0);\n\n        defineParam(_latLong, \"Output LatLong\", false);\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        __bouncesPerRay = max(0, _maxBounces);\n\n        __lightSamplingEnabled = _maxLightSamplingBounces > 0;\n\n        __lightSamplingAngle = PI * (1.0f - saturate(_lightSamplingBias));\n\n        __equiangularSamplingEnabled = _equiangularSamples > 0;\n\n        float aspect = aspectRatio(_formatHeight, _formatWidth);\n        float4x4 cameraProjectionMatrix = projectionMatrix(\n            _focalLength,\n            _horizontalAperture,\n            aspect,\n            _nearPlane,\n            _farPlane\n        );\n        __inverseCameraProjectionMatrix = cameraProjectionMatrix.invert();\n\n        __aperture = fStopToAperture(_fStop, _focalLength);\n\n        __hdriPixelSize = float2(\n            hdri.bounds.width() / (2 * PI),\n            hdri.bounds.height() / PI\n        );\n        __irradiancePixelSize = float2(\n            irradiance.bounds.width() / (2 * PI),\n            irradiance.bounds.height() / PI\n        );\n        __hdriOffsetRadians = degreesToRadians(_hdriOffsetAngle);\n\n        __offset0 = 0.5773f * float3(1, -1, -1);\n        __offset1 = 0.5773f * float3(-1, -1, 1);\n        __offset2 = 0.5773f * float3(-1, 1, -1);\n        __offset3 = 0.5773f * float3(1, 1, 1);\n    \}\n\n\n    /**\n     * Get the noise value at a position.\n     *\n     * @arg index: The index of the noise.\n     * @arg position: The position at which we want the noise.\n     * @arg noiseOptions: The noise modifier options.\n     *\n     * @returns: The noise value.\n     */\n    float getNoiseValue(const int index, const float3 &position, int &noiseOptions)\n    \{\n        // Make sure there is a noise node plugged into the object.\n        noiseOptions = (int) noiseParams0(index, 0, 0);\n        if ((noiseOptions & NOISE_ENABLED) == 0)\n        \{\n            return -1.0f;\n        \}\n\n        // Read the noise parameters\n        const float3 translation = float3(\n            noiseParams0(index, 0, 1),\n            noiseParams0(index, 0, 2),\n            noiseParams0(index, 0, 3)\n        );\n\n        const int octaves = noiseParams1(index, 0, 0);\n        const float lacunarity = noiseParams1(index, 0, 1);\n        const float gain = noiseParams1(index, 0, 2);\n        const float gamma = noiseParams1(index, 0, 3);\n        const float size = noiseParams2(index, 0, 0);\n\n        // Translate the noise, and convert the position to the local\n        // coordinate system\n        float3 noisePosition;\n        if (index == _objectTextureWidth)\n        \{\n            noisePosition = position + translation;\n        \}\n        else\n        \{\n            noisePosition = worldToLocal(index, position + translation);\n        \}\n\n        // Get the noise value based on which type of noise we are using\n        float noiseValue;\n        if (noiseOptions & FBM_NOISE)\n        \{\n            noiseValue = fractalBrownianMotionNoise(\n                octaves,\n                lacunarity,\n                size,\n                gain,\n                gamma,\n                noisePosition\n            );\n        \}\n        else\n        \{\n            noiseValue = turbulenceNoise(\n                octaves,\n                lacunarity,\n                size,\n                gain,\n                gamma,\n                noisePosition\n            );\n        \}\n\n        // Modify the noise using the grade parameters\n        const float whitePoint = noiseParams2(index, 0, 1);\n        const float blackPoint = noiseParams2(index, 0, 2);\n        const float lift = noiseParams2(index, 0, 3);\n\n        if (whitePoint != blackPoint)\n        \{\n            noiseValue = saturate((noiseValue - blackPoint) / (whitePoint - blackPoint));\n        \}\n\n        noiseValue = saturate(noiseValue * (1.0f - lift) + lift);\n\n        if (noiseOptions & INVERT_NOISE)\n        \{\n            noiseValue = 1.0f - noiseValue;\n        \}\n\n        return noiseValue;\n    \}\n\n\n    /**\n     * Modify the material properties of an object based on noise.\n     *\n     * @arg objectIndex: The index of the object.\n     * @arg intersectionPosition: The position at which the we are\n     *     modifying the material.\n     * @arg diffusivity: The diffuse values of the surface.\n     * @arg specularity: The specular values of the surface.\n     * @arg transmittance: The extinction coefficient and transmissive\n     *     probability of the surface.\n     * @arg emittance: The emissive values of the surface.\n     * @arg specularRoughness: The specular roughness of the surface.\n     * @arg transmissionRoughness: The transmissive roughness of the\n     *     surface.\n     * @arg refractiveIndex: The refractive index of the material.\n     */\n    void noiseMaterialInteraction(\n            const int objectIndex,\n            const float3 &intersectionPosition,\n            float4 &diffusivity,\n            float4 &specularity,\n            float4 &transmittance,\n            float4 &emittance,\n            float &specularRoughness,\n            float &transmissionRoughness,\n            float &refractiveIndex)\n    \{\n        int noiseOptions;\n        const float noiseValue = getNoiseValue(\n            objectIndex,\n            intersectionPosition,\n            noiseOptions\n        );\n        if (noiseValue >= 0.0f)\n        \{\n            useNoiseOnMaterial(\n                noiseOptions,\n                noiseValue,\n                diffusivity,\n                specularity,\n                transmittance,\n                emittance,\n                specularRoughness,\n                transmissionRoughness,\n                refractiveIndex\n            );\n        \}\n    \}\n\n\n    /**\n     * Get the value of hdri the ray would hit at infinite distance\n     *\n     * @arg rayDirection: The direction of the ray.\n     *\n     * @returns: The colour of the pixel in the direction of the ray.\n     */\n    float4 readHDRIValue(float3 rayDirection)\n    \{\n        const float2 angles = cartesionUnitVectorToSpherical(rayDirection, __hdriOffsetRadians);\n\n        // Should be able to say image access is eEdgeClamped and not do this\n        // but I see nan pixels sooo... :(\n        const float2 indices = clamp(\n            float2(\n                __hdriPixelSize.x * angles.x,\n                hdri.bounds.height() - (__hdriPixelSize.y * angles.y)\n            ),\n            float2(0),\n            float2(hdri.bounds.width(), hdri.bounds.height()) - 1.0f\n        );\n\n        return bilinear(hdri, indices.x, indices.y);\n    \}\n\n\n    /**\n     * Get the value of irradiance the hdri would provide in a direction\n     *\n     * @arg rayDirection: The direction of the ray.\n     *\n     * @returns: The colour of the pixel in the direction of the ray.\n     */\n    inline float4 readIrradianceValue(float3 rayDirection)\n    \{\n        const float2 angles = cartesionUnitVectorToSpherical(rayDirection, __hdriOffsetRadians);\n\n        // Should be able to say image access is eEdgeClamped and not do this\n        // but I see nan pixels sooo... :(\n        const float2 indices = clamp(\n            float2(\n                __irradiancePixelSize.x * angles.x,\n                irradiance.bounds.height() - (__irradiancePixelSize.y * angles.y)\n            ),\n            float2(0),\n            float2(irradiance.bounds.width(), irradiance.bounds.height()) - 1.0f\n        );\n\n        return bilinear(irradiance, indices.x, indices.y);\n    \}\n\n\n    /**\n     * Get the scale of an object.\n     *\n     * @arg objectIndex: The index of the object.\n     *\n     * @returns: The scale of the object.\n     */\n    float getScale(const int objectIndex)\n    \{\n        float scale = 1.0f;\n\n        for (int j=0; j <= objectIndex; j++)\n        \{\n            const float numChildren = shapeProperties(j, 0, 2);\n\n            if (j + numChildren < objectIndex)\n            \{\n                j += numChildren;\n                continue;\n            \}\n\n            scale *= positions(j, 0, 3);\n        \}\n\n        return scale;\n    \}\n\n\n    /**\n     * Get the radius of an object.\n     *\n     * @arg objectIndex: The index of the object.\n     *\n     * @returns: The radius of the object.\n     */\n    float getRadius(const int objectIndex)\n    \{\n        return getScale(objectIndex) * dimensions(objectIndex, 0, 0);\n    \}\n\n\n    /**\n     * Get the local position, from a world position.\n     *\n     * @arg objectIndex: The index of the object whose local coordinate\n     *     system we are using.\n     * @arg worldPosition: The world position.\n     *\n     * @returns: The local position of the worldPosition.\n     */\n    float3 worldToLocal(const int objectIndex, const float3 &worldPosition)\n    \{\n        float3 localPosition = worldPosition;\n        for (int j=0; j <= objectIndex; j++)\n        \{\n            SampleType(shapeProperties) shapeProperty = shapeProperties(j, 0);\n            const float numChildren = shapeProperty.z;\n\n            if (j + numChildren < objectIndex)\n            \{\n                j += numChildren;\n                continue;\n            \}\n\n            // Read in the shape properties\n            const SampleType(positions) position = positions(j, 0);\n            const SampleType(rotations) rotation = rotations(j, 0);\n            const SampleType(dimensions) dimension = dimensions(j, 0);\n            const SampleType(shapeModParameters0) modParameters0 = shapeModParameters0(j, 0);\n            const SampleType(shapeModParameters1) modParameters1 = shapeModParameters1(j, 0);\n\n            // const float scale = position.w;\n            const int modifications = (int) shapeProperty.y;\n\n            // Use parent transform to position child\n            localPosition = transformRay(\n                localPosition,\n                float3(position.x, position.y, position.z),\n                float3(rotation.x, rotation.y, rotation.z),\n                modifications,\n                modParameters0,\n                modParameters1\n            );\n        \}\n\n        return localPosition;\n    \}\n\n\n    /**\n     * Get the world position, from a local position.\n     *\n     * @arg objectIndex: The index of the object whose local coordinate\n     *     system we are using.\n     * @arg localPosition: The local position.\n     *\n     * @returns: The world position of the localPosition.\n     */\n    float3 localToWorld(const int objectIndex, const float3 &localPosition)\n    \{\n        float3 worldPosition = localPosition;\n        for (int j=objectIndex; j >= 0; j--)\n        \{\n            SampleType(shapeProperties) shapeProperty = shapeProperties(j, 0);\n            const float numChildren = shapeProperty.z;\n\n            if (j + numChildren < objectIndex)\n            \{\n                continue;\n            \}\n\n            // Read in the shape properties\n            const SampleType(positions) position = positions(j, 0);\n            const SampleType(rotations) rotation = rotations(j, 0);\n            const SampleType(dimensions) dimension = dimensions(j, 0);\n            const SampleType(shapeModParameters0) modParameters0 = shapeModParameters0(j, 0);\n            const SampleType(shapeModParameters1) modParameters1 = shapeModParameters1(j, 0);\n\n            // const float scale = position.w;\n            const int modifications = (int) shapeProperty.y;\n\n            // Use parent transform to position child\n            worldPosition = inverseTransformRay(\n                worldPosition,\n                float3(position.x, position.y, position.z),\n                float3(rotation.x, rotation.y, rotation.z),\n                modifications,\n                modParameters0,\n                modParameters1\n            );\n        \}\n\n        return worldPosition;\n    \}\n\n\n    /**\n     * Get the world position of an object.\n     *\n     * @arg objectIndex: The index of the object.\n     *\n     * @returns: The world position of the object.\n     */\n    float3 getObjectPosition(const int objectIndex)\n    \{\n        return localToWorld(objectIndex, float3(0));\n    \}\n\n\n    /**\n     * Check whether or not an object is set to interact with its\n     * children in a way that is not union.\n     *\n     * @arg objectIndex: The index of the object to check.\n     *\n     * @returns: True if object's interaction type is not set to union,\n     *     and false otherwise.\n     */\n    inline bool childInteractionIsNotUnion(const int objectIndex)\n    \{\n        return (int(shapeProperties(objectIndex, 0, 1)) & IS_NOT_UNION) > 0;\n    \}\n\n\n    /**\n     * Check whether or not an object is the parent of another.\n     *\n     * @arg parentIndex: The index of the potential parent.\n     * @arg childIndex: The index of the potential child.\n     *\n     * @returns: True if the object is the parent, and false otherwise.\n     */\n    inline bool isParentOf(const int parentIndex, const int childIndex)\n    \{\n        return (\n            parentIndex < childIndex\n            && parentIndex + shapeProperties(parentIndex, 0, 2) >= childIndex\n        );\n    \}\n\n\n    /**\n     * Check whether or not we will be exiting the current material if\n     * we transmit through the surface of an object.\n     *\n     * @arg currentMaterialIndex: The index of the object whose material\n     *     we are currently travelling through.\n     * @arg objectIndex: The index of the object that we have hit.\n     *\n     * @returns: True if we will be exiting, and false otherwise.\n     */\n    bool isExitingObject(const int currentMaterialIndex, const int objectIndex)\n    \{\n        return (\n            currentMaterialIndex >= 0\n            && (\n                currentMaterialIndex == objectIndex\n                || (\n                    isParentOf(objectIndex, currentMaterialIndex)\n                    && childInteractionIsNotUnion(objectIndex)\n                ) || (\n                    isParentOf(currentMaterialIndex, objectIndex)\n                    && childInteractionIsNotUnion(currentMaterialIndex)\n                )\n            )\n        );\n    \}\n\n\n    /**\n     * Compute the minimum distance to an object in the scene.\n     *\n     * @arg rayOrigin: The origin position of the ray.\n     * @arg pixelFootprint: A value proportional to the amount of world\n     *     space that fills a pixel, like the distance from camera.\n     *\n     * @returns: The minimum distance to an object in the scene.\n     */\n    float getMinDistanceToObjectInScene(const float3 &rayOrigin, const float pixelFootprint)\n    \{\n        float distance = _maxRayDistance;\n\n        // numChildren, transformedRay, scale, mods, nextDistance, diffuse colour\n        // roughness, specular colour, specular, transmissive colour, transmission,\n        // emissive colour, emission, refractive index, objectId, blendStrength\n        float parentStack\[MAX_CHILD_DEPTH]\[PARENT_STACK_PARAMS];\n        int parentStackLength = 0;\n\n        for (int j=0; j < _objectTextureWidth; j++)\n        \{\n            // Read in the shape properties\n            SampleType(positions) position = positions(j, 0);\n            SampleType(rotations) rotation = rotations(j, 0);\n            SampleType(dimensions) dimension = dimensions(j, 0);\n            SampleType(shapeProperties) shapeProperty = shapeProperties(j, 0);\n            SampleType(shapeModParameters0) modParameters0 = shapeModParameters0(j, 0);\n            SampleType(shapeModParameters1) modParameters1 = shapeModParameters1(j, 0);\n\n            float scale = position.w;\n\n            const int modifications = (int) shapeProperty.y;\n            float numChildren = shapeProperty.z;\n            const float blendStrength = shapeProperty.w;\n\n            int stackLastIndex = parentStackLength - 1;\n\n            // Position relative to the parent if we have any\n            float3 parentTransformedRay = rayOrigin;\n            if (parentStackLength > 0)\n            \{\n                parentTransformedRay.x = parentStack\[stackLastIndex]\[TRANSFORM_X];\n                parentTransformedRay.y = parentStack\[stackLastIndex]\[TRANSFORM_Y];\n                parentTransformedRay.z = parentStack\[stackLastIndex]\[TRANSFORM_Z];\n                scale *= parentStack\[stackLastIndex]\[SCALE];\n            \}\n\n            // Use parent transform to position child\n            const float3 transformedRay = transformRay(\n                parentTransformedRay,\n                float3(position.x, position.y, position.z),\n                float3(rotation.x, rotation.y, rotation.z),\n                modifications,\n                modParameters0,\n                modParameters1\n            );\n\n            // Get distance to this child\n            float nextDistance = getModifiedDistance(\n                transformedRay,\n                (int) shapeProperty.x,\n                dimension,\n                scale,\n                modifications,\n                modParameters1.w,\n                rotation.w\n            );\n\n            // Track which object was hit for the alpha channel\n            float objectId = (float) j + 1.0f;\n\n            // If this is a bounding volume, we can skip its children\n            // if we aren't close to, or inside it\n            if (\n                modifications & IS_BOUND\n                && numChildren > 0\n                && nextDistance > _hitTolerance + pixelFootprint\n            ) \{\n                // Update the min distance if this bounding volume is closest.\n                // Otherwise we could step through it, or if every object in\n                // the scene is inside it, we would not step forward at all\n                if (fabs(nextDistance) < fabs(distance))\n                \{\n                    distance = nextDistance;\n                \}\n\n                // This was tagged as a boundary object, skip its children\n                // since we arent close to hitting it\n                j += numChildren;\n\n                for (int parentIndex=stackLastIndex; parentIndex >= 0; parentIndex--)\n                \{\n                    parentStack\[parentIndex]\[NUM_CHILDREN] -= numChildren + 1.0f;\n                \}\n\n                // If there are no parents, or still children of the parent\n                // we do not need to compute anything further for this loop\n                if (parentStackLength <= 0 || parentStack\[stackLastIndex]\[NUM_CHILDREN] > 0.0f)\n                \{\n                    continue;\n                \}\n\n                // pop stack\n                // we know that there will be no more children if we did not continue\n                numChildren = 0.0f;\n                nextDistance = parentStack\[stackLastIndex]\[DISTANCE];\n                stackLastIndex--;\n                parentStackLength--;\n            \}\n\n            if (numChildren <= 0.0f)\n            \{\n                // No Children left, compute interactions with parent\n                if (parentStackLength > 0)\n                \{\n                    // Process this object, along with all parents that do not\n                    // have any more children, removing them from the stack,\n                    // but descend all the way down the stack, without removing\n                    // the objects that still have children\n                    for (int stackIndex=stackLastIndex; stackIndex >= 0; stackIndex--)\n                    \{\n                        const int parentModifications = parentStack\[stackIndex]\[MODIFICATIONS];\n\n                        // Do not need to interact with bounding volumes.\n                        // They are in the stack for relative positioning\n                        // if they weren't then we would have to manually move\n                        // the bounding box to follow the children\n                        const float parentBlendStrength = parentStack\[stackIndex]\[BLEND_STRENGTH];\n                        const float parentNextDistance = parentStack\[stackIndex]\[DISTANCE];\n\n                        // Compute interaction between parent and this child\n                        nextDistance = performChildInteraction(\n                            parentModifications,\n                            parentNextDistance,\n                            nextDistance,\n                            parentBlendStrength\n                        );\n\n                        // Update the global min distance (and surface/colour)\n                        if (fabs(nextDistance) < fabs(distance))\n                        \{\n                            distance = nextDistance;\n                        \}\n                    \}\n\n                    do\n                    \{\n                        // Decrement the number of children each parent has\n                        for (int parentIndex=stackLastIndex; parentIndex >= 0; parentIndex--)\n                        \{\n                            parentStack\[parentIndex]\[NUM_CHILDREN] -= 1.0f;\n                        \}\n\n                        // Get the number of children still remaining for the parent\n                        // If there are still children, we can break out of this loop\n                        // to process the rest of them before the parent itself\n                        numChildren = parentStack\[stackLastIndex]\[NUM_CHILDREN];\n                    \}\n                    while (numChildren <= 0.0f && --stackLastIndex >= 0);\n\n                    parentStackLength = stackLastIndex + 1;\n                \}\n                // No parents to interact with, simply check the distance\n                else if (fabs(nextDistance) < fabs(distance))\n                \{\n                    distance = nextDistance;\n                \}\n            \}\n            else\n            \{\n                // Node has Children, push it to the stack for later\n                // processing when we have all its children\n                // parentStack.push()\n                parentStack\[parentStackLength]\[NUM_CHILDREN] = numChildren;\n                parentStack\[parentStackLength]\[TRANSFORM_X] = transformedRay.x;\n                parentStack\[parentStackLength]\[TRANSFORM_Y] = transformedRay.y;\n                parentStack\[parentStackLength]\[TRANSFORM_Z] = transformedRay.z;\n                parentStack\[parentStackLength]\[SCALE] = scale;\n                parentStack\[parentStackLength]\[MODIFICATIONS] = (float) modifications;\n                parentStack\[parentStackLength]\[BLEND_STRENGTH] = blendStrength;\n                parentStack\[parentStackLength]\[DISTANCE] = nextDistance;\n                parentStackLength++;\n            \}\n        \}\n\n        return distance;\n    \}\n\n\n    /**\n     * Compute the minimum distance to an object in the scene.\n     *\n     * @arg rayOrigin: The origin position of the ray.\n     * @arg pixelFootprint: A value proportional to the amount of world\n     *     space that fills a pixel, like the distance from camera.\n     * @arg diffusivity: The diffuse values of the nearest surface.\n     * @arg specularity: The specular values of the nearest surface.\n     * @arg transmittance: The extinction coefficient and transmissive\n     *     probability of the nearest surface.\n     * @arg emittance: The emissive values of the nearest surface.\n     * @arg scatteringCoefficient: The scattering coefficient of the\n     *     nearest material.\n     * @arg specularRoughness: The specular roughness of the surface.\n     * @arg transmissionRoughness: The transmissive roughness of the\n     *     nearest surface.\n     * @arg refractiveIndex: The refractive index of the material.\n     * @arg doRefraction: Whether or not refraction is enabled on the\n     *     nearest material.\n     * @arg id: The ID of the nearest object.\n     *\n     * @returns: The minimum distance to an object in the scene.\n     */\n    float getMinDistanceToObjectInScene(\n            const float3 &rayOrigin,\n            const float pixelFootprint,\n            float4 &diffusivity,\n            float4 &specularity,\n            float4 &transmittance,\n            float4 &emittance,\n            float4 &scatteringCoefficient,\n            float &specularRoughness,\n            float &transmissionRoughness,\n            float &refractiveIndex,\n            bool &doRefraction,\n            int &id)\n    \{\n        float distance = _maxRayDistance;\n        id = 0;\n\n        // numChildren, transformedRay, scale, mods, nextDistance, diffuse colour\n        // roughness, specular colour, specular, transmissive colour, transmission,\n        // emissive colour, emission, refractive index, objectId, blendStrength\n        float parentStack\[MAX_CHILD_DEPTH]\[FULL_PARENT_STACK_PARAMS];\n        int parentStackLength = 0;\n\n        for (int j=0; j < _objectTextureWidth; j++)\n        \{\n            // Read in the shape properties\n            SampleType(positions) position = positions(j, 0);\n            SampleType(rotations) rotation = rotations(j, 0);\n            SampleType(dimensions) dimension = dimensions(j, 0);\n            SampleType(shapeProperties) shapeProperty = shapeProperties(j, 0);\n            SampleType(shapeModParameters0) modParameters0 = shapeModParameters0(j, 0);\n            SampleType(shapeModParameters1) modParameters1 = shapeModParameters1(j, 0);\n            SampleType(diffusivities) diffuseColour = diffusivities(j, 0);\n            SampleType(specularities) specularColour = specularities(j, 0);\n            SampleType(transmittances) transmissiveColour = transmittances(j, 0);\n            SampleType(emittances) emissiveColour = emittances(j, 0);\n            SampleType(scatteringCoefficients) scatteringColour = scatteringCoefficients(j, 0);\n            SampleType(surfaceProperties) surfaceProperty = surfaceProperties(j, 0);\n\n            const int modifications = ((int) shapeProperty.y) | ((int) surfaceProperty.y);\n            float scale = position.w;\n\n            const float blendStrength = shapeProperty.w;\n            float numChildren = shapeProperty.z;\n\n            int stackLastIndex = parentStackLength - 1;\n\n            float4 blendedDiffuseColour = diffuseColour;\n            float4 blendedSpecularColour = specularColour;\n            float4 blendedTransmissiveColour = transmissiveColour;\n            float4 blendedEmissiveColour = emissiveColour;\n            float4 blendedScatteringCoefficient = scatteringColour;\n            float blendedRefractiveIndex = surfaceProperty.x;\n            float blendedTransmissionRoughness = surfaceProperty.z;\n\n            // Position relative to the parent if we have any\n            float3 parentTransformedRay = rayOrigin;\n            if (parentStackLength > 0)\n            \{\n                parentTransformedRay.x = parentStack\[stackLastIndex]\[TRANSFORM_X];\n                parentTransformedRay.y = parentStack\[stackLastIndex]\[TRANSFORM_Y];\n                parentTransformedRay.z = parentStack\[stackLastIndex]\[TRANSFORM_Z];\n                scale *= parentStack\[stackLastIndex]\[SCALE];\n            \}\n\n            // Use parent transform to position child\n            const float3 transformedRay = transformRay(\n                parentTransformedRay,\n                float3(position.x, position.y, position.z),\n                float3(rotation.x, rotation.y, rotation.z),\n                modifications,\n                modParameters0,\n                modParameters1\n            );\n\n            // Get distance to this child\n            float nextDistance = getModifiedDistance(\n                transformedRay,\n                (int) shapeProperty.x,\n                dimension,\n                scale,\n                modifications,\n                modParameters1.w,\n                rotation.w,\n                blendedDiffuseColour,\n                blendedSpecularColour,\n                blendedTransmissiveColour,\n                blendedEmissiveColour,\n                blendedScatteringCoefficient\n            );\n\n            // Track which object was hit for the alpha channel\n            float objectId = (float) j + 1.0f;\n\n            // If this is a bounding volume, we can skip its children\n            // if we aren't close to, or inside it\n            if (\n                modifications & IS_BOUND\n                && numChildren > 0\n                && nextDistance > _hitTolerance + pixelFootprint\n            ) \{\n                // Update the min distance if this bounding volume is closest.\n                // Otherwise we could step through it, or if every object in\n                // the scene is inside it, we would not step forward at all\n                if (fabs(nextDistance) < fabs(distance))\n                \{\n                    distance = nextDistance;\n\n                    diffusivity = blendedDiffuseColour;\n                    specularity = blendedSpecularColour;\n                    transmittance = blendedTransmissiveColour;\n                    emittance = blendedEmissiveColour;\n                    scatteringCoefficient = blendedScatteringCoefficient;\n                    specularRoughness = blendedDiffuseColour.w;\n                    transmissionRoughness = blendedTransmissionRoughness;\n                    refractiveIndex = blendedRefractiveIndex;\n\n                    id = objectId;\n\n                    doRefraction = modifications & 262144;\n                \}\n\n                // This was tagged as a boundary object, skip its children\n                // since we arent close to hitting it\n                j += numChildren;\n\n                for (int parentIndex=stackLastIndex; parentIndex >= 0; parentIndex--)\n                \{\n                    parentStack\[parentIndex]\[NUM_CHILDREN] -= numChildren + 1.0f;\n                \}\n\n                // If there are no parents, or still children of the parent\n                // we do not need to compute anything further for this loop\n                if (parentStackLength <= 0 || parentStack\[stackLastIndex]\[NUM_CHILDREN] > 0.0f)\n                \{\n                    continue;\n                \}\n\n                // pop stack\n                // we know that there will be no more children if we did not continue\n                numChildren = 0.0f;\n                nextDistance = parentStack\[stackLastIndex]\[DISTANCE];\n                blendedDiffuseColour = float4(\n                    parentStack\[stackLastIndex]\[DIFFUSE_COLOUR_R],\n                    parentStack\[stackLastIndex]\[DIFFUSE_COLOUR_G],\n                    parentStack\[stackLastIndex]\[DIFFUSE_COLOUR_B],\n                    parentStack\[stackLastIndex]\[SPECULAR_ROUGHNESS]\n                );\n                blendedSpecularColour = float4(\n                    parentStack\[stackLastIndex]\[SPECULAR_COLOUR_R],\n                    parentStack\[stackLastIndex]\[SPECULAR_COLOUR_G],\n                    parentStack\[stackLastIndex]\[SPECULAR_COLOUR_B],\n                    parentStack\[stackLastIndex]\[SPECULAR]\n                );\n                blendedTransmissiveColour = float4(\n                    parentStack\[stackLastIndex]\[EXTINCTION_R],\n                    parentStack\[stackLastIndex]\[EXTINCTION_G],\n                    parentStack\[stackLastIndex]\[EXTINCTION_B],\n                    parentStack\[stackLastIndex]\[TRANSMISSION]\n                );\n                blendedEmissiveColour = float4(\n                    parentStack\[stackLastIndex]\[EMISSION_R],\n                    parentStack\[stackLastIndex]\[EMISSION_G],\n                    parentStack\[stackLastIndex]\[EMISSION_B],\n                    0\n                );\n                blendedScatteringCoefficient = float4(\n                    parentStack\[stackLastIndex]\[SCATTERING_R],\n                    parentStack\[stackLastIndex]\[SCATTERING_G],\n                    parentStack\[stackLastIndex]\[SCATTERING_B],\n                    0\n                );\n                blendedTransmissionRoughness = parentStack\[stackLastIndex]\[TRANSMISSION_ROUGHNESS];\n                blendedRefractiveIndex = parentStack\[stackLastIndex]\[PARENT_REFRACTIVE_INDEX];\n\n                objectId = parentStack\[stackLastIndex]\[PARENT_OBJECT_ID];\n                stackLastIndex--;\n                parentStackLength--;\n            \}\n\n            if (numChildren <= 0.0f)\n            \{\n                // No Children left, compute interactions with parent\n                if (parentStackLength > 0)\n                \{\n                    // Process this object, along with all parents that do not\n                    // have any more children, removing them from the stack,\n                    // but descend all the way down the stack, without removing\n                    // the objects that still have children\n                    for (int stackIndex=stackLastIndex; stackIndex >= 0; stackIndex--)\n                    \{\n                        const int parentModifications = parentStack\[stackIndex]\[MODIFICATIONS];\n\n                        // Do not need to interact with bounding volumes.\n                        // They are in the stack for relative positioning\n                        // if they weren't then we would have to manually move\n                        // the bounding box to follow the children\n                        const float parentBlendStrength = (\n                            parentStack\[stackIndex]\[BLEND_STRENGTH]\n                        );\n                        const float parentNextDistance = parentStack\[stackIndex]\[DISTANCE];\n                        const float4 parentDiffuseColour = float4(\n                            parentStack\[stackIndex]\[DIFFUSE_COLOUR_R],\n                            parentStack\[stackIndex]\[DIFFUSE_COLOUR_G],\n                            parentStack\[stackIndex]\[DIFFUSE_COLOUR_B],\n                            parentStack\[stackIndex]\[SPECULAR_ROUGHNESS]\n                        );\n                        const float4 parentSpecularColour = float4(\n                            parentStack\[stackIndex]\[SPECULAR_COLOUR_R],\n                            parentStack\[stackIndex]\[SPECULAR_COLOUR_G],\n                            parentStack\[stackIndex]\[SPECULAR_COLOUR_B],\n                            parentStack\[stackIndex]\[SPECULAR]\n                        );\n                        const float4 parentTransmissiveColour = float4(\n                            parentStack\[stackIndex]\[EXTINCTION_R],\n                            parentStack\[stackIndex]\[EXTINCTION_G],\n                            parentStack\[stackIndex]\[EXTINCTION_B],\n                            parentStack\[stackIndex]\[TRANSMISSION]\n                        );\n                        const float4 parentEmissiveColour = float4(\n                            parentStack\[stackIndex]\[EMISSION_R],\n                            parentStack\[stackIndex]\[EMISSION_G],\n                            parentStack\[stackIndex]\[EMISSION_B],\n                            0\n                        );\n                        const float4 parentScatteringCoefficient = float4(\n                            parentStack\[stackIndex]\[SCATTERING_R],\n                            parentStack\[stackIndex]\[SCATTERING_G],\n                            parentStack\[stackIndex]\[SCATTERING_B],\n                            0\n                        );\n                        const float parentTransmissionRoughness = (\n                            parentStack\[stackLastIndex]\[TRANSMISSION_ROUGHNESS]\n                        );\n\n                        const float parentRefractiveIndex = (\n                            parentStack\[stackLastIndex]\[PARENT_REFRACTIVE_INDEX]\n                        );\n\n                        if (fabs(nextDistance) > fabs(parentNextDistance))\n                        \{\n                            objectId = parentStack\[stackIndex]\[PARENT_OBJECT_ID];\n                        \}\n\n                        // Compute interaction between parent and this child\n                        nextDistance = performChildInteraction(\n                            parentModifications,\n                            parentNextDistance,\n                            nextDistance,\n                            parentDiffuseColour,\n                            blendedDiffuseColour,\n                            parentSpecularColour,\n                            blendedSpecularColour,\n                            parentTransmissiveColour,\n                            blendedTransmissiveColour,\n                            parentEmissiveColour,\n                            blendedEmissiveColour,\n                            parentScatteringCoefficient,\n                            blendedScatteringCoefficient,\n                            parentTransmissionRoughness,\n                            blendedTransmissionRoughness,\n                            parentRefractiveIndex,\n                            blendedRefractiveIndex,\n                            parentBlendStrength\n                        );\n\n                        // Update the global min distance (and surface/colour)\n                        if (fabs(nextDistance) < fabs(distance))\n                        \{\n                            distance = nextDistance;\n\n                            diffusivity = blendedDiffuseColour;\n                            specularity = blendedSpecularColour;\n                            transmittance = blendedTransmissiveColour;\n                            emittance = blendedEmissiveColour;\n                            scatteringCoefficient = blendedScatteringCoefficient;\n                            specularRoughness = blendedDiffuseColour.w;\n                            transmissionRoughness = blendedTransmissionRoughness;\n                            refractiveIndex = blendedRefractiveIndex;\n\n                            id = objectId;\n\n                            doRefraction = parentModifications & 262144;\n                        \}\n                    \}\n\n                    do\n                    \{\n                        // Decrement the number of children each parent has\n                        for (int parentIndex=stackLastIndex; parentIndex >= 0; parentIndex--)\n                        \{\n                            parentStack\[parentIndex]\[NUM_CHILDREN] -= 1.0f;\n                        \}\n\n                        // Get the number of children still remaining for the parent\n                        // If there are still children, we can break out of this loop\n                        // to process the rest of them before the parent itself\n                        numChildren = parentStack\[stackLastIndex]\[NUM_CHILDREN];\n                    \}\n                    while (numChildren <= 0.0f && --stackLastIndex >= 0);\n\n                    parentStackLength = stackLastIndex + 1;\n                \}\n                // No parents to interact with, simply check the distance\n                else if (fabs(nextDistance) < fabs(distance))\n                \{\n                    distance = nextDistance;\n\n                    diffusivity = blendedDiffuseColour;\n                    specularity = blendedSpecularColour;\n                    transmittance = blendedTransmissiveColour;\n                    emittance = blendedEmissiveColour;\n                    scatteringCoefficient = blendedScatteringCoefficient;\n                    specularRoughness = blendedDiffuseColour.w;\n                    transmissionRoughness = blendedTransmissionRoughness;\n                    refractiveIndex = blendedRefractiveIndex;\n\n                    id = objectId;\n\n                    doRefraction = modifications & 262144;\n                \}\n            \}\n            else\n            \{\n                // Node has Children, push it to the stack for later\n                // processing when we have all its children\n                // parentStack.push()\n                parentStack\[parentStackLength]\[NUM_CHILDREN] = numChildren;\n                parentStack\[parentStackLength]\[TRANSFORM_X] = transformedRay.x;\n                parentStack\[parentStackLength]\[TRANSFORM_Y] = transformedRay.y;\n                parentStack\[parentStackLength]\[TRANSFORM_Z] = transformedRay.z;\n                parentStack\[parentStackLength]\[SCALE] = scale;\n                parentStack\[parentStackLength]\[MODIFICATIONS] = (float) modifications;\n                parentStack\[parentStackLength]\[BLEND_STRENGTH] = blendStrength;\n                parentStack\[parentStackLength]\[DISTANCE] = nextDistance;\n                parentStack\[parentStackLength]\[DIFFUSE_COLOUR_R] = blendedDiffuseColour.x;\n                parentStack\[parentStackLength]\[DIFFUSE_COLOUR_G] = blendedDiffuseColour.y;\n                parentStack\[parentStackLength]\[DIFFUSE_COLOUR_B] = blendedDiffuseColour.z;\n                parentStack\[parentStackLength]\[SPECULAR_ROUGHNESS] = blendedDiffuseColour.w;\n                parentStack\[parentStackLength]\[SPECULAR_COLOUR_R] = blendedSpecularColour.x;\n                parentStack\[parentStackLength]\[SPECULAR_COLOUR_G] = blendedSpecularColour.y;\n                parentStack\[parentStackLength]\[SPECULAR_COLOUR_B] = blendedSpecularColour.z;\n                parentStack\[parentStackLength]\[SPECULAR] = blendedSpecularColour.w;\n                parentStack\[parentStackLength]\[EXTINCTION_R] = blendedTransmissiveColour.x;\n                parentStack\[parentStackLength]\[EXTINCTION_G] = blendedTransmissiveColour.y;\n                parentStack\[parentStackLength]\[EXTINCTION_B] = blendedTransmissiveColour.z;\n                parentStack\[parentStackLength]\[TRANSMISSION] = blendedTransmissiveColour.w;\n                parentStack\[parentStackLength]\[EMISSION_R] = blendedEmissiveColour.x;\n                parentStack\[parentStackLength]\[EMISSION_G] = blendedEmissiveColour.y;\n                parentStack\[parentStackLength]\[EMISSION_B] = blendedEmissiveColour.z;\n                parentStack\[parentStackLength]\[SCATTERING_R] = blendedScatteringCoefficient.x;\n                parentStack\[parentStackLength]\[SCATTERING_G] = blendedScatteringCoefficient.y;\n                parentStack\[parentStackLength]\[SCATTERING_B] = blendedScatteringCoefficient.z;\n                parentStack\[parentStackLength]\[TRANSMISSION_ROUGHNESS] = blendedTransmissionRoughness;\n                parentStack\[parentStackLength]\[PARENT_REFRACTIVE_INDEX] = blendedRefractiveIndex;\n                parentStack\[parentStackLength]\[PARENT_OBJECT_ID] = objectId;\n                parentStackLength++;\n            \}\n        \}\n\n        diffusivity.w = 1.0f - specularity.w - transmittance.w;\n\n        return distance;\n    \}\n\n\n    /**\n     * Estimate the surface normal at the closest point on the closest\n     * object to a point\n     *\n     * @arg point: The point near which to get the surface normal\n     * @arg pixelFootprint: A value proportional to the amount of world\n     *     space that fills a pixel, like the distance from camera.\n     *\n     * @returns: The normalized surface normal.\n     */\n    float3 estimateSurfaceNormal(const float3 &point, const float pixelFootprint)\n    \{\n        return normalize(\n            __offset0 * getMinDistanceToObjectInScene(\n                point + __offset0 * _hitTolerance,\n                pixelFootprint\n            )\n            + __offset1 * getMinDistanceToObjectInScene(\n                point + __offset1 * _hitTolerance,\n                pixelFootprint\n            )\n            + __offset2 * getMinDistanceToObjectInScene(\n                point + __offset2 * _hitTolerance,\n                pixelFootprint\n            )\n            + __offset3 * getMinDistanceToObjectInScene(\n                point + __offset3 * _hitTolerance,\n                pixelFootprint\n            )\n        );\n    \}\n\n\n    /**\n     * Sample the data of a particular artificial light in the scene.\n     * Artificial lights are any that are passed into the 'lights'\n     * input.\n     *\n     * @arg position: The position on the surface to sample the data of.\n     * @arg lightIndex: The index of the chosen light in the lights\n     *     texture.\n     * @arg numLights: The number of lights in the scene.\n     * @arg lightDirection: The direction from the surface to the light.\n     * @arg distanceToLight: The distance to the light's surface.\n     *\n     * @returns: The PDF of the light.\n     */\n    float sampleArtificialLightData(\n            const float3 &position,\n            const int lightIndex,\n            const int numLights,\n            float3 &lightDirection,\n            float &distanceToLight)\n    \{\n        float visibleSurfaceArea = 1.0f;\n\n        // Selected a 'fake' light eg. point, directional, ambient\n        SampleType(lights) light = lights(lightIndex, 0);\n        const int lightType = abs((int) lightProperties(lightIndex, 0, 3));\n\n        if (lightType > 1)\n        \{\n            getLightData(\n                position,\n                float3(light.x, light.y, light.z),\n                lightType,\n                _maxRayDistance,\n                distanceToLight,\n                visibleSurfaceArea,\n                lightDirection\n            );\n        \}\n\n        return sampleLightsPDF(max(1, numLights), visibleSurfaceArea);\n    \}\n\n\n    /**\n     * Sample the data of a particular physical light in the scene.\n     * Physical lights are any that have an emissive material, rather\n     * than being passed into the 'lights' input with the artificial\n     * lights.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg position: The position on the surface to sample the data of.\n     * @arg objectIndex: The index of the chosen light in the object\n     *     texture.\n     * @arg numLights: The number of lights in the scene.\n     * @arg lightDirection: The direction from the surface to the light.\n     * @arg distanceToLight: The distance to the light's surface.\n     *\n     * @returns: The PDF of the light.\n     */\n    float samplePhysicalLightData(\n            const float3 &seed,\n            const float3 &position,\n            const int objectIndex,\n            const int numLights,\n            float3 &lightDirection,\n            float &distanceToLight)\n    \{\n        float visibleSurfaceArea = 1.0f;\n\n        const float3 objectPosition = getObjectPosition(objectIndex);\n\n        sphericalLightData(\n            seed,\n            position,\n            objectPosition,\n            getRadius(objectIndex),\n            lightDirection,\n            distanceToLight,\n            visibleSurfaceArea\n        );\n\n        if (_maxLightSamplingBounces > 1 && __lightSamplingAngle > 0.0f)\n        \{\n            lightDirection = uniformDirectionInSolidAngle(\n                lightDirection,\n                __lightSamplingAngle,\n                RAND_CONST_0 * seed\n            );\n        \}\n\n        return sampleLightsPDF(max(1, numLights), visibleSurfaceArea);\n    \}\n\n\n    /**\n     * Sample the data of a particular light in the scene.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg position: The position on the surface to sample the data of.\n     * @arg surfaceNormal: The normal to the surface at the position we\n     *     are sampling the data of.\n     * @arg emissiveIndices: The indices of the emissive objects in the\n     *     scene.\n     * @arg numEmissive: The number of emissive objects in the scene.\n     * @arg numLights: The number of lights in the scene.\n     * @arg selectedLight: The index of the chosen light to sample.\n     * @arg lightDirection: The direction from the surface to the light.\n     * @arg distanceToLight: The distance to the light's surface.\n     *\n     * @returns: The PDF of the light.\n     */\n    float sampleLightData(\n            const float3 &seed,\n            const float3 &position,\n            const float3 &surfaceNormal,\n            const int emissiveIndices\[MAX_MIS_EMISSIVE_SHAPES],\n            const int numEmissive,\n            const int numLights,\n            const int selectedLight,\n            float3 &lightDirection,\n            float &distanceToLight)\n    \{\n        float visibleSurfaceArea = 1.0f;\n\n        if (selectedLight < _lightTextureWidth)\n        \{\n            return sampleArtificialLightData(\n                position,\n                selectedLight,\n                numLights,\n                lightDirection,\n                distanceToLight\n            );\n        \}\n        else if (selectedLight - _lightTextureWidth < numEmissive)\n        \{\n            return samplePhysicalLightData(\n                seed,\n                position,\n                emissiveIndices\[selectedLight - _lightTextureWidth],\n                numLights,\n                lightDirection,\n                distanceToLight\n            );\n        \}\n\n        hdriLightData(\n            seed * RAND_CONST_1,\n            surfaceNormal,\n            lightDirection,\n            distanceToLight\n        );\n        return sampleLightsPDF(max(1, numLights), 1.0f);\n    \}\n\n\n    /**\n     * Sample the data of a random light in the scene.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg position: The position on the surface to sample the data of.\n     * @arg surfaceNormal: The normal to the surface at the position we\n     *     are sampling the data of.\n     * @arg emissiveIndices: The indices of the emissive objects in the\n     *     scene.\n     * @arg numEmissive: The number of emissive objects in the scene.\n     * @arg sampleHDRI: Whether or not to sample the HDRI. If there are\n     *     lights in the scene this will increase the noise, but will be\n     *     more accurate.\n     * @arg lightDirection: The direction from the surface to the light.\n     * @arg distanceToLight: The distance to the light's surface.\n     * @arg selectedLight: The index of the chosen light to sample.\n     *\n     * @returns: The PDF of the light.\n     */\n    float sampleRandomLightData(\n            const float3 &seed,\n            const float3 &position,\n            const float3 &surfaceNormal,\n            const int emissiveIndices\[MAX_MIS_EMISSIVE_SHAPES],\n            const int numEmissive,\n            const bool sampleHDRI,\n            float3 &lightDirection,\n            float &distanceToLight,\n            int &selectedLight)\n    \{\n        const float rng = random(random(seed.x + seed.y) + random(seed.z));\n        const int numSamplingOptions = (\n            numEmissive\n            + _lightTextureWidth\n            + sampleHDRI\n        );\n        selectedLight = max(0, (int) floor(rng * (numSamplingOptions - 0.0001f)));\n\n        return sampleLightData(\n            seed,\n            position,\n            surfaceNormal,\n            emissiveIndices,\n            numEmissive,\n            numSamplingOptions,\n            selectedLight,\n            lightDirection,\n            distanceToLight\n        );\n    \}\n\n\n    /**\n     * Compute a soft shadow value.\n     *\n     * @arg rayOrigin: The origin of the ray.\n     * @arg rayDirection: The direction to cast the shadow ray.\n     * @arg distanceToShadePoint: The maximum distance to check for\n     *     a shadow casting object.\n     * @arg softness: The softness of the shadow.\n     *\n     * @returns: The shadow intenstity.\n     */\n    inline float sampleSoftShadow(\n            const float3 &rayOrigin,\n            const float3 &rayDirection,\n            const float distanceToShadePoint,\n            const float softness)\n    \{\n        float distanceTravelled = 0;\n        float shadowIntensity = 1.0f;\n        float lastStepDistance = FLT_MAX;\n\n        int iterations = 0;\n        float pixelFootprint = _hitTolerance;\n\n        float3 position = rayOrigin;\n        while (distanceTravelled < distanceToShadePoint && iterations < _maxRaySteps / 2)\n        \{\n            const float stepDistance = fabs(\n                getMinDistanceToObjectInScene(position, pixelFootprint)\n            );\n            const float stepDistanceSquared = stepDistance * stepDistance;\n            float softOffset = stepDistanceSquared / (2.0f * lastStepDistance);\n            shadowIntensity = min(\n                shadowIntensity,\n                softness * sqrt(stepDistanceSquared - softOffset * softOffset)\n                / max(0.0f, distanceTravelled - softOffset)\n            );\n\n            if (stepDistance < pixelFootprint)\n            \{\n                shadowIntensity = saturate(shadowIntensity);\n                return shadowIntensity * shadowIntensity * (3.0f - 2.0f * shadowIntensity);\n            \}\n\n            lastStepDistance = stepDistance;\n            position += rayDirection * stepDistance;\n            distanceTravelled += stepDistance;\n            pixelFootprint += stepDistance * _hitTolerance;\n            iterations++;\n        \}\n\n        shadowIntensity = saturate(shadowIntensity);\n        return shadowIntensity * shadowIntensity * (3.0f - 2.0f * shadowIntensity);\n    \}\n\n\n    /**\n     * Compute a shadow value.\n     *\n     * @arg rayOrigin: The origin of the ray.\n     * @arg rayDirection: The direction to cast the shadow ray.\n     * @arg distanceToShadePoint: The maximum distance to check for\n     *     a shadow casting object.\n     *\n     * @returns: The shadow intenstity.\n     */\n    float sampleShadow(\n            const float3 &rayOrigin,\n            const float3 &rayDirection,\n            const float distanceToShadePoint)\n    \{\n        float distanceTravelled = 0;\n        int iterations = 0;\n        float pixelFootprint = _hitTolerance;\n        float3 position = rayOrigin;\n\n        while (distanceTravelled < distanceToShadePoint && iterations < _maxRaySteps / 2)\n        \{\n            const float stepDistance = fabs(\n                getMinDistanceToObjectInScene(position, pixelFootprint)\n            );\n\n            if (stepDistance < pixelFootprint)\n            \{\n                return 0;\n            \}\n\n            position += rayDirection * stepDistance;\n            distanceTravelled += stepDistance;\n            pixelFootprint += stepDistance * _hitTolerance;\n            iterations++;\n        \}\n\n        return 1;\n    \}\n\n\n    /**\n     * Compute the ambient occlusion.\n     *\n     * @arg rayOrigin: The origin of the ray.\n     * @arg surfaceNormal: The normal to the surface.\n     * @arg amount: The amount to scale the occlusion value by.\n     * @arg iterations: The number of iterations to refine the\n     *     occlusion.\n     *\n     * @returns: The occlusion value.\n     */\n    inline float sampleAmbientOcclusion(\n            const float3 &rayOrigin,\n            const float3 &surfaceNormal,\n            const float amount,\n            const int iterations)\n    \{\n        float occlusion = 0.0f;\n        float occlusionScaleFactor = 1.0f;\n        for (int iteration=0; iteration < iterations; iteration++)\n        \{\n            const float stepDistance = 0.001f + 0.15f * float(iteration) / 4.0f;\n            const float distanceToClosestObject = fabs(\n                getMinDistanceToObjectInScene(\n                    rayOrigin + stepDistance * surfaceNormal,\n                    _hitTolerance\n                )\n            );\n            occlusion += (stepDistance - distanceToClosestObject) * occlusionScaleFactor;\n            occlusionScaleFactor *= 0.95;\n        \}\n\n        return (\n            amount\n            * saturate(0.5f + 0.5f * surfaceNormal.y)  // ambient\n            * saturate(1.0f - 1.5f * occlusion)       // occlusion\n        );\n    \}\n\n\n    /**\n     * Perform direct illumination light sampling on a chosen artificial\n     * light in the scene.\n     *\n     * @arg pointOnSurface: The point on the surface to compute the\n     *     light intensity at.\n     * @arg surfaceNormal: The normal to the surface at the position we\n     *     are sampling the illumination of.\n     * @arg lightDirection: The direction from the surface to the light.\n     * @arg distanceToLight: The distance to the light's surface.\n     * @arg selectedLight: The index of the chosen light to sample.\n     *\n     * @returns: The colour of the sampled light.\n     */\n    inline float4 sampleArtificialLight(\n            const float3 &pointOnSurface,\n            const float3 &surfaceNormal,\n            const float3 &lightDirection,\n            const float distanceToLight,\n            const int selectedLight)\n    \{\n        // Read the light properties\n        SampleType(lights) light = lights(selectedLight, 0);\n        SampleType(lightProperties) lightProperty = lightProperties(selectedLight, 0);\n        SampleType(lightProperties1) lightProperty1 = lightProperties1(selectedLight, 0);\n\n        float2 intensity;\n\n        int lightType = (int) lightProperty.w;\n        int absLightType = abs(lightType);\n\n        if (absLightType == 0)\n        \{\n            // Ambient light, simply return the intensity.\n            intensity = float2(light.w, 1);\n        \}\n        else if (absLightType == 1)\n        \{\n            intensity = float2(\n                1.0f,\n                sampleAmbientOcclusion(\n                    pointOnSurface,\n                    surfaceNormal,\n                    light.w,\n                    (int) light.x\n                )\n            );\n        \}\n        else\n        \{\n            float intensityAtPosition = lightIntensity(\n                light.w,\n                lightProperty1.y,\n                distanceToLight\n            );\n\n            float shadowIntensityAtPosition;\n            if (lightType < 0)\n            \{\n                shadowIntensityAtPosition = sampleSoftShadow(\n                    pointOnSurface,\n                    lightDirection,\n                    distanceToLight,\n                    lightProperty1.x\n                );\n            \}\n            else\n            \{\n                shadowIntensityAtPosition = sampleShadow(\n                    pointOnSurface,\n                    lightDirection,\n                    distanceToLight\n                );\n            \}\n\n            intensity = float2(intensityAtPosition, shadowIntensityAtPosition);\n        \}\n\n        return intensity.x * intensity.y * float4(\n            lightProperty.x,\n            lightProperty.y,\n            lightProperty.z,\n            0\n        );\n    \}\n\n\n    /**\n     * Perform direct illumination light sampling on every artificial\n     * light in the scene.\n     *\n     * @arg position: The position on the surface to sample the\n     *     illumination of.\n     * @arg surfaceNormal: The surface normal at the intersection point.\n     * @arg throughput: The throughput of the ray.\n     * @arg materialBRDF: The BRDF of the surface at the position we\n     *     are sampling the illumination of.\n     * @arg materialPDF: The PDF of the material we are sampling the\n     *     direct illumination of.\n     *\n     * @returns: The colour of the sampled light.\n     */\n    inline float4 sampleArtificialLights(\n            const float3 &position,\n            const float3 &surfaceNormal,\n            const float4 &throughput,\n            const float4 &materialBRDF,\n            const float materialPDF)\n    \{\n        float4 lightColour = float4(0);\n\n        for (int lightIndex=0; lightIndex < _lightTextureWidth; lightIndex++)\n        \{\n            float3 lightDirection = surfaceNormal;\n            float distanceToLight = 0.0f;\n\n            const float lightPDF = sampleArtificialLightData(\n                position,\n                lightIndex,\n                _lightTextureWidth,\n                lightDirection,\n                distanceToLight\n            );\n\n            float geometryFactor = saturate(dot(lightDirection, surfaceNormal));\n\n            lightColour += multipleImportanceSample(\n                sampleArtificialLight(\n                    position,\n                    surfaceNormal,\n                    lightDirection,\n                    distanceToLight,\n                    lightIndex\n                ),\n                throughput * materialBRDF * geometryFactor / lightPDF,\n                lightPDF,\n                materialPDF * geometryFactor\n            );\n        \}\n\n        return lightColour;\n    \}\n\n\n    /**\n     * Handle the interaction between a ray and the surface of a material.\n     *\n     * @arg pixelFootprint: A value proportional to the amount of world\n     *     space that fills a pixel, like the distance from camera.\n     * @arg distance: The distance travelled since the last bounce.\n     * @arg intersectionPosition: The position at which the ray\n     *     intersects the geometry.\n     * @arg surfaceNormal: The surface normal at the intersection point.\n     * @arg objectId: The ID of the object that was hit.\n     * @arg doRefraction: Whether or not refraction is enabled on the\n     *     material.\n     * @arg numLights: The number of lights in the scene.\n     * @arg seed: The seed to use in randomization.\n     * @arg direction: The incoming ray direction.\n     * @arg origin: The ray origin.\n     * @arg diffusivity: The diffuse values of the surface.\n     * @arg specularity: The specular values of the surface.\n     * @arg transmittance: The extinction coefficient and transmissive\n     *     probability of the surface.\n     * @arg emittance: The emissive values of the surface.\n     * @arg specularRoughness: The specular roughness of the surface.\n     * @arg transmissionRoughness: The transmissive roughness of the\n     *     surface.\n     * @arg refractiveIndex: The refractive index of the material.\n     * @arg scatteringCoefficient: The scattering coefficient of the\n     *     material.\n     * @arg nestedDielectrics: The stack of dielectrics that we have\n     *     entered without exiting.\n     * @arg numNestedDielectrics: The number of dielectrics in the\n     *     stack.\n     * @arg rayColour: The colour of the ray.\n     * @arg throughput: The throughput of the ray.\n     * @arg previousMaterialPDF: The PDF of the last material interacted\n     *     with.\n     */\n    void materialInteraction(\n            const float pixelFootprint,\n            const float distance,\n            const float3 &intersectionPosition,\n            const float3 &surfaceNormal,\n            const int objectId,\n            const bool doRefraction,\n            const float numLights,\n            float3 &seed,\n            float3 &direction,\n            float3 &origin,\n            float4 &diffusivity,\n            float4 &specularity,\n            float4 &transmittance,\n            float4 &emittance,\n            float &specularRoughness,\n            float &transmissionRoughness,\n            float &refractiveIndex,\n            float4 &scatteringCoefficient,\n            float nestedDielectrics\[MAX_NESTED_DIELECTRICS]\[NESTED_DIELECTRIC_PARAMS],\n            int &numNestedDielectrics,\n            float4 &rayColour,\n            float4 &throughput,\n            float &previousMaterialPDF)\n    \{\n        // Use the noise to modify the surface properties\n        noiseMaterialInteraction(\n            objectId - 1,\n            intersectionPosition,\n            diffusivity,\n            specularity,\n            transmittance,\n            emittance,\n            specularRoughness,\n            transmissionRoughness,\n            refractiveIndex\n        );\n\n        // Compute the amount we would offset a point to escape the surface\n        const float offset = 2.0f * pixelFootprint * _shadowBias;\n\n        const float4 extinctionCoefficient = getExtinctionCoefficient(\n            nestedDielectrics,\n            numNestedDielectrics\n        );\n        throughput *= exp(-distance * extinctionCoefficient);\n\n        origin = intersectionPosition;\n\n        // Get material data for material and light sampling\n        float4 materialBRDF;\n        float3 bounceDirection;\n        float materialLightPDF;\n        const float materialPDF = sampleMaterial(\n            seed,\n            surfaceNormal,\n            direction,\n            diffusivity,\n            offset,\n            transmittance,\n            doRefraction,\n            refractiveIndex,\n            scatteringCoefficient,\n            transmissionRoughness,\n            specularity,\n            specularRoughness,\n            objectId,\n            isExitingObject(\n                nestedDielectrics\[numNestedDielectrics]\[OBJECT_ID] - 1,\n                objectId - 1\n            ),\n            materialBRDF,\n            bounceDirection,\n            origin,\n            nestedDielectrics,\n            numNestedDielectrics,\n            materialLightPDF\n        );\n\n        if (\n            __lightSamplingEnabled\n            && _doSecondaryLightSampling\n            && materialLightPDF > 0.0f\n            && _lightTextureWidth > 0\n        ) \{\n            const float3 offsetPosition = offsetPoint(\n                origin,\n                surfaceNormal,\n                offset\n            );\n            // Perform MIS light sampling\n            rayColour += sampleArtificialLights(\n                offsetPosition,\n                surfaceNormal,\n                throughput,\n                materialBRDF,\n                materialLightPDF\n            );\n        \}\n\n        const float radius = getRadius(objectId - 1);\n        const float visibleSurfaceArea = 2.0f * PI * radius * radius;\n\n        rayColour += multipleImportanceSample(\n            emittance,\n            throughput,\n            previousMaterialPDF,\n            sampleLightsPDF(numLights, visibleSurfaceArea)\n        );\n\n        throughput *= materialBRDF / materialPDF;\n\n        // Prepare the variables for the next march\n        previousMaterialPDF = materialPDF;\n\n        direction = bounceDirection;\n    \}\n\n\n    /**\n     * March a path through the scene, with only MIS material and\n     * artifical light sampling.\n     *\n     * @arg rayOrigin: The origin of the ray.\n     * @arg rayDirection: The direction of the ray.\n     * @arg initialSeed: The seed to use in randomization.\n     * @arg sampleHDRI: Whether or not to sample the HDRI. If there are\n     *     lights in the scene this will increase the noise, but will be\n     *     more accurate.\n     * @arg maxRayDistance: The maximum distance the ray can travel.\n     * @arg currentNestedDielectrics: The stack of dielectrics that we\n     *     have entered without exiting.\n     * @arg currentNumNestedDielectrics: The number of dielectrics in\n     *     the stack.\n     * @arg numEmissive: The number of emissive objects in the scene.\n     * @arg distanceTravelled: Location to store the distance the ray\n     *     actually travels.\n     *\n     * @returns: The ray colour.\n     */\n    inline float4 marchPath(\n            const float3 &rayOrigin,\n            const float3 &rayDirection,\n            const float3 &initialSeed,\n            const bool sampleHDRI,\n            const float maxRayDistance,\n            const float currentNestedDielectrics\[MAX_NESTED_DIELECTRICS]\[NESTED_DIELECTRIC_PARAMS],\n            const int currentNumNestedDielectrics,\n            const int numEmissive,\n            float &distanceTravelled)\n    \{\n        const int numLights = _lightTextureWidth + numEmissive + sampleHDRI;\n\n        float nestedDielectrics\[MAX_NESTED_DIELECTRICS]\[NESTED_DIELECTRIC_PARAMS];\n        for (int nestedIndex=0; nestedIndex <= currentNumNestedDielectrics; nestedIndex++)\n        \{\n            for (int dataIndex=0; dataIndex < NESTED_DIELECTRIC_PARAMS; dataIndex++)\n            \{\n                nestedDielectrics\[nestedIndex]\[dataIndex] = (\n                    currentNestedDielectrics\[nestedIndex]\[dataIndex]\n                );\n            \}\n        \}\n        int numNestedDielectrics = currentNumNestedDielectrics;\n\n        float4 rayColour = float4(0);\n        float4 throughput = float4(1);\n\n        float lastStepDistance = 1.0f;\n\n        float firstObjectId = 0.0f;\n\n        int iterations = 0;\n        int bounces = 0;\n\n        distanceTravelled = 0;\n        float distanceSinceLastBounce = distanceTravelled;\n\n        // Get the next ray\n        float3 origin = rayOrigin;\n        float3 direction = rayDirection;\n        float3 positionOnRay = origin;\n\n        float4 diffusivity;\n        float4 specularity;\n        float4 transmittance;\n        float4 emittance;\n\n        float pixelFootprint = _hitTolerance;\n\n        float previousMaterialPDF = 1.0f;\n\n        float3 seed = initialSeed;\n\n        // March the ray\n        while (\n            distanceTravelled < maxRayDistance\n            && iterations < _maxRaySteps\n            && sumComponent(throughput) > _hitTolerance\n        ) \{\n            positionOnRay = origin + distanceSinceLastBounce * direction;\n\n            // Get the closest distance to an object\n            bool doRefraction = true;\n            float4 scatteringCoefficient = float4(0);\n            float specularRoughness = 0.0f;\n            float transmissionRoughness = 0.0f;\n            float refractiveIndex = 1.0f;\n            int objectId = 0;\n\n            const float signedStepDistance = getMinDistanceToObjectInScene(\n                positionOnRay,\n                pixelFootprint,\n                diffusivity,\n                specularity,\n                transmittance,\n                emittance,\n                scatteringCoefficient,\n                specularRoughness,\n                transmissionRoughness,\n                refractiveIndex,\n                doRefraction,\n                objectId\n            );\n\n            // Get the absolute value, the true shortest distance to a\n            // surface\n            const float stepDistance = fabs(signedStepDistance);\n\n            // Keep track of the distance the ray has travelled\n            distanceTravelled += stepDistance;\n            distanceSinceLastBounce += stepDistance;\n\n            // Have we hit the nearest object?\n            if (stepDistance < pixelFootprint)\n            \{\n                float3 intersectionPosition = positionOnRay + stepDistance * direction;\n\n                // The normal to the surface at that position\n                float3 surfaceNormal = sign(lastStepDistance) * estimateSurfaceNormal(\n                    intersectionPosition,\n                    pixelFootprint\n                );\n\n                materialInteraction(\n                    pixelFootprint,\n                    distanceSinceLastBounce,\n                    intersectionPosition,\n                    surfaceNormal,\n                    objectId,\n                    doRefraction,\n                    numLights,\n                    seed,\n                    direction,\n                    origin,\n                    diffusivity,\n                    specularity,\n                    transmittance,\n                    emittance,\n                    specularRoughness,\n                    transmissionRoughness,\n                    refractiveIndex,\n                    scatteringCoefficient,\n                    nestedDielectrics,\n                    numNestedDielectrics,\n                    rayColour,\n                    throughput,\n                    previousMaterialPDF\n                );\n\n                // Exit if we have reached the bounce limit\n                // or with a random chance\n                const float rng = random(random(seed.x) + random(seed.y + random(seed.z)));\n                const float exitProbability = max(\n                    throughput.x,\n                    throughput.y,\n                    throughput.z\n                );\n                if (\n                    ++bounces > _maxLightSamplingBounces\n                    || emittance.w > 0.0f\n                    || (_roulette && exitProbability <= rng)\n                ) \{\n                    return rayColour;\n                \}\n                if (_roulette)\n                \{\n                    // Account for the lost intensity from the early exits\n                    throughput /= exitProbability;\n                \}\n\n                // Update the random seed\n                seed = RAND_CONST_8 * random(\n                    seed\n                    + rng\n                    + random(fabs(intersectionPosition + direction))\n                );\n\n                // Reset the pixel footprint so multiple reflections don't\n                // reduce precision\n                pixelFootprint = _hitTolerance;\n            \}\n            else if (_levelOfDetail)\n            \{\n                pixelFootprint += _hitTolerance * stepDistance;\n            \}\n\n            lastStepDistance = signedStepDistance;\n            iterations++;\n        \}\n\n        distanceTravelled = (\n            distanceSinceLastBounce\n            + _maxRayDistance\n            - distanceTravelled\n        );\n\n        // Read the hdri value in the direction the ray was last travelling\n        // and absorb an amount of light proportional to the distance travelled\n        // through the last material\n        rayColour += (\n            throughput\n            * readHDRIValue(direction)\n            * getScatteringCoefficient(\n                nestedDielectrics,\n                numNestedDielectrics\n            ) * exp(\n                -distanceTravelled\n                * getExtinctionCoefficient(\n                    nestedDielectrics,\n                    numNestedDielectrics\n                )\n            )\n        );\n\n        return rayColour;\n    \}\n\n\n    /**\n     * Perform direct illumination light sampling on a chosen light in\n     * the scene.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg throughput: The throughput of the ray.\n     * @arg materialBRDF: The BRDF of the surface at the position we\n     *     are sampling the illumination of.\n     * @arg distanceToLight: The distance to the light's surface.\n     * @arg surfaceNormal: The normal to the surface at the position we\n     *     are sampling the illumination of.\n     * @arg position: The position on the surface to sample the\n     *     illumination of.\n     * @arg lightDirection: The direction from the surface to the light.\n     * @arg lightPDF: The PDF of the light we are sampling the\n     *     direct illumination of.\n     * @arg materialPDF: The PDF of the material we are sampling the\n     *     direct illumination of.\n     * @arg selectedLight: The index of the chosen light to sample.\n     * @arg numEmissive: The number of emissive objects in the scene.\n     * @arg sampleHDRI: Whether or not to sample the HDRI. If there are\n     *     lights in the scene this will increase the noise, but will be\n     *     more accurate.\n     * @arg nestedDielectrics: The stack of dielectrics that we have\n     *     entered without exiting.\n     * @arg numNestedDielectrics: The number of dielectrics in the\n     *     stack.\n     *\n     * @returns: The colour of the sampled light.\n     */\n    float4 sampleLight(\n            const float3 &seed,\n            const float4 &throughput,\n            const float4 &materialBRDF,\n            const float distanceToLight,\n            const float3 &surfaceNormal,\n            const float3 &position,\n            const float3 &lightDirection,\n            const float lightPDF,\n            const float materialPDF,\n            const int selectedLight,\n            const int numEmissive,\n            const bool sampleHDRI,\n            const float nestedDielectrics\[MAX_NESTED_DIELECTRICS]\[NESTED_DIELECTRIC_PARAMS],\n            const int numNestedDielectrics)\n    \{\n        float4 lightColour = float4(0);\n        float lightGeometryFactor;\n\n        if (selectedLight < _lightTextureWidth)\n        \{\n            lightColour = sampleArtificialLight(\n                position,\n                surfaceNormal,\n                lightDirection,\n                distanceToLight,\n                selectedLight\n            );\n            lightGeometryFactor = saturate(dot(lightDirection, surfaceNormal));\n        \}\n        else if (selectedLight - _lightTextureWidth - sampleHDRI < numEmissive)\n        \{\n            float actualDistance;\n            lightColour = marchPath(\n                position,\n                lightDirection,\n                seed,\n                sampleHDRI,\n                distanceToLight * 2.0f,\n                nestedDielectrics,\n                numNestedDielectrics,\n                numEmissive,\n                actualDistance\n            );\n            lightGeometryFactor = geometryFactor(\n                lightDirection,\n                surfaceNormal,\n                actualDistance\n            );\n        \}\n\n        return multipleImportanceSample(\n            lightColour,\n            throughput * materialBRDF * lightGeometryFactor / lightPDF,\n            lightPDF,\n            materialPDF * lightGeometryFactor\n        );\n    \}\n\n\n\n    /**\n     * Perform direct illumination light sampling on a random light in\n     * the scene.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg throughput: The throughput of the ray.\n     * @arg materialBRDF: The BRDF of the surface at the position we\n     *     are sampling the illumination of.\n     * @arg surfaceNormal: The normal to the surface at the position we\n     *     are sampling the illumination of.\n     * @arg position: The position on the surface to sample the\n     *     illumination of.\n     * @arg materialPDF: The PDF of the material we are sampling the\n     *     direct illumination of.\n     * @arg emissiveIndices: The indices of the emissive objects in the\n     *     scene.\n     * @arg numEmissive: The number of emissive objects in the scene.\n     * @arg sampleHDRI: Whether or not to sample the HDRI. If there are\n     *     lights in the scene this will increase the noise, but will be\n     *     more accurate.\n     * @arg nestedDielectrics: The stack of dielectrics that we have\n     *     entered without exiting.\n     * @arg numNestedDielectrics: The number of dielectrics in the\n     *     stack.\n     *\n     * @returns: The colour of the sampled light.\n     */\n    inline float4 sampleRandomLight(\n            const float3 &seed,\n            const float4 &throughput,\n            const float4 &materialBRDF,\n            const float3 &surfaceNormal,\n            const float3 &position,\n            const float materialPDF,\n            const int emissiveIndices\[MAX_MIS_EMISSIVE_SHAPES],\n            const int numEmissive,\n            const bool sampleHDRI,\n            const float nestedDielectrics\[MAX_NESTED_DIELECTRICS]\[NESTED_DIELECTRIC_PARAMS],\n            const int numNestedDielectrics)\n    \{\n        float3 lightDirection = surfaceNormal;\n        float distanceToLight = 0.0f;\n        int selectedLight;\n\n        // Get data for light sampling\n        float lightPDF = sampleRandomLightData(\n            seed,\n            position,\n            surfaceNormal,\n            emissiveIndices,\n            numEmissive,\n            sampleHDRI,\n            lightDirection,\n            distanceToLight,\n            selectedLight\n        );\n\n        // Perform MIS light sampling\n        return sampleLight(\n            seed * RAND_CONST_2,\n            throughput,\n            materialBRDF,\n            distanceToLight,\n            surfaceNormal,\n            position,\n            lightDirection,\n            lightPDF,\n            materialPDF,\n            selectedLight,\n            numEmissive,\n            sampleHDRI,\n            nestedDielectrics,\n            numNestedDielectrics\n        );\n    \}\n\n\n    /**\n     * Perform direct illumination light sampling on every light in the\n     * scene.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg throughput: The throughput of the ray.\n     * @arg materialBRDF: The BRDF of the surface at the position we\n     *     are sampling the illumination of.\n     * @arg surfaceNormal: The normal to the surface at the position we\n     *     are sampling the illumination of.\n     * @arg position: The position on the surface to sample the\n     *     illumination of.\n     * @arg materialPDF: The PDF of the material we are sampling the\n     *     direct illumination of.\n     * @arg emissiveIndices: The indices of the emissive objects in the\n     *     scene.\n     * @arg numEmissive: The number of emissive objects in the scene.\n     * @arg sampleHDRI: Whether or not to sample the HDRI. If there are\n     *     lights in the scene this will increase the noise, but will be\n     *     more accurate.\n     * @arg nestedDielectrics: The stack of dielectrics that we have\n     *     entered without exiting.\n     * @arg numNestedDielectrics: The number of dielectrics in the\n     *     stack.\n     *\n     * @returns: The colour of the sampled light.\n     */\n    inline float4 sampleLights(\n            const float3 &seed,\n            const float4 &throughput,\n            const float4 &materialBRDF,\n            const float3 &surfaceNormal,\n            const float3 &position,\n            const float materialPDF,\n            const int emissiveIndices\[MAX_MIS_EMISSIVE_SHAPES],\n            const int numEmissive,\n            const bool sampleHDRI,\n            const float nestedDielectrics\[MAX_NESTED_DIELECTRICS]\[NESTED_DIELECTRIC_PARAMS],\n            const int numNestedDielectrics)\n    \{\n        float4 lightColour = float4(0);\n        const int numLights = numEmissive + _lightTextureWidth + sampleHDRI;\n\n        for (int path=0; path < numLights; path++)\n        \{\n            float3 lightDirection = surfaceNormal;\n            float distanceToLight = 0.0f;\n\n            const float lightPDF = sampleLightData(\n                seed * RAND_CONST_3 / (path + 1),\n                position,\n                surfaceNormal,\n                emissiveIndices,\n                numEmissive,\n                numLights,\n                path,\n                lightDirection,\n                distanceToLight\n            );\n\n            lightColour += sampleLight(\n                seed * RAND_CONST_4 * (path + 1),\n                throughput,\n                materialBRDF,\n                distanceToLight,\n                surfaceNormal,\n                position,\n                lightDirection,\n                lightPDF,\n                materialPDF,\n                path,\n                numEmissive,\n                sampleHDRI,\n                nestedDielectrics,\n                numNestedDielectrics\n            );\n        \}\n\n        return lightColour;\n    \}\n\n\n    /**\n     * Perform direct illumination light sampling.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg throughput: The throughput of the ray.\n     * @arg materialBRDF: The BRDF of the surface at the position we\n     *     are sampling the illumination of.\n     * @arg surfaceNormal: The normal to the surface at the position we\n     *     are sampling the illumination of.\n     * @arg position: The position on the surface to sample the\n     *     illumination of.\n     * @arg materialPDF: The PDF of the material we are sampling the\n     *     direct illumination of.\n     * @arg offset: The amount to offset the ray in order to escape the\n     *     surface.\n     * @arg emissiveIndices: The indices of the emissive objects in the\n     *     scene.\n     * @arg numEmissive: The number of emissive objects in the scene.\n     * @arg sampleHDRI: Whether or not to sample the HDRI. If there are\n     *     lights in the scene this will increase the noise, but will be\n     *     more accurate.\n     * @arg nestedDielectrics: The stack of dielectrics that we have\n     *     entered without exiting.\n     * @arg numNestedDielectrics: The number of dielectrics in the\n     *     stack.\n     *\n     * @returns: The colour of the sampled light.\n     */\n    inline float4 lightSampling(\n            const float3 &seed,\n            const float4 &throughput,\n            const float4 &materialBRDF,\n            const float3 &surfaceNormal,\n            const float3 &position,\n            const float materialPDF,\n            const float offset,\n            const int emissiveIndices\[MAX_MIS_EMISSIVE_SHAPES],\n            const int numEmissive,\n            const bool sampleHDRI,\n            const float nestedDielectrics\[MAX_NESTED_DIELECTRICS]\[NESTED_DIELECTRIC_PARAMS],\n            const int numNestedDielectrics)\n    \{\n        const float3 offsetPosition = offsetPoint(\n            position,\n            surfaceNormal,\n            offset\n        );\n        if (_sampleAllLights)\n        \{\n            return sampleLights(\n                seed,\n                throughput,\n                materialBRDF,\n                surfaceNormal,\n                offsetPosition,\n                materialPDF,\n                emissiveIndices,\n                numEmissive,\n                sampleHDRI,\n                nestedDielectrics,\n                numNestedDielectrics\n            );\n        \}\n        return sampleRandomLight(\n            seed,\n            throughput,\n            materialBRDF,\n            surfaceNormal,\n            offsetPosition,\n            materialPDF,\n            emissiveIndices,\n            numEmissive,\n            sampleHDRI,\n            nestedDielectrics,\n            numNestedDielectrics\n        );\n    \}\n\n\n    /**\n     * Perform equi-angular sampling for participating media.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg intersectionPosition: The position at which the ray\n     *     intersects the geometry.\n     * @arg rayOrigin: The ray origin.\n     * @arg rayDirection: The incoming ray direction.\n     * @arg distanceSinceLastBounce: The distance travelled since the\n     *     last bounce.\n     * @arg emissiveIndices: The indices of the emissive objects in the\n     *     scene.\n     * @arg numEmissive: The number of emissive objects in the scene.\n     * @arg nestedDielectrics: The stack of dielectrics that we have\n     *     entered without exiting.\n     * @arg numNestedDielectrics: The number of dielectrics in the\n     *     stack.\n     * @arg throughput: The throughput of the ray.\n     *\n     * @returns: The colour of the ray.\n     */\n    float4 sampleEquiangular(\n            const float3 &seed,\n            const float3 &intersectionPosition,\n            const float3 &rayOrigin,\n            const float3 &rayDirection,\n            const float distanceSinceLastBounce,\n            const int emissiveIndices\[MAX_MIS_EMISSIVE_SHAPES],\n            const int numEmissive,\n            const float nestedDielectrics\[MAX_NESTED_DIELECTRICS]\[NESTED_DIELECTRIC_PARAMS],\n            const int numNestedDielectrics,\n            float4 &throughput)\n    \{\n        // Get the scattering coefficient of the material we are in\n        const float4 scatteringCoefficient = getScatteringCoefficient(\n            nestedDielectrics,\n            numNestedDielectrics\n        );\n        const float4 extinctionCoefficient = getExtinctionCoefficient(\n            nestedDielectrics,\n            numNestedDielectrics\n        );\n        float4 scatteredColour = float4(0);\n\n        if (\n            !__equiangularSamplingEnabled\n            || (\n                length(scatteringCoefficient) <= 0.0f\n                && length(extinctionCoefficient) <= 0.0f\n            )\n        ) \{\n            throughput *= exp(-extinctionCoefficient * distanceSinceLastBounce);\n            return scatteredColour;\n        \}\n\n        int objectIndex = nestedDielectrics\[numNestedDielectrics]\[OBJECT_ID] - 1;\n        if (objectIndex < 0)\n        \{\n            // blink cannot handle single pixel images in versions < 12.1\n            // so we have a weird dummy pixel when only one object is passed\n            // to the scene\n            objectIndex = _objectTextureWidth == 0 ? 1 : _objectTextureWidth;\n        \}\n\n        const float offset = random(random(seed.z) + random(seed.y + random(seed.x)));\n\n        float extinctionNoiseSum = 0.0f;\n\n        for (int step=1; step <= _equiangularSamples; step++)\n        \{\n            const float uniform = (step + offset - 1) / (float) _equiangularSamples;\n\n            float3 surfaceNormal = randomUnitVector(seed * RAND_CONST_5);\n            float3 lightDirection = surfaceNormal;\n            float distanceToLight = 0.0f;\n            int selectedLight;\n\n            const float lightPDF = sampleRandomLightData(\n                seed * RAND_CONST_6 * step,\n                intersectionPosition,\n                surfaceNormal,\n                emissiveIndices,\n                numEmissive,\n                _sampleHDRIEquiangular,\n                lightDirection,\n                distanceToLight,\n                selectedLight\n            );\n            const float3 lightPosition = intersectionPosition + lightDirection * distanceToLight;\n\n            float equiangularDistance;\n            float equiangularPDF = _equiangularSamples * sampleEquiangularPDF(\n                uniform,\n                distanceSinceLastBounce,\n                rayOrigin,\n                rayDirection,\n                lightPosition,\n                equiangularDistance\n            );\n\n            const float3 particlePosition = rayOrigin + equiangularDistance * rayDirection;\n            const float3 particleToLight = lightPosition - particlePosition;\n            distanceToLight = length(particleToLight);\n\n            if (distanceToLight > 0.0f)\n            \{\n                lightDirection = normalize(particleToLight);\n            \}\n\n            int noiseOptions;\n            float noiseValue = getNoiseValue(\n                objectIndex,\n                particlePosition,\n                noiseOptions\n            );\n            float scatteringNoise = noiseValue;\n            float extinctionNoise = noiseValue;\n            if (noiseValue < 0.0f || !(noiseOptions & SCATTERING_NOISE))\n            \{\n                scatteringNoise = 1.0f;\n            \}\n            if (noiseValue < 0.0f || !(noiseOptions & EXTINCTION_NOISE))\n            \{\n                extinctionNoise = 1.0f;\n            \}\n\n            extinctionNoiseSum += extinctionNoise;\n\n            const float4 lightBRDF = exp(\n                -extinctionCoefficient\n                * extinctionNoise\n                * (distanceToLight + equiangularDistance)\n            );\n\n            scatteredColour += scatteringCoefficient * scatteringNoise * sampleLight(\n                seed * RAND_CONST_7 / step,\n                throughput,\n                lightBRDF,\n                distanceToLight,\n                lightDirection,\n                particlePosition,\n                lightDirection,\n                equiangularPDF,\n                lightPDF,\n                selectedLight,\n                numEmissive,\n                _sampleHDRIEquiangular,\n                nestedDielectrics,\n                numNestedDielectrics\n            );\n        \}\n\n        throughput *= exp(\n            -extinctionCoefficient\n            * extinctionNoiseSum\n            * distanceSinceLastBounce\n            / (float) _equiangularSamples\n        );\n\n        return scatteredColour;\n    \}\n\n\n    /**\n     * Handle the interaction between a ray and the surface of a material.\n     *\n     * @arg stepDistance: The last step size to be marched.\n     * @arg pixelFootprint: A value proportional to the amount of world\n     *     space that fills a pixel, like the distance from camera.\n     * @arg distance: The distance travelled since the last bounce.\n     * @arg intersectionPosition: The position at which the ray\n     *     intersects the geometry.\n     * @arg surfaceNormal: The surface normal at the intersection point.\n     * @arg objectId: The ID of the object that was hit.\n     * @arg emissiveIndices: The indices of the emissive objects in the\n     *     scene.\n     * @arg numEmissive: The number of emissive objects in the scene.\n     * @arg doRefraction: Whether or not refraction is enabled on the\n     *     material.\n     * @arg numLights: The number of lights in the scene.\n     * @arg seed: The seed to use in randomization.\n     * @arg direction: The incoming ray direction.\n     * @arg origin: The ray origin.\n     * @arg diffusivity: The diffuse values of the surface.\n     * @arg specularity: The specular values of the surface.\n     * @arg transmittance: The extinction coefficient and transmissive\n     *     probability of the surface.\n     * @arg emittance: The emissive values of the surface.\n     * @arg specularRoughness: The specular roughness of the surface.\n     * @arg transmissionRoughness: The transmissive roughness of the\n     *     surface.\n     * @arg refractiveIndex: The refractive index of the material.\n     * @arg scatteringCoefficient: The scattering coefficient of the\n     *     material.\n     * @arg nestedDielectrics: The stack of dielectrics that we have\n     *     entered without exiting.\n     * @arg numNestedDielectrics: The number of dielectrics in the\n     *     stack.\n     * @arg rayColour: The colour of the ray.\n     * @arg throughput: The throughput of the ray.\n     * @arg previousMaterialPDF: The PDF of the last material interacted\n     *     with.\n     * @arg usedPrecomputedIrradiance: Whether or not we have used the\n     *     precomputed irradiance.\n     */\n    void materialInteraction(\n            const float stepDistance,\n            const float pixelFootprint,\n            const float distance,\n            const float3 &intersectionPosition,\n            const float3 &surfaceNormal,\n            const int objectId,\n            const int emissiveIndices\[MAX_MIS_EMISSIVE_SHAPES],\n            const int numEmissive,\n            const bool doRefraction,\n            const float numLights,\n            float3 &seed,\n            float3 &direction,\n            float3 &origin,\n            float4 &diffusivity,\n            float4 &specularity,\n            float4 &transmittance,\n            float4 &emittance,\n            float &specularRoughness,\n            float &transmissionRoughness,\n            float &refractiveIndex,\n            float4 &scatteringCoefficient,\n            float nestedDielectrics\[MAX_NESTED_DIELECTRICS]\[NESTED_DIELECTRIC_PARAMS],\n            int &numNestedDielectrics,\n            float4 &rayColour,\n            float4 &throughput,\n            float &previousMaterialPDF,\n            bool &usedPrecomputedIrradiance)\n    \{\n        // Use the noise to modify the surface properties\n        noiseMaterialInteraction(\n            objectId - 1,\n            intersectionPosition,\n            diffusivity,\n            specularity,\n            transmittance,\n            emittance,\n            specularRoughness,\n            transmissionRoughness,\n            refractiveIndex\n        );\n\n        // Compute the amount we would offset a point to escape the surface\n        const float offset = 2.0f * pixelFootprint * _shadowBias;\n\n        // Perform Equi-Angular Sampling\n        rayColour += sampleEquiangular(\n            seed,\n            intersectionPosition,\n            origin,\n            direction,\n            distance,\n            emissiveIndices,\n            numEmissive,\n            nestedDielectrics,\n            numNestedDielectrics,\n            throughput\n        );\n\n        origin = intersectionPosition;\n\n        // Get material data for material and light sampling\n        float4 materialBRDF;\n        float3 bounceDirection;\n        float materialLightPDF;\n        const float materialPDF = sampleMaterial(\n            seed * RAND_CONST_8,\n            surfaceNormal,\n            direction,\n            diffusivity,\n            offset,\n            transmittance,\n            doRefraction,\n            refractiveIndex,\n            scatteringCoefficient,\n            transmissionRoughness,\n            specularity,\n            specularRoughness,\n            objectId,\n            isExitingObject(\n                nestedDielectrics\[numNestedDielectrics]\[OBJECT_ID] - 1,\n                objectId - 1\n            ),\n            materialBRDF,\n            bounceDirection,\n            origin,\n            nestedDielectrics,\n            numNestedDielectrics,\n            materialLightPDF\n        );\n\n        if (\n            __lightSamplingEnabled\n            && materialLightPDF > 0.0f\n            && numLights > 0\n        ) \{\n            // Perform MIS light sampling\n            rayColour += lightSampling(\n                seed * RAND_CONST_9,\n                throughput,\n                materialBRDF,\n                surfaceNormal,\n                origin,\n                materialLightPDF,\n                offset,\n                emissiveIndices,\n                numEmissive,\n                _sampleHDRI,\n                nestedDielectrics,\n                numNestedDielectrics\n            );\n        \}\n\n        if (_usePrecomputedIrradiance && materialLightPDF > 0.0f)\n        \{\n            emittance += diffusivity * diffusivity.w * readIrradianceValue(surfaceNormal);\n            usedPrecomputedIrradiance = true;\n        \}\n\n        // Perform MIS material sampling\n        const float radius = getRadius(objectId - 1);\n        const float visibleSurfaceArea = 2.0f * PI * radius * radius;\n\n        rayColour += multipleImportanceSample(\n            emittance,\n            throughput,\n            previousMaterialPDF,\n            sampleLightsPDF(numLights, visibleSurfaceArea)\n        );\n\n        float materialGeometryFactor = 1.0f;\n        if (materialLightPDF > 0.0f)\n        \{\n            materialGeometryFactor = saturate(dot(bounceDirection, surfaceNormal));\n        \}\n\n        throughput *= materialBRDF * materialGeometryFactor / materialPDF;\n\n        // Prepare the variables for the next march\n        previousMaterialPDF = materialPDF;\n\n        direction = bounceDirection;\n    \}\n\n\n    /**\n     * March a path through the scene.\n     *\n     * @arg rayOrigin: The origin of the ray.\n     * @arg rayDirection: The direction of the ray.\n     * @arg emissiveIndices: The indices of the emissive objects in the\n     *     scene.\n     * @arg numEmissive: The number of emissive objects in the scene.\n     * @arg seed: The seed to use in randomization.\n     *\n     * @returns: The ray colour.\n     */\n    float4 marchPath(\n            const float3 &rayOrigin,\n            const float3 &rayDirection,\n            const int emissiveIndices\[MAX_MIS_EMISSIVE_SHAPES],\n            const int numEmissive,\n            float3 &seed)\n    \{\n        const int numLights = _lightTextureWidth + numEmissive + _sampleHDRI;\n\n        float nestedDielectrics\[MAX_NESTED_DIELECTRICS]\[NESTED_DIELECTRIC_PARAMS];\n        nestedDielectrics\[0]\[EXTINCTION_X] = _extinctionCoefficient.x;\n        nestedDielectrics\[0]\[EXTINCTION_Y] = _extinctionCoefficient.y;\n        nestedDielectrics\[0]\[EXTINCTION_Z] = _extinctionCoefficient.z;\n        nestedDielectrics\[0]\[OBJECT_ID] = -1;\n        nestedDielectrics\[0]\[REFRACTIVE_INDEX] = _refractiveIndex;\n        nestedDielectrics\[0]\[SCATTERING_X] = _scatteringCoefficient.x;\n        nestedDielectrics\[0]\[SCATTERING_Y] = _scatteringCoefficient.y;\n        nestedDielectrics\[0]\[SCATTERING_Z] = _scatteringCoefficient.z;\n        nestedDielectrics\[0]\[DO_REFRACTION] = false;\n        int numNestedDielectrics = 0;\n\n        float4 rayColour = float4(0);\n        float4 throughput = float4(1);\n\n        float lastStepDistance = 1.0f;\n\n        float firstObjectId = 0.0f;\n\n        int iterations = 0;\n        int bounces = 0;\n\n        float distanceTravelled = 0;\n        float distanceSinceLastBounce = distanceTravelled;\n\n        // Get the next ray\n        float3 origin = rayOrigin;\n        float3 direction = rayDirection;\n        float3 positionOnRay = origin;\n\n        float4 diffusivity;\n        float4 specularity;\n        float4 transmittance;\n        float4 emittance;\n\n        float pixelFootprint = _hitTolerance;\n\n        float previousMaterialPDF = 1.0f;\n\n        bool usedPrecomputedIrradiance = false;\n\n        // March the ray\n        while (\n            distanceTravelled < _maxRayDistance\n            && iterations < _maxRaySteps\n            && sumComponent(throughput) > _hitTolerance\n            && length(rayColour) < _maxBrightness\n        ) \{\n            positionOnRay = origin + distanceSinceLastBounce * direction;\n\n            // Get the closest distance to an object\n            bool doRefraction = true;\n            float4 scatteringCoefficient = float4(0);\n            float specularRoughness = 0.0f;\n            float transmissionRoughness = 0.0f;\n            float refractiveIndex = 1.0f;\n            int objectId = 0;\n\n            // Keep the signed distance so we know whether or not we are\n            // inside the object\n            const float signedStepDistance = getMinDistanceToObjectInScene(\n                positionOnRay,\n                pixelFootprint,\n                diffusivity,\n                specularity,\n                transmittance,\n                emittance,\n                scatteringCoefficient,\n                specularRoughness,\n                transmissionRoughness,\n                refractiveIndex,\n                doRefraction,\n                objectId\n            );\n\n            // Get the absolute value, the true shortest distance to a\n            // surface\n            const float stepDistance = fabs(signedStepDistance);\n\n            // Keep track of the distance the ray has travelled\n            distanceTravelled += stepDistance;\n            distanceSinceLastBounce += stepDistance;\n\n            // Have we hit the nearest object?\n            if (stepDistance < pixelFootprint)\n            \{\n                float3 intersectionPosition = positionOnRay + stepDistance * direction;\n\n                // The normal to the surface at that position\n                float3 surfaceNormal = sign(lastStepDistance) * estimateSurfaceNormal(\n                    intersectionPosition,\n                    pixelFootprint\n                );\n\n                if (bounces == 0)\n                \{\n                    // Keep the ID of the first object hit, so we can\n                    // store it in the alpha channel\n                    firstObjectId = objectId;\n\n                    // Early exit for the various AOVs that are not 'beauty'\n                    if (_outputType > BEAUTY_AOV && _outputType < STATS_AOV)\n                    \{\n                        return earlyExitAOVs(\n                            _outputType,\n                            intersectionPosition,\n                            worldToLocal(firstObjectId - 1, intersectionPosition),\n                            surfaceNormal,\n                            fabs(matmul(\n                                _cameraWorldMatrix.invert(),\n                                float4(\n                                    intersectionPosition.x,\n                                    intersectionPosition.y,\n                                    intersectionPosition.z,\n                                    1.0f\n                                )\n                            )\[2]),\n                            firstObjectId\n                        );\n                    \}\n                \}\n\n                materialInteraction(\n                    stepDistance,\n                    pixelFootprint,\n                    distanceSinceLastBounce,\n                    intersectionPosition,\n                    surfaceNormal,\n                    objectId,\n                    emissiveIndices,\n                    numEmissive,\n                    doRefraction,\n                    numLights,\n                    seed,\n                    direction,\n                    origin,\n                    diffusivity,\n                    specularity,\n                    transmittance,\n                    emittance,\n                    specularRoughness,\n                    transmissionRoughness,\n                    refractiveIndex,\n                    scatteringCoefficient,\n                    nestedDielectrics,\n                    numNestedDielectrics,\n                    rayColour,\n                    throughput,\n                    previousMaterialPDF,\n                    usedPrecomputedIrradiance\n                );\n\n                // Exit if we have reached the bounce limit\n                // or with a random chance\n                const float rng = random(random(seed.x) + random(seed.y + random(seed.z)));\n                const float exitProbability = max(\n                    throughput.x,\n                    throughput.y,\n                    throughput.z\n                );\n                if (\n                    ++bounces > __bouncesPerRay\n                    || emittance.w >= 1.0f\n                    || usedPrecomputedIrradiance\n                    || (_roulette && exitProbability <= rng)\n                ) \{\n                    return finalAOVs(\n                        _outputType,\n                        iterations,\n                        bounces,\n                        firstObjectId,\n                        rayColour\n                    );\n                \}\n                if (_roulette)\n                \{\n                    // Account for the lost intensity from the early exits\n                    throughput /= exitProbability;\n                \}\n\n                // Update the random seed\n                seed = RAND_CONST_12 * random(\n                    seed\n                    + rng\n                    + random(fabs(intersectionPosition + direction))\n                );\n\n                distanceSinceLastBounce = 0.0f;\n\n                // Reset the pixel footprint so multiple reflections don't\n                // reduce precision\n                pixelFootprint = _hitTolerance;\n            \}\n            else if (_levelOfDetail)\n            \{\n                pixelFootprint += _hitTolerance * stepDistance;\n            \}\n\n            lastStepDistance = signedStepDistance;\n            iterations++;\n        \}\n\n        // If we are not computing the scene value and we have missed all\n        // objects, return an appropriate colour.\n        if (_outputType > BEAUTY_AOV)\n        \{\n            return rayMissAOVs(\n                _outputType,\n                iterations,\n                bounces,\n                firstObjectId\n            );\n        \}\n\n        const float correctedDistance = (\n            distanceSinceLastBounce\n            + _maxRayDistance\n            - distanceTravelled\n        );\n\n        // Perform Equi-Angular Sampling\n        rayColour += sampleEquiangular(\n            seed,\n            origin + correctedDistance * direction,\n            origin,\n            direction,\n            correctedDistance,\n            emissiveIndices,\n            numEmissive,\n            nestedDielectrics,\n            numNestedDielectrics,\n            throughput\n        );\n\n        // Read the hdri value in the direction the ray was last travelling\n        rayColour += throughput * readHDRIValue(direction);\n\n        rayColour.w = (bounces > 0) * firstObjectId;\n        return rayColour;\n    \}\n\n\n    /**\n     * Get the indices of all the emissive objects in the scene.\n     *\n     * @arg emissiveIndices: The array to store the indices in.\n     *\n     * @returns: The total number of emissive objects found.\n     */\n    int getEmissiveIndices(int emissiveIndices\[MAX_MIS_EMISSIVE_SHAPES])\n    \{\n        int currentIndex = 0;\n        for (int j=0; j < min(_objectTextureWidth, MAX_MIS_EMISSIVE_SHAPES); j++)\n        \{\n            if (emittances(j, 0, 3) > 0.0f)\n            \{\n                emissiveIndices\[currentIndex++] = j;\n            \}\n        \}\n\n        return currentIndex;\n    \}\n\n\n    /**\n     * Create a ray out of the camera. It will be either a standard ray,\n     * a latlong ray, or a ray that will result in depth of field.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg pixelLocation: The x, and y locations of the pixel.\n     * @arg rayOrigin: The location to store the origin of the new ray.\n     * @arg rayDirection: The location to store the direction of the new\n     *     ray.\n     */\n    void getCameraRay(\n            const float3 &seed,\n            const float2 &pixelLocation,\n            float3 &rayOrigin,\n            float3 &rayDirection)\n    \{\n        const float2 uvCoordinates = pixelsToUV(\n            pixelLocation + random(float2(seed.x, seed.y)),\n            float2(_formatWidth, _formatHeight)\n        );\n        if (_latLong)\n        \{\n            createLatLongCameraRay(\n                _cameraWorldMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else if (_depthOfFieldEnabled)\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                __aperture,\n                _focalDistance,\n                seed,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n    \}\n\n\n    /**\n     * Compute a raymarched pixel value.\n     *\n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        SampleType(noise) noisePixel = noise();\n        float3 seed = random(float3(noisePixel.x, noisePixel.y, noisePixel.z));\n\n        const float4 variancePixel = variance();\n\n        const float numPaths = adaptiveSamples(\n            _minPathsPerPixel,\n            _maxPathsPerPixel,\n            float3(variancePixel.x, variancePixel.y, variancePixel.z)\n        );\n        const float numPrecomputedPaths = variancePixel.w;\n        const float totalPaths = numPaths + numPrecomputedPaths;\n\n        float4 resultPixel = float4(0);\n\n        float2 pixelLocation = float2(pos.x, pos.y);\n\n        int emissiveMISOptions\[MAX_MIS_EMISSIVE_SHAPES];\n\n        const int numEmissive = getEmissiveIndices(emissiveMISOptions);\n\n        for (int path=1; path <= numPaths; path++)\n        \{\n            // Generate a ray from the camera\n            float3 rayOrigin;\n            float3 rayDirection;\n            getCameraRay(\n                seed,\n                pixelLocation,\n                rayOrigin,\n                rayDirection\n            );\n\n            // Determine the colour of the ray\n            resultPixel += marchPath(\n                rayOrigin,\n                rayDirection,\n                emissiveMISOptions,\n                numEmissive,\n                seed\n            ) / totalPaths;\n\n            seed = RAND_CONST_10 * random(seed * path * RAND_CONST_11);\n        \}\n\n        const uint objectId = resultPixel.w / totalPaths;\n\n        dst() = resultPixel + numPrecomputedPaths * src() / totalPaths;\n\n        if (_outputType == STATS_AOV)\n        \{\n            dst(2) = totalPaths;\n        \}\n\n        dst(3) = encodeTwoValuesInUint(objectId, totalPaths);\n    \}\n\};\n"
  rebuild ""
  "RayMarchKernel_Focal Length" {{parent.DummyCam.focal}}
  "RayMarchKernel_Horizontal Aperture" {{parent.DummyCam.haperture}}
  "RayMarchKernel_Near Plane" {{parent.DummyCam.near}}
  "RayMarchKernel_Far Plane" {{parent.DummyCam.far}}
  "RayMarchKernel_Camera World Matrix" {
      {{parent.DummyCam.world_matrix.0} {parent.DummyCam.world_matrix.1} {parent.DummyCam.world_matrix.2} {parent.DummyCam.world_matrix.3}}
      {{parent.DummyCam.world_matrix.4} {parent.DummyCam.world_matrix.5} {parent.DummyCam.world_matrix.6} {parent.DummyCam.world_matrix.7}}
      {{parent.DummyCam.world_matrix.8} {parent.DummyCam.world_matrix.9} {parent.DummyCam.world_matrix.10} {parent.DummyCam.world_matrix.11}}
      {{parent.DummyCam.world_matrix.12} {parent.DummyCam.world_matrix.13} {parent.DummyCam.world_matrix.14} {parent.DummyCam.world_matrix.15}}
    }
  "RayMarchKernel_Focal Distance" {{parent.DummyCam.focal_point}}
  RayMarchKernel_fstop {{parent.DummyCam.fstop}}
  "RayMarchKernel_Enable Depth Of Field" {{parent.enable_dof}}
  "RayMarchKernel_Screen Width" {{parent.resolution_dot.width}}
  "RayMarchKernel_Screen Height" {{parent.resolution_dot.height}}
  "RayMarchKernel_HDRI Offset Angle" {{parent.hdri_offset_angle}}
  "RayMarchKernel_Use Precomputed Irradiance" {{parent.use_precomputed_irradiance}}
  "RayMarchKernel_Min Paths Per Pixel" {{parent.min_paths_per_pixel}}
  "RayMarchKernel_Max Paths Per Pixel" {{parent.max_paths_per_pixel}}
  RayMarchKernel_Roulette {{parent.roulette}}
  "RayMarchKernel_Max Bounces" {{parent.max_bounces}}
  "RayMarchKernel_Max Light Sampling Bounces" {{parent.max_light_sampling_bounces}}
  "RayMarchKernel_Sample HDRI" {{parent.sample_hdri}}
  "RayMarchKernel_Sample All Lights" {{parent.sample_all_lights}}
  "RayMarchKernel_Secondary Light Sampling" {{parent.secondary_sampling}}
  "RayMarchKernel_Light Sampling Bias" {{parent.light_sampling_bias}}
  "RayMarchKernel_Max Ray Distance" {{parent.ray_distance}}
  "RayMarchKernel_Max Ray Steps" {{parent.max_ray_steps}}
  "RayMarchKernel_Level of Detail" {{parent.level_of_detail}}
  "RayMarchKernel_Hit Tolerance" {{parent.hit_tolerance}}
  "RayMarchKernel_Shadow Bias" {{parent.shadow_bias}}
  "RayMarchKernel_Maximum Brightness" {{parent.max_brightness}}
  "RayMarchKernel_Index of Refraction" {{parent.refractive_index}}
  "RayMarchKernel_Scattering Coefficient" {{"parent.scattering_colour * parent.scattering_coefficient"} {"parent.scattering_colour * parent.scattering_coefficient"} {"parent.scattering_colour * parent.scattering_coefficient"} 0}
  "RayMarchKernel_Extinction Coefficient" {{"(1 - clamp(parent.extinction_colour.r, 0, 1)) * parent.extinction_coefficient"} {"(1 - clamp(parent.extinction_colour.g, 0, 1)) * parent.extinction_coefficient"} {"(1 - clamp(parent.extinction_colour.b, 0, 1)) * parent.extinction_coefficient"} 0}
  "RayMarchKernel_Equi-Angular Samples" {{parent.equiangular_samples}}
  "RayMarchKernel_Sample HDRI Equi-Angular" {{parent.sample_hdri_equiangular}}
  "RayMarchKernel_Object Texture Width" {{"parent.object_input_protection.disable ? parent.obj_dot.width : parent.scene.width == 1 ? 1 : 0"}}
  "RayMarchKernel_Light Texture Width" {{"parent.light_input_protection.disable ? parent.light_dot.width : parent.lights.width == 1 ? 1 : 0"}}
  "RayMarchKernel_Output Type" {{parent.output_type}}
  "RayMarchKernel_Output LatLong" {{parent.latlong}}
  rebuild_finalise ""
  name BlinkPathMarcher
  xpos 1610
  ypos -472
 }
 Reformat {
  format {{{parent.format_.format}}}
  name Reformat1
  xpos 1610
  ypos -434
 }
 Expression {
  expr0 "isnan(r) ? 0 : (isinf(r) ? parent.max_brightness : clamp(r, 0, parent.max_brightness))"
  expr1 "isnan(g) ? 0 : (isinf(g) ? parent.max_brightness : clamp(g, 0, parent.max_brightness))"
  expr2 "isnan(b) ? 0 : (isinf(b) ? parent.max_brightness : clamp(b, 0, parent.max_brightness))"
  name Expression2
  xpos 1610
  ypos -408
 }
 Dot {
  name Dot11
  xpos 1644
  ypos -270
 }
set N91fed90 [stack 0]
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/kernels/decode_alpha.blink
  recompileCount 3
  ProgramGroup 1
  KernelDescription "2 \"DecodeAlpha\" iterate pixelWise 1c4995e5ef3c4395ca22dae32e63f03d3c8b0eb4c438ef32fcb399691563ff7d 2 \"src\" Read Point \"dst\" Write Point 0 0 0"
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n#include \"conversion.h\"\n\n\nkernel DecodeAlpha : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessPoint, eEdgeNone> src; // the input image\n    Image<eWrite> dst; // the output image\n\n\n    /**\n     * Decode the multiple values stored in the alpha channel.\n     */\n    void process()\n    \{\n        SampleType(src) srcPixel = src();\n\n        const int2 decoded = decodeTwoValuesFromUint(srcPixel.w);\n        dst() = float4(decoded.x, decoded.y, 0, 0);\n    \}\n\};\n"
  rebuild ""
  rebuild_finalise ""
  name BlinkScript1
  xpos 1610
  ypos -40
 }
set N9203dc0 [stack 0]
push $N91fed90
 Dot {
  name Dot8
  xpos 1754
  ypos -270
 }
 ShuffleCopy {
  inputs 2
  in2 rgb
  alpha red
  green2 green2
  name ShuffleCopy2
  xpos 1720
  ypos -34
 }
push $N91fed90
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/kernels/variance.blink
  recompileCount 18
  KernelDescription "2 \"Variance\" iterate pixelWise 9ffe5cb17cce3fe6b29c96cc653303e51591ce19298e8dbdc053847856d3fddc 2 \"src\" Read Ranged2D \"dst\" Write Point 1 \"Range\" Float 2 AABAQAAAQEA= 1 \"_range\" 2 1 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"__numSamples\" Float 1 1 AAAAAA=="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n#include \"math.h\"\n\n\nkernel Variance : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessRanged2D, eEdgeClamped> src; // the input image\n    Image<eWrite> dst; // the output image\n\n    param:\n        float2 _range;\n\n    local:\n        float __numSamples;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        defineParam(_range, \"Range\", float2(3, 3));\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        src.setRange(-_range.x, -_range.y, _range.x, _range.y);\n\n        __numSamples = (2.0f * _range.x + 1.0f) * (2.0f * _range.y + 1.0f);\n    \}\n\n\n    /**\n     * Compute the variance of a pixel.\n     * \n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        float4 mean = float4(0);\n        for (int yOffset=-_range.y; yOffset <= _range.y; yOffset++)\n        \{\n            for (int xOffset=-_range.x; xOffset <= _range.x; xOffset++)\n            \{\n                mean += src(xOffset, yOffset) / __numSamples;\n            \}\n        \}\n\n        float4 sumOfSquares = float4(0);\n        for (int yOffset=-_range.y; yOffset <= _range.y; yOffset++)\n        \{\n            for (int xOffset=-_range.x; xOffset <= _range.x; xOffset++)\n            \{\n                const float4 sample = src(xOffset, yOffset);\n\n                const float4 deviation = src(xOffset, yOffset) - mean;\n\n                sumOfSquares += deviation * deviation / (__numSamples - 1.0f);\n            \}\n        \}\n\n        dst() = sumOfSquares;\n    \}\n\};\n"
  rebuild ""
  Variance_Range {{parent.variance_range} {parent.variance_range}}
  rebuild_finalise ""
  name BlinkScript2
  xpos 1500
  ypos -280
 }
 Dot {
  name Dot17
  xpos 1534
  ypos -222
 }
set N923f930 [stack 0]
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/kernels/minMax.blink
  recompileCount 8
  KernelDescription "2 \"MinMaxMeanDeviation\" iterate pixelWise d658e53ec264cb72124ab1c5eeaddc8daaefd311b02e7e408e47a126f7c2db06 2 \"src\" Read Random \"dst\" Write Point 1 \"Inclusive Range\" Float 1 80/DRw== 1 \"_maximum\" 1 1 1 \"__numSamples\" Float 1 1 AAAAAA=="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n#include \"math.h\"\n\n\nkernel MinMaxMeanDeviation : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessRandom, eEdgeNone> src; // the input image\n    Image<eWrite> dst; // the output image\n\n    param:\n        float _maximum;\n\n    local:\n        float __numSamples;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        defineParam(_maximum, \"Inclusive Range\", 99999.9f);\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        __numSamples = 3.0f * src.bounds.width() * src.bounds.height();\n    \}\n\n\n    /**\n     * Compute the min max and standard deviation of the image.\n     *\n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        if (length(float2(pos.x, pos.y)) > 0)\n        \{\n            dst() = 0;\n            return;\n        \}\n\n        float minValue = FLT_MAX;\n        float maxValue = 0.0f;\n        float mean = 0.0f;\n\n        for (int y=src.bounds.y1; y < src.bounds.y2; y++)\n        \{\n            for (int x=src.bounds.x1; x < src.bounds.x2; x++)\n            \{\n                const float3 pixelValue = float3(\n                    src(x, y, 0),\n                    src(x, y, 1),\n                    src(x, y, 2)\n                );\n\n                minValue = min(minValue, minComponent(pixelValue));\n                maxValue = max(maxValue, maxComponent(pixelValue));\n\n                mean += sumComponent(pixelValue) / __numSamples;\n            \}\n        \}\n\n        float standardDeviation = 0.0f;\n\n        for (int y=src.bounds.y1; y < src.bounds.y2; y++)\n        \{\n            for (int x=src.bounds.x1; x < src.bounds.x2; x++)\n            \{\n                const float3 pixelValue = float3(\n                    src(x, y, 0),\n                    src(x, y, 1),\n                    src(x, y, 2)\n                );\n\n                const float deviation = sumComponent(fabs(pixelValue - mean));\n\n                standardDeviation += min(deviation * deviation, _maximum) / __numSamples;\n            \}\n        \}\n\n        dst() = float4(minValue, maxValue, mean, sqrt(standardDeviation));\n    \}\n\};\n"
  rebuild ""
  "MinMaxMeanDeviation_Inclusive Range" 99999.99
  rebuild_finalise ""
  name BlinkScript3
  xpos 1390
  ypos -232
 }
 Dot {
  name Dot29
  xpos 1424
  ypos -150
 }
push $N923f930
 BlinkScript {
  inputs 2
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/kernels/normalize.blink
  recompileCount 11
  KernelDescription "2 \"Normalize\" iterate pixelWise 5a966d373c338a72f091ff982ef82b54a18f6a1983de644d989df8ef81655617 3 \"src\" Read Point \"minMax\" Read Random \"dst\" Write Point 2 \"Normalization Method\" Int 1 AAAAAA== \"Clamp To Standard Deviation\" Bool 1 AA== 2 \"_normalizationMethod\" 1 1 \"_clampToStdDev\" 1 1 1 \"minMaxconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n#include \"math.h\"\n\n\nkernel Normalize : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessPoint, eEdgeNone> src; // the input image\n    Image<eRead, eAccessRandom, eEdgeConstant> minMax; // the input image\n    Image<eWrite> dst; // the output image\n\n\n    param:\n        int _normalizationMethod;\n        bool _clampToStdDev;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        defineParam(_normalizationMethod, \"Normalization Method\", 0);\n        defineParam(_clampToStdDev, \"Clamp To Standard Deviation\", false);\n    \}\n\n\n    /**\n     * The normalized values.\n     */\n    void process()\n    \{\n        float minValue = minMax(0, 0, 0);\n        float maxValue = minMax(0, 0, 1);\n        const float meanValue = minMax(0, 0, 2);\n        const float standardDeviationValue = minMax(0, 0, 3);\n\n        float4 srcValue;\n        if (_clampToStdDev)\n        \{\n            const float lowerBound = meanValue - standardDeviationValue;\n            const float upperBound = meanValue + standardDeviationValue;\n\n            srcValue = clamp(src(), lowerBound, upperBound);\n            minValue = clamp(minValue, lowerBound, upperBound);\n            maxValue = clamp(maxValue, lowerBound, upperBound);\n        \}\n        else\n        \{\n            srcValue = src();\n        \}\n\n        float4 output;\n\n        if (_normalizationMethod == 0 && minValue != maxValue)\n        \{\n            dst() = (srcValue - minValue) / (maxValue - minValue);\n        \}\n        else if (_normalizationMethod == 1 && standardDeviationValue != 0.0f)\n        \{\n            dst() = (srcValue - meanValue) / standardDeviationValue;\n        \}\n        else\n        \{\n            dst() = 0.0f;\n        \}\n    \}\n\};\n"
  rebuild ""
  "Normalize_Normalization Method" 1
  rebuild_finalise ""
  name BlinkScript4
  xpos 1500
  ypos -160
 }
 Dot {
  name Dot31
  xpos 1534
  ypos -102
 }
set N9308510 [stack 0]
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/kernels/minMax.blink
  recompileCount 8
  KernelDescription "2 \"MinMaxMeanDeviation\" iterate pixelWise d658e53ec264cb72124ab1c5eeaddc8daaefd311b02e7e408e47a126f7c2db06 2 \"src\" Read Random \"dst\" Write Point 1 \"Inclusive Range\" Float 1 80/DRw== 1 \"_maximum\" 1 1 1 \"__numSamples\" Float 1 1 AAAAAA=="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n#include \"math.h\"\n\n\nkernel MinMaxMeanDeviation : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessRandom, eEdgeNone> src; // the input image\n    Image<eWrite> dst; // the output image\n\n    param:\n        float _maximum;\n\n    local:\n        float __numSamples;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        defineParam(_maximum, \"Inclusive Range\", 99999.9f);\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        __numSamples = 3.0f * src.bounds.width() * src.bounds.height();\n    \}\n\n\n    /**\n     * Compute the min max and standard deviation of the image.\n     *\n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        if (length(float2(pos.x, pos.y)) > 0)\n        \{\n            dst() = 0;\n            return;\n        \}\n\n        float minValue = FLT_MAX;\n        float maxValue = 0.0f;\n        float mean = 0.0f;\n\n        for (int y=src.bounds.y1; y < src.bounds.y2; y++)\n        \{\n            for (int x=src.bounds.x1; x < src.bounds.x2; x++)\n            \{\n                const float3 pixelValue = float3(\n                    src(x, y, 0),\n                    src(x, y, 1),\n                    src(x, y, 2)\n                );\n\n                minValue = min(minValue, minComponent(pixelValue));\n                maxValue = max(maxValue, maxComponent(pixelValue));\n\n                mean += sumComponent(pixelValue) / __numSamples;\n            \}\n        \}\n\n        float standardDeviation = 0.0f;\n\n        for (int y=src.bounds.y1; y < src.bounds.y2; y++)\n        \{\n            for (int x=src.bounds.x1; x < src.bounds.x2; x++)\n            \{\n                const float3 pixelValue = float3(\n                    src(x, y, 0),\n                    src(x, y, 1),\n                    src(x, y, 2)\n                );\n\n                const float deviation = sumComponent(fabs(pixelValue - mean));\n\n                standardDeviation += min(deviation * deviation, _maximum) / __numSamples;\n            \}\n        \}\n\n        dst() = float4(minValue, maxValue, mean, sqrt(standardDeviation));\n    \}\n\};\n"
  rebuild ""
  "MinMaxMeanDeviation_Inclusive Range" 99999.99
  rebuild_finalise ""
  name BlinkScript5
  xpos 1390
  ypos -112
 }
 Dot {
  name Dot32
  xpos 1424
  ypos -30
 }
push $N9308510
 BlinkScript {
  inputs 2
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/kernels/normalize.blink
  recompileCount 10
  KernelDescription "2 \"Normalize\" iterate pixelWise 5a966d373c338a72f091ff982ef82b54a18f6a1983de644d989df8ef81655617 3 \"src\" Read Point \"minMax\" Read Random \"dst\" Write Point 2 \"Normalization Method\" Int 1 AAAAAA== \"Clamp To Standard Deviation\" Bool 1 AA== 2 \"_normalizationMethod\" 1 1 \"_clampToStdDev\" 1 1 1 \"minMaxconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n#include \"math.h\"\n\n\nkernel Normalize : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessPoint, eEdgeNone> src; // the input image\n    Image<eRead, eAccessRandom, eEdgeConstant> minMax; // the input image\n    Image<eWrite> dst; // the output image\n\n\n    param:\n        int _normalizationMethod;\n        bool _clampToStdDev;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        defineParam(_normalizationMethod, \"Normalization Method\", 0);\n        defineParam(_clampToStdDev, \"Clamp To Standard Deviation\", false);\n    \}\n\n\n    /**\n     * The normalized values.\n     */\n    void process()\n    \{\n        float minValue = minMax(0, 0, 0);\n        float maxValue = minMax(0, 0, 1);\n        const float meanValue = minMax(0, 0, 2);\n        const float standardDeviationValue = minMax(0, 0, 3);\n\n        float4 srcValue;\n        if (_clampToStdDev)\n        \{\n            const float lowerBound = meanValue - standardDeviationValue;\n            const float upperBound = meanValue + standardDeviationValue;\n\n            srcValue = clamp(src(), lowerBound, upperBound);\n            minValue = clamp(minValue, lowerBound, upperBound);\n            maxValue = clamp(maxValue, lowerBound, upperBound);\n        \}\n        else\n        \{\n            srcValue = src();\n        \}\n\n        float4 output;\n\n        if (_normalizationMethod == 0 && minValue != maxValue)\n        \{\n            dst() = (srcValue - minValue) / (maxValue - minValue);\n        \}\n        else if (_normalizationMethod == 1 && standardDeviationValue != 0.0f)\n        \{\n            dst() = (srcValue - meanValue) / standardDeviationValue;\n        \}\n        else\n        \{\n            dst() = 0.0f;\n        \}\n    \}\n\};\n"
  rebuild ""
  "Normalize_Clamp To Standard Deviation" true
  rebuild_finalise ""
  name BlinkScript6
  xpos 1500
  ypos -40
 }
 Dot {
  name Dot30
  xpos 1534
  ypos 90
 }
push $N9203dc0
 ShuffleCopy {
  inputs 2
  in rgb
  in2 rgb
  red red
  green green
  blue blue
  alpha green2
  black red
  white green
  red2 blue
  green2 green2
  out variance
  name ShuffleCopy1
  xpos 1610
  ypos 86
 }
 Copy {
  inputs 2
  channels all
  name Copy1
  xpos 1720
  ypos 74
 }
 Output {
  name Output1
  xpos 1720
  ypos 182
 }
end_group
set N860e8d0 [stack 0]
Write {
 channels rgba
 file /home/ob1/software/nuke/dev/raymarch/images/volumetric_caustics/volumetric_caustics.####.exr
 file_type exr
 datatype "32 bit float"
 first_part rgba
 version 15
 name Write1
 xpos 730
 ypos 503
}
CheckerBoard2 {
 inputs 0
 format "2048 1024 0 0 2048 1024 1 2K_LatLong"
 boxsize 32
 centerlinewidth 0
 name CheckerBoard1
 xpos 730
 ypos 126
}
Grade {
 white 0.1
 name Grade1
 xpos 788
 ypos 224
}
Constant {
 inputs 0
 channels rgb
 color 0.1
 format "2048 1024 0 0 2048 1024 1 2K_LatLong"
 name Constant1
 xpos 823
 ypos 126
}
Group {
 inputs 0
 name sdf_light
 onCreate "__import__('sdf.light', fromlist='SDFLight').SDFLight().handle_node_created()"
 knobChanged "__import__('sdf.light', fromlist='SDFLight').SDFLight().handle_knob_changed()"
 tile_color 0xffcc80ff
 label point
 xpos 501
 ypos 221
 addUserKnob {20 User l "SDF LIght"}
 addUserKnob {4 type t "The type of light." M {ambient "ambient occlusion" directional point}}
 type point
 addUserKnob {13 dimension_x l position t "The position of the light." R 1 10}
 dimension_x {-2 0 0}
 addUserKnob {7 dimension_y l iterations t "The number of iterations to compute." +HIDDEN R 1 10}
 dimension_y 5
 addUserKnob {7 intensity t "The intensity of the light." R 0 10}
 intensity 5
 addUserKnob {7 falloff t "The power of the light's intensity falloff. Two is physically accurate." R 0 5}
 falloff 2
 addUserKnob {18 colour t "The colour of the light."}
 colour {1 0.8 0.5}
 addUserKnob {6 colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 shadow_hardness l "shadow hardness" t "The hardness of the shadows, this is a non-physically accurate effect, but can look nice." +DISABLED R 1 100}
 shadow_hardness 1
 addUserKnob {6 soften_shadows l "soften shadows" t "Soften the shadows using a non-phisically accurate effect." -STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 info l "" +STARTLINE T "v2.0.0 - (c) Owen Bulka - 2022"}
}
 Input {
  inputs 0
  name siblings
  xpos 803
  ypos 30
 }
 Dot {
  name Dot1
  xpos 837
  ypos 488
 }
 Constant {
  inputs 0
  channels sdf_light
  color {{parent.dimension_y} 0 0 {parent.intensity}}
  format "1 1 0 0 1 1 1 1x1"
  name light1
  xpos 229
  ypos 143
 }
 Constant {
  inputs 0
  channels sdf_light
  color {{parent.dimension_x.x} {parent.dimension_x.y} {parent.dimension_x.z} {parent.intensity}}
  format "1 1 0 0 1 1 1 1x1"
  name light
  xpos 363
  ypos 11
 }
 Switch {
  inputs 2
  which {{"parent.type < 2"}}
  name Switch1
  xpos 363
  ypos 172
 }
 Dot {
  name Dot9
  xpos 397
  ypos 324
 }
 Constant {
  inputs 0
  channels sdf_light_properties
  color {{parent.colour.r} {parent.colour.g} {parent.colour.b} {"parent.soften_shadows ? -parent.type : parent.type"}}
  format "1 1 0 0 1 1 1 1x1"
  name light_props
  xpos 501
  ypos 11
 }
 Copy {
  inputs 2
  channels all
  name Copy1
  xpos 501
  ypos 380
 }
 Constant {
  inputs 0
  channels sdf_light_properties1
  color {{parent.shadow_hardness} {parent.falloff} 0 0}
  format "1 1 0 0 1 1 1 1x1"
  name light_props1
  xpos 646
  ypos 12
 }
 Copy {
  inputs 2
  channels all
  name Copy2
  xpos 642
  ypos 380
 }
 Group {
  inputs 2
  name sdf_merge
  xpos 642
  ypos 484
  disable {{"!(\[exists parent.input0] && !(parent.input0.disable && !\[exists parent.input0.input0]))"}}
  addUserKnob {20 User}
  addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
 }
  Reformat {
   inputs 0
   type "to box"
   box_width 1
   box_height 1
   box_fixed true
   name Reformat1
   xpos -119
   ypos 440
  }
  Input {
   inputs 0
   name Input2
   xpos 158
   ypos -28
   number 1
  }
  Dot {
   name Dot2
   xpos 192
   ypos -2
  }
set N82b2ad0 [stack 0]
  Dot {
   name Dot3
   xpos 329
   ypos -2
  }
  Dot {
   name Dot4
   xpos 329
   ypos 391
  }
  Input {
   inputs 0
   name Input1
   xpos 0
   ypos -32
  }
  Dot {
   name Dot1
   xpos 34
   ypos -6
  }
set N827c510 [stack 0]
  Dot {
   name Dot6
   xpos -98
   ypos -6
  }
  Dot {
   name Dot5
   xpos -98
   ypos 336
  }
push $N82b2ad0
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop3
   xpos 158
   ypos 69
  }
  Crop {
   box {0 0 {parent.Dot2.width} 1}
   name Crop4
   xpos 158
   ypos 95
  }
  Transform {
   translate {{parent.Dot1.width} 0}
   center {1 0.5}
   name Transform2
   xpos 158
   ypos 121
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop5
   xpos 158
   ypos 167
  }
push $N827c510
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop6
   xpos 0
   ypos 66
  }
  Crop {
   box {0 0 {parent.Dot1.width} 1}
   name Crop7
   xpos 0
   ypos 92
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop8
   xpos 0
   ypos 164
  }
  Merge2 {
   inputs 2
   also_merge all
   name Merge1
   xpos 0
   ypos 262
   disable {{"\[exists parent.input1] ? 0:1"}}
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input1] ? 0:1"}}
   name Switch2
   xpos 0
   ypos 332
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:1"}}
   name Switch1
   xpos 0
   ypos 387
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
   name Switch3
   xpos 0
   ypos 456
  }
  Dot {
   name out_dot
   xpos 36
   ypos 518
  }
  Output {
   name Output1
   xpos 2
   ypos 661
  }
 end_group
 Output {
  name Output1
  xpos 642
  ypos 562
 }
end_group
push $N860e8d0
Viewer {
 frame_range 1001-1111
 monitorOutOutputTransform rec709
 name Viewer1
 xpos 915
 ypos 542
}
Group {
 inputs 0
 name Group2
 onCreate "__import__('sdf.primitive', fromlist='SDFPrimitive').SDFPrimitive().handle_node_created()"
 knobChanged "__import__('sdf.primitive', fromlist='SDFPrimitive').SDFPrimitive().handle_knob_changed()"
 tile_color 0xffffffff
 label sphere
 xpos 323
 ypos 482
 addUserKnob {20 User l "SDF Primitive"}
 addUserKnob {4 shape t "The shape of the object." M {sphere ellipsoid "cut sphere" "hollow sphere" "death star" "solid angle" "rectangular prism" "rectangular prism frame" rhombus "triangular prism" cylinder "infinite cylinder" plane capsule cone "infinite cone" "capped cone" "rounded cone" torus "capped torus" link "hexagonal prism" octahedron mandelbulb mandelbox ""}}
 addUserKnob {7 dimension_x l radius t "The radius of the sphere." R 0 10}
 dimension_x 0.5
 addUserKnob {7 dimension_y l "y radius" t "The radius along the y-axis of the ellipsoid." +HIDDEN R 0 10}
 dimension_y 0.25
 addUserKnob {7 dimension_z l "z radius" t "The radius along the z-axis of the ellipsoid." +HIDDEN R 0 10}
 dimension_z 0.25
 addUserKnob {7 dimension_w l "folding limit" t "Clamp the position between +/- this value when performing the box fold. Higher values will result in a denser fractal." +HIDDEN R 0.01 2}
 dimension_w 0.8
 addUserKnob {7 wall_thickness l "wall thickness" t "The thickness of the walls of the shape, if the shape is hollow." +DISABLED}
 wall_thickness 0.01
 addUserKnob {6 hollow t "If enabled, the object will be hollow, with a thickness of 'wall thickness'." -STARTLINE}
 addUserKnob {7 edge_radius l "edge radius" t "This parameter increases the hit tolerance by the specified amount for this specific object, having the effect of rounding off the edges."}
 addUserKnob {6 mirror_x l "mirror x" t "Mirror the shape in the yz-plane." +STARTLINE}
 addUserKnob {6 mirror_y l "mirror y" t "Mirror the shape in the xz-plane." -STARTLINE}
 addUserKnob {6 mirror_z l "mirror z" t "Mirror the shape in the xy-plane." -STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {13 translate t "The translation of the object in its local coordinate space."}
 addUserKnob {13 rotate t "The rotation of the object in its local coordinate space."}
 addUserKnob {13 elongation t "The elongation of the object along the respective axes." +DISABLED}
 elongation {0.1 0 0}
 addUserKnob {6 elongate t "Enable the elongation of the object." -STARTLINE}
 addUserKnob {7 uniform_scale l "uniform scale" t "The scale of the object in its local coordinate space, along all axes." R 0 10}
 uniform_scale 1
 addUserKnob {26 div1 l "" +STARTLINE}
 addUserKnob {4 repetition t "Repeat objects in the scene with no extra memory consumption. Note that if the repeated objects overlap some strange things can occur." -STARTLINE M {none finite infinite "" ""}}
 addUserKnob {13 repetition_params l spacing t "The spacing along each positive axis to repeat the objects." +HIDDEN}
 repetition_params {1.1 1.1 100}
 addUserKnob {7 repetition_spacing l spacing t "The spacing between the objects." +HIDDEN R 0 10}
 repetition_spacing 1.1
 addUserKnob {26 ""}
 addUserKnob {4 blend_type l "blend type" t "The type of interaction this object will have with its children.\n    Union: All objects will appear as normal.\n    Subtraction: This object will be subtracted from all of its\n        children, leaving holes.\n    Intersection: Only the region where this object and its\n        children overlap will remain.\n    Smooth Union: All children will smoothly blend together\n        with this object according to the 'blend strength'.\n    Smooth Subtraction:This object will be subtracted from all\n        of its children,  leaving holes that are smoothed\n        according to the 'blend strength'.\n    Smooth Intersection: Only the region where this object\n        and its children overlap will remain, and the remaining\n        regions will be smoothed according to the 'blend\n        strength'." +DISABLED M {union subtraction intersection "smooth union" "smooth subtraction" "smooth intersection" "" "" ""}}
 addUserKnob {7 blend_strength l "blend strength" t "The amount to blend between this and its child objects if one of the 'Smooth' blend types are selected." +DISABLED}
 blend_strength 0.1
 addUserKnob {6 is_bound l "is bound" t "If enabled, this object will act as a bounding volume for all its children. This means that until a ray hits the bounding volume, none of the child object's signed distance fields will be computed. This can vastly improve performance, especially when many complex objects are far from the camera. This option does not always play well with lighting effects that depend on the number of iterations in the computation such as 'ambient occlusion' and 'softened shadows' due to the variation near the surface of the bounding object." +DISABLED +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 info l "" +STARTLINE T "v2.0.0 - (c) Owen Bulka - 2022"}
}
 Input {
  inputs 0
  name siblings
  xpos 1484
  ypos 476
 }
 Dot {
  name Dot2
  xpos 1518
  ypos 904
 }
 Input {
  inputs 0
  name children
  xpos 1357
  ypos 475
  number 1
 }
 Dot {
  name Dot1
  xpos 1391
  ypos 826
 }
 Input {
  inputs 0
  name material
  xpos 1183
  ypos 479
  number 2
 }
 Constant {
  inputs 0
  channels sdf_position_scale
  color {{parent.translate.x} {parent.translate.y} {parent.translate.z} {parent.uniform_scale}}
  format "1 1 0 0 1 1 1 1x1"
  name position_scale
  xpos 387
  ypos 444
 }
 Dot {
  name Dot17
  xpos 421
  ypos 636
 }
 Constant {
  inputs 0
  channels sdf_rotation_wall_thickness
  color {{"parent.rotate.x * pi / 180"} {"parent.rotate.y * pi / 180"} {"parent.rotate.z * pi / 180"} {parent.wall_thickness}}
  format "1 1 0 0 1 1 1 1x1"
  name rotation
  xpos 510
  ypos 446
 }
 Copy {
  inputs 2
  channels all
  name Copy1
  xpos 510
  ypos 715
 }
 Constant {
  inputs 0
  channels sdf_dimensions
  color {{parent.dimension_x} {parent.dimension_y} {parent.dimension_z} {parent.dimension_w}}
  format "1 1 0 0 1 1 1 1x1"
  name dimensions
  xpos 647
  ypos 449
 }
 Copy {
  inputs 2
  channels all
  name Copy2
  xpos 647
  ypos 715
 }
 Constant {
  inputs 0
  channels sdf_shape
  color {{parent.shape} {"parent.repetition | (parent.elongate ? 4 : 0) | (parent.mirror_x ? 8 : 0) | (parent.mirror_y ? 16 : 0) | (parent.mirror_z ? 32 : 0) | (parent.hollow ? 64 : 0) | (parent.blend_type > 0 && !parent.is_bound ? (1 << (parent.blend_type + 6)) : 0) | (parent.is_bound ? 4096 : 0) "} {"parent.sdf_merge.disable ? 0 : parent.sdf_merge.input1.width"} {parent.blend_strength}}
  format "1 1 0 0 1 1 1 1x1"
  name shape
  xpos 789
  ypos 450
 }
 Copy {
  inputs 2
  channels all
  name Copy4
  xpos 789
  ypos 715
 }
 Constant {
  inputs 0
  channels sdf_shape_mods_0
  color {{parent.repetition_params.x} {parent.repetition_params.y} {parent.repetition_params.z} {parent.repetition_spacing}}
  format "1 1 0 0 1 1 1 1x1"
  name shape_mods
  xpos 910
  ypos 452
 }
 Copy {
  inputs 2
  channels all
  name Copy6
  xpos 910
  ypos 715
 }
 Constant {
  inputs 0
  channels sdf_shape_mods_1
  color {{parent.elongation.x} {parent.elongation.y} {parent.elongation.z} {parent.edge_radius}}
  format "1 1 0 0 1 1 1 1x1"
  name shape_mods1
  xpos 1037
  ypos 454
 }
 Copy {
  inputs 2
  channels all
  name Copy7
  xpos 1037
  ypos 715
 }
 Copy {
  inputs 2
  channels all
  name Copy3
  xpos 1183
  ypos 715
 }
 Group {
  inputs 2
  name sdf_merge
  xpos 1183
  ypos 822
  disable {{"!(\[exists parent.input1] && !input1.parent.input1.disable)"}}
  addUserKnob {20 User}
  addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
 }
  Reformat {
   inputs 0
   type "to box"
   box_width 1
   box_height 1
   box_fixed true
   name Reformat1
   xpos -119
   ypos 440
  }
  Input {
   inputs 0
   name Input2
   xpos 158
   ypos -28
   number 1
  }
  Dot {
   name Dot2
   xpos 192
   ypos -2
  }
set N1379a720 [stack 0]
  Dot {
   name Dot3
   xpos 329
   ypos -2
  }
  Dot {
   name Dot4
   xpos 329
   ypos 391
  }
  Input {
   inputs 0
   name Input1
   xpos 0
   ypos -32
  }
  Dot {
   name Dot1
   xpos 34
   ypos -6
  }
set N149e6650 [stack 0]
  Dot {
   name Dot6
   xpos -98
   ypos -6
  }
  Dot {
   name Dot5
   xpos -98
   ypos 336
  }
push $N1379a720
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop3
   xpos 158
   ypos 69
  }
  Crop {
   box {0 0 {parent.Dot2.width} 1}
   name Crop4
   xpos 158
   ypos 95
  }
  Transform {
   translate {{parent.Dot1.width} 0}
   center {1 0.5}
   name Transform2
   xpos 158
   ypos 121
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop5
   xpos 158
   ypos 167
  }
push $N149e6650
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop6
   xpos 0
   ypos 66
  }
  Crop {
   box {0 0 {parent.Dot1.width} 1}
   name Crop7
   xpos 0
   ypos 92
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop8
   xpos 0
   ypos 164
  }
  Merge2 {
   inputs 2
   also_merge all
   name Merge1
   xpos 0
   ypos 262
   disable {{"\[exists parent.input1] ? 0:1"}}
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input1] ? 0:1"}}
   name Switch2
   xpos 0
   ypos 332
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:1"}}
   name Switch1
   xpos 0
   ypos 387
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
   name Switch3
   xpos 0
   ypos 456
  }
  Dot {
   name out_dot
   xpos 36
   ypos 518
  }
  Output {
   name Output1
   xpos 2
   ypos 661
  }
 end_group
 Group {
  inputs 2
  name sdf_merge1
  xpos 1183
  ypos 900
  disable {{"!(\[exists parent.input0] && !(parent.input0.disable && !\[exists parent.input0.input0]))"}}
  addUserKnob {20 User}
  addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
 }
  Reformat {
   inputs 0
   type "to box"
   box_width 1
   box_height 1
   box_fixed true
   name Reformat1
   xpos -119
   ypos 440
  }
  Input {
   inputs 0
   name Input2
   xpos 158
   ypos -28
   number 1
  }
  Dot {
   name Dot2
   xpos 192
   ypos -2
  }
set N1e48f340 [stack 0]
  Dot {
   name Dot3
   xpos 329
   ypos -2
  }
  Dot {
   name Dot4
   xpos 329
   ypos 391
  }
  Input {
   inputs 0
   name Input1
   xpos 0
   ypos -32
  }
  Dot {
   name Dot1
   xpos 34
   ypos -6
  }
set N405a0270 [stack 0]
  Dot {
   name Dot6
   xpos -98
   ypos -6
  }
  Dot {
   name Dot5
   xpos -98
   ypos 336
  }
push $N1e48f340
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop3
   xpos 158
   ypos 69
  }
  Crop {
   box {0 0 {parent.Dot2.width} 1}
   name Crop4
   xpos 158
   ypos 95
  }
  Transform {
   translate {{parent.Dot1.width} 0}
   center {1 0.5}
   name Transform2
   xpos 158
   ypos 121
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop5
   xpos 158
   ypos 167
  }
push $N405a0270
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop6
   xpos 0
   ypos 66
  }
  Crop {
   box {0 0 {parent.Dot1.width} 1}
   name Crop7
   xpos 0
   ypos 92
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop8
   xpos 0
   ypos 164
  }
  Merge2 {
   inputs 2
   also_merge all
   name Merge1
   xpos 0
   ypos 262
   disable {{"\[exists parent.input1] ? 0:1"}}
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input1] ? 0:1"}}
   name Switch2
   xpos 0
   ypos 332
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:1"}}
   name Switch1
   xpos 0
   ypos 387
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
   name Switch3
   xpos 0
   ypos 456
  }
  Dot {
   name out_dot
   xpos 36
   ypos 518
  }
  Output {
   name Output1
   xpos 2
   ypos 661
  }
 end_group
 Output {
  name Output1
  xpos 1183
  ypos 1002
 }
end_group
Group {
 inputs 0
 name ray_march1
 knobChanged "__import__('sdf.path_march', fromlist='PathMarch').PathMarch().handle_knob_changed()"
 xpos 204
 ypos 490
 addUserKnob {20 User l "Ray March"}
 addUserKnob {3 min_paths_per_pixel l "min paths per pixel" t "The minimum number of paths to trace for each pixel. This is only used when a previous render with a 'variance' layer is plugged into the 'previous' input."}
 min_paths_per_pixel 1
 addUserKnob {3 max_paths_per_pixel l "max paths per pixel" t "The maximum paths to trace. If nothing is plugged into the 'previous' input, then each pixel will trace this many paths."}
 max_paths_per_pixel 1
 addUserKnob {6 roulette t "Randomly terminate rays with a probability proportional to the remaining strength, or throughput of a ray." +STARTLINE}
 roulette true
 addUserKnob {26 ""}
 addUserKnob {7 ray_distance l "max distance" t "Each ray, once spawned is only allowed to travel this distance before it is culled." R 10 10000}
 ray_distance 100
 addUserKnob {3 max_ray_steps l "max ray steps" t "Limit the number of steps a ray can be marched before it is culled. Shadow rays are given half this number of steps."}
 max_ray_steps 1000
 addUserKnob {3 max_bounces l "max bounces" t "Limits the number of times the rays can intersect an object per subpixel."}
 max_bounces 7
 addUserKnob {7 hit_tolerance l "hit tolerance" t "The ray will be considered to have hit an object when it is within this distance of its surface" R 1e-06 0.01}
 hit_tolerance 0.0001
 addUserKnob {7 shadow_bias l "shadow bias" t "Increase the distance a ray is offset from a surface after intersecting by this factor." R 1 5}
 shadow_bias 1
 addUserKnob {7 max_brightness l "max brightness" t "The maximum brightness of a pixel. This protects against overflowing to infinity." R 1 1e+08}
 max_brightness 100000000
 addUserKnob {26 ""}
 addUserKnob {13 seeds t "The seeds used to generate per-pixel, random seeds. Be sure to change this on each render used for adaptive sampling, or set the expression on these knobs to be `random()`"}
 seeds {1 2 3}
 addUserKnob {6 enable_dof l "enable depth of field" t "Enable the use of depth of field. The amount to defocus is driven by the camera parameters." +STARTLINE}
 addUserKnob {6 level_of_detail l "dynamic level of detail" t "Increase the hit tolerance the farther the ray travels without hitting a surface. This has performance and antialiasing benefits." +STARTLINE}
 level_of_detail true
 addUserKnob {26 ""}
 addUserKnob {3 max_light_sampling_bounces l "max light sampling bounces" t "The maximum number of bounces during light sampling. Light sampling will be disabled if this is 0. Light sampling means that each time a surface is hit, the direct illumination from lights in the scene will be computed, which helps to reduce noise very quickly."}
 max_light_sampling_bounces 7
 addUserKnob {6 sample_hdri l "sample hdri" t "Include the HDRI in the list of lights that can be sampled during light sampling." -STARTLINE}
 addUserKnob {6 sample_all_lights l "sample all lights" t "Sample every light in the scene during light sampling, rather than just one random one. This will reduce noise quickly but slow things down." -STARTLINE}
 addUserKnob {7 light_sampling_bias l "light sampling bias" t "A fully biased (1) light sampling means that on each light sample the ray will be initialised pointing directly at the light. Reducing this bias means that some rays will be pointed away from the light. This, when combined with multiple 'max light sampling bounces' allows the renderer to find difficult paths, such as volumetric caustics."}
 light_sampling_bias 1
 addUserKnob {6 secondary_sampling l "secondary sampling" t "Sample the artificial lights (those in the 'lights' input) while casting shadow rays for light sampling." +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {3 equiangular_samples l "equi-angular samples" t "The number of equi-angular samples to perform if the extinction/scattering coefficients are greater than 0. This enables participating media such as fog/smoke/clouds to be traced."}
 equiangular_samples 7
 addUserKnob {6 sample_hdri_equiangular l "sample hdri" t "Sample the HDRI during equi-angular sampling. If there are no lights in the scene, this will allow you to see the participating media. With more than one light in the scene, this will increase noise." -STARTLINE}
 addUserKnob {7 refractive_index l "refractive index" t "The index of refraction of the medium that the camera is currently in." R 1 4}
 refractive_index 1
 addUserKnob {18 extinction_colour l "extinction colour" t "The colour absorbed as light travels through the material that the camera is in."}
 extinction_colour {0 0 0}
 addUserKnob {7 extinction_coefficient l "extinction coefficient" t "The amount of energy lost as the light travells through the material." R 0 10}
 addUserKnob {18 scattering_colour l "scattering colour" t "The colour being scattered by the participating media."}
 scattering_colour {1 1 1}
 addUserKnob {7 scattering_coefficient l "scattering coefficient" t "The amount of light being scattered by the participating media."}
 addUserKnob {26 ""}
 addUserKnob {7 hdri_offset_angle l "hdri offset angle" t "Rotate the hdri image by this amount around the y-axis." R 0 360}
 addUserKnob {26 ""}
 addUserKnob {6 use_precomputed_irradiance l "use precomputed irradiance" t "Use precomputed irradiance on diffuse bounces. This will mean that noise is all but illiminated imediately, and so will be fast, but will not give correct occlusion, or indirect illumination." +STARTLINE}
 addUserKnob {7 hdri_lighting_scale l "hdri irradiance scale" t "The amount to scale the precomputed irradiance. A smaller scale will improve memory usage and lookup times." R 0.1 1}
 hdri_lighting_scale 0.25
 addUserKnob {3 hdri_irradiance_samples l "hdri irradiance samples" t "The number of samples to use when precomputing the irradiance."}
 hdri_irradiance_samples 100
 addUserKnob {7 hdri_lighting_blur l "hdri irradiance blur" t "The amount to blur the precomputed irradiance. This can be necessary to increase when there are small, very bright, points in the HDRI, because they will not be sampled smoothly and quickly." R 0 10}
 hdri_lighting_blur 10
 addUserKnob {26 ""}
 addUserKnob {3 variance_range l "variance range" t "The number of adjacent pixels that will contribute to the variance of a pixel for the variance AOV which is automatically output."}
 variance_range 1
 addUserKnob {26 ""}
 addUserKnob {4 output_type l output t "The AOV type to output.\n\nThe stats AOV has the average number of steps in the red channel, the average number of bounces in the green channel, and the total number of paths that have been traced for a pixel in the blue channel." M {Beauty "World Position" "Local Position" Normal Depth Stats "" "" "" "" "" "" "" "" ""}}
 addUserKnob {41 format t "The format to output." T format_.format}
 addUserKnob {6 latlong l LatLong t "Output a LatLong, 360 degree field of view image." +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 info l "" +STARTLINE T "v2.0.0 - (c) Owen Bulka - 2022"}
}
 BackdropNode {
  inputs 0
  name Lights
  xpos -1085
  ypos -1626
  bdwidth 410
  bdheight 851
 }
 BackdropNode {
  inputs 0
  name Objects
  xpos -639
  ypos -1625
  bdwidth 1939
  bdheight 850
 }
 Input {
  inputs 0
  name camera
  xpos 1390
  ypos -1570
  number 1
 }
 Camera {
  projection_mode {{"\[expression \[value the_cam]projection_mode(\[value the_frame])]"}}
  focal {{"\[expression \[value the_cam]focal(\[value the_frame])]"}}
  haperture {{"\[expression \[value the_cam]haperture(\[value the_frame])]"}}
  vaperture {{"\[expression \[value the_cam]vaperture(\[value the_frame])]"}}
  near {{"\[expression \[value the_cam]near(\[value the_frame])]"}}
  far {{"\[expression \[value the_cam]far(\[value the_frame])]"}}
  win_translate {{"\[expression \[value the_cam]win_translate.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_translate.v(\[value the_frame])]"}}
  win_scale {{"\[expression \[value the_cam]win_scale.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_scale.v(\[value the_frame])]"}}
  winroll {{"\[expression \[value the_cam]winroll(\[value the_frame])]"}}
  focal_point {{"\[expression \[value the_cam]focal_point(\[value the_frame])]"}}
  fstop {{"\[expression \[value the_cam]fstop(\[value the_frame])]"}}
  name DummyCam
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if no Camera connected. Can also be used inside of groups and gizmos, as many levels deep as you want :D All using live and super fast TCL.\n\nUpdated v1.1: Now grabs the correct frame too (thanks Erwan Leroy for the idea).\n\nUpdated v1.3: Now accepts Nuke13's Camera3\n\nadrianpueyo.com, 2019-2021"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  xpos 1400
  ypos -1470
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\n#DummyCam v1.3 - Updated 5 May 2021.\nset starting_point \"this.input0\"\nset default \"this.d_\"\n\n# If cam has no inputs, return the default.\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera3\" && \[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera3\"||\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{ \[class \$x]==\"Input\" \} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{ \[exists \$inp] \} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {43 the_frame +INVISIBLE}
  the_frame "\[\nset the_camera \[string trimright \[value the_cam] .]\nif \{\[exists \$the_camera]\} \{\n    return \[value \$the_camera.frame]\n\} \{ \n    return \[frame]\n\}\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l "focal length" R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {30 d_win_translate l "window translate"}
  addUserKnob {30 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 version l " " t "Updated 5 May 2021" T "<span style=\"color:#666\"><br/><b>DummyCam v1.3</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019-2021</span>"}
 }
 Constant {
  inputs 0
  format "2 1 0 0 2 1 1 lights"
  name Constant3
  xpos 1500
  ypos -1545
 }
 Input {
  inputs 0
  name hdri
  xpos 1610
  ypos -1594
  number 2
 }
 Merge2 {
  inputs 2
  name Merge1
  xpos 1610
  ypos -1522
 }
 Reformat {
  type scale
  format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  black_outside true
  name Reformat5
  xpos 1610
  ypos -1498
 }
 Dot {
  name hdri_dot
  xpos 1644
  ypos -1453
 }
set N9f51430 [stack 0]
 Reformat {
  type scale
  scale {{"floor(min(parent.hdri_dot.height, parent.hdri_dot.width) * parent.hdri_lighting_scale) > 0 ? parent.hdri_lighting_scale : 1"}}
  resize fill
  name Reformat
  xpos 1720
  ypos -1457
 }
 Blur {
  size {{parent.hdri_lighting_blur}}
  name Blur2
  xpos 1720
  ypos -1415
 }
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/kernels/hdri_irradiance.blink
  recompileCount 124
  ProgramGroup 1
  KernelDescription "2 \"HDRIrradiance\" iterate pixelWise 4fa4ec41cd2454b183501b9818f4ffb89ac8c635382155a0db4a6ab53708bae2 2 \"hdri\" Read Random \"dst\" Write Point 1 \"Samples\" Int 2 ZAAAADIAAAA= 1 \"_samples\" 2 1 3 \"__hdriPixelSize\" Float 2 1 AAAAAAAAAAA= \"__up\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"__sampleStep\" Float 2 1 AAAAAAAAAAA="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n#include \"math.h\"\n\n\nkernel HDRIrradiance : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessRandom, eEdgeClamped> hdri; // the input image\n    Image<eWrite> dst; // the output image\n\n    param:\n        int2 _samples;\n\n    local:\n        float2 __hdriPixelSize;\n        float3 __up;\n        float2 __sampleStep;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        defineParam(_samples, \"Samples\", int2(100, 50));\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        __hdriPixelSize = float2(hdri.bounds.width() / (2.0f * PI), hdri.bounds.height() / PI);\n        __up = float3(0, 1, 0);\n\n        __sampleStep = float2(\n            2.0f * PI / (float) _samples.x,\n            PI / (2.0f * (float) _samples.y)\n        );\n    \}\n\n\n    /**\n     * Get the value of hdri the ray would hit at infinite distance\n     *\n     * @arg rayDirection: The direction of the ray.\n     *\n     * @returns: The colour of the pixel in the direction of the ray.\n     */\n    float4 readHDRIValue(float3 rayDirection)\n    \{\n        const float2 angles = cartesionUnitVectorToSpherical(rayDirection);\n\n        // Why does bilinear give nans? :(\n        return hdri(\n            round(__hdriPixelSize.x * angles.x) - 1,\n            round(hdri.bounds.height() - (__hdriPixelSize.y * angles.y)) - 1\n        );\n    \}\n\n\n    /**\n     * Compute the irradiance of a pixel.\n     *\n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        const float2 uvPosition = pixelsToUV(\n            float2(pos.x, pos.y),\n            float2(hdri.bounds.width(), hdri.bounds.height())\n        );\n        const float3 direction = sphericalUnitVectorToCartesion(\n            uvPositionToAngles(uvPosition)\n        );\n\n        const float3 tangentRight = normalize(cross(__up, direction));\n        const float3 tangentUp = normalize(cross(direction, tangentRight));\n\n        float4 irradiance = float4(0);\n\n        for (float theta = 0.0f; theta < 2.0f * PI; theta += __sampleStep.x)\n        \{\n            for (float phi = PI / 2.0f; phi > 0.0f; phi -= __sampleStep.y)\n            \{\n                const float3 tangent = sphericalUnitVectorToCartesion(float2(theta, phi));\n                const float3 sampleDirection = (\n                    tangent.x * tangentRight\n                    + tangent.z * tangentUp\n                    + tangent.y * direction\n                );\n\n                irradiance += readHDRIValue(sampleDirection) * cos(phi) * sin(phi);\n            \}\n        \}\n\n        dst() = PI * irradiance / (float) (_samples.x * _samples.y);\n    \}\n\};\n"
  rebuild ""
  HDRIrradiance_Samples {{parent.hdri_irradiance_samples} {parent.hdri_irradiance_samples/2}}
  rebuild_finalise ""
  name HDRIrradiance
  xpos 1720
  ypos -1363
 }
 Reformat {
  type scale
  format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  black_outside true
  name Reformat3
  xpos 1720
  ypos -1305
 }
 Dot {
  name Dot33
  xpos 1754
  ypos -558
 }
 Constant {
  inputs 0
  format "1 1 0 0 1 1 1 1x1"
  name Constant4
  xpos -1580
  ypos -1713
 }
 Dot {
  name Dot7
  xpos -1546
  ypos -1542
 }
set N13d2c1a0 [stack 0]
 Dot {
  name Dot25
  xpos -1106
  ypos -1542
 }
set N1ae70940 [stack 0]
 Dot {
  name Dot15
  xpos -1106
  ypos -1446
 }
push $N1ae70940
 Input {
  inputs 0
  name lights
  xpos -1030
  ypos -1594
  number 4
 }
 Merge2 {
  inputs 2
  name light_merge
  xpos -1030
  ypos -1498
 }
 Group {
  inputs 2
  name light_input_protection
  xpos -1030
  ypos -1450
  disable {{"width > 1"}}
  addUserKnob {20 User}
  addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
 }
  Reformat {
   inputs 0
   type "to box"
   box_width 1
   box_height 1
   box_fixed true
   name Reformat1
   xpos -119
   ypos 440
  }
  Input {
   inputs 0
   name Input2
   xpos 158
   ypos -28
   number 1
  }
  Dot {
   name Dot2
   xpos 192
   ypos -2
  }
set N1f9a7850 [stack 0]
  Dot {
   name Dot3
   xpos 329
   ypos -2
  }
  Dot {
   name Dot4
   xpos 329
   ypos 391
  }
  Input {
   inputs 0
   name Input1
   xpos 0
   ypos -32
  }
  Dot {
   name Dot1
   xpos 34
   ypos -6
  }
set Nc0dd610 [stack 0]
  Dot {
   name Dot6
   xpos -98
   ypos -6
  }
  Dot {
   name Dot5
   xpos -98
   ypos 336
  }
push $N1f9a7850
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop3
   xpos 158
   ypos 69
  }
  Crop {
   box {0 0 {parent.Dot2.width} 1}
   name Crop4
   xpos 158
   ypos 95
  }
  Transform {
   translate {{parent.Dot1.width} 0}
   center {1 0.5}
   name Transform2
   xpos 158
   ypos 121
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop5
   xpos 158
   ypos 167
  }
push $Nc0dd610
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop6
   xpos 0
   ypos 66
  }
  Crop {
   box {0 0 {parent.Dot1.width} 1}
   name Crop7
   xpos 0
   ypos 92
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop8
   xpos 0
   ypos 164
  }
  Merge2 {
   inputs 2
   also_merge all
   name Merge1
   xpos 0
   ypos 262
   disable {{"\[exists parent.input1] ? 0:1"}}
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input1] ? 0:1"}}
   name Switch2
   xpos 0
   ypos 332
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:1"}}
   name Switch1
   xpos 0
   ypos 387
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
   name Switch3
   xpos 0
   ypos 456
  }
  Dot {
   name out_dot
   xpos 36
   ypos 518
  }
  Output {
   name Output1
   xpos 2
   ypos 661
  }
 end_group
 Dot {
  name light_dot
  xpos -996
  ypos -1302
 }
set N188a7780 [stack 0]
 Shuffle {
  in sdf_light_properties1
  blue green
  alpha green
  name light_props1
  xpos -810
  ypos -994
 }
 Dot {
  name Dot22
  xpos -776
  ypos -822
 }
push $N188a7780
 Shuffle {
  in sdf_light_properties
  name light_props
  xpos -920
  ypos -994
 }
 Dot {
  name Dot23
  xpos -886
  ypos -822
 }
push $N188a7780
 Shuffle {
  in sdf_light
  name light
  xpos -1030
  ypos -994
 }
 Dot {
  name Dot24
  xpos -996
  ypos -822
 }
push $N1ae70940
 Dot {
  name Dot16
  xpos -556
  ypos -1542
 }
set N14b2c480 [stack 0]
 Dot {
  name Dot36
  xpos 874
  ypos -1542
 }
 Input {
  inputs 0
  name noise
  xpos 950
  ypos -1594
  number 5
 }
 Merge2 {
  inputs 2
  name noise_merge
  xpos 950
  ypos -1498
 }
push $N14b2c480
 Input {
  inputs 0
  name scene
  xpos -480
  ypos -1594
 }
 Merge2 {
  inputs 2
  name object_merge
  xpos -480
  ypos -1498
 }
 Dot {
  name Dot37
  xpos -446
  ypos -1446
 }
set N1221d470 [stack 0]
 Group {
  inputs 2
  name noise_sdf_merge
  xpos 950
  ypos -1450
  addUserKnob {20 User}
  addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
 }
  Reformat {
   inputs 0
   type "to box"
   box_width 1
   box_height 1
   box_fixed true
   name Reformat1
   xpos -119
   ypos 440
  }
  Input {
   inputs 0
   name Input2
   xpos 158
   ypos -28
   number 1
  }
  Dot {
   name Dot2
   xpos 192
   ypos -2
  }
set N11362730 [stack 0]
  Dot {
   name Dot3
   xpos 329
   ypos -2
  }
  Dot {
   name Dot4
   xpos 329
   ypos 391
  }
  Input {
   inputs 0
   name Input1
   xpos 0
   ypos -32
  }
  Dot {
   name Dot1
   xpos 34
   ypos -6
  }
set N1aaf6400 [stack 0]
  Dot {
   name Dot6
   xpos -98
   ypos -6
  }
  Dot {
   name Dot5
   xpos -98
   ypos 336
  }
push $N11362730
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop3
   xpos 158
   ypos 69
  }
  Crop {
   box {0 0 {parent.Dot2.width} 1}
   name Crop4
   xpos 158
   ypos 95
  }
  Transform {
   translate {{parent.Dot1.width} 0}
   center {1 0.5}
   name Transform2
   xpos 158
   ypos 121
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop5
   xpos 158
   ypos 167
  }
push $N1aaf6400
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop6
   xpos 0
   ypos 66
  }
  Crop {
   box {0 0 {parent.Dot1.width} 1}
   name Crop7
   xpos 0
   ypos 92
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop8
   xpos 0
   ypos 164
  }
  Merge2 {
   inputs 2
   also_merge all
   name Merge1
   xpos 0
   ypos 262
   disable {{"\[exists parent.input1] ? 0:1"}}
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input1] ? 0:1"}}
   name Switch2
   xpos 0
   ypos 332
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:1"}}
   name Switch1
   xpos 0
   ypos 387
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
   name Switch3
   xpos 0
   ypos 456
  }
  Dot {
   name out_dot
   xpos 36
   ypos 518
  }
  Output {
   name Output1
   xpos 2
   ypos 661
  }
 end_group
 Dot {
  name Dot35
  xpos 984
  ypos -1230
 }
set N19f562e0 [stack 0]
 Shuffle {
  in sdf_noise_params2
  name noise_params2
  xpos 1170
  ypos -994
 }
 Dot {
  name Dot28
  xpos 1204
  ypos -822
 }
push $N19f562e0
 Shuffle {
  in sdf_noise_params1
  name noise_params1
  xpos 1060
  ypos -994
 }
 Dot {
  name Dot26
  xpos 1094
  ypos -822
 }
push $N19f562e0
 Shuffle {
  in sdf_noise_params0
  name noise_params0
  xpos 950
  ypos -994
 }
 Dot {
  name Dot27
  xpos 984
  ypos -822
 }
push $N14b2c480
 Dot {
  name Dot1
  xpos -556
  ypos -1374
 }
push $N1221d470
 Group {
  inputs 2
  name object_input_protection
  xpos -480
  ypos -1378
  disable {{"width > 1"}}
  addUserKnob {20 User}
  addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
 }
  Reformat {
   inputs 0
   type "to box"
   box_width 1
   box_height 1
   box_fixed true
   name Reformat1
   xpos -119
   ypos 440
  }
  Input {
   inputs 0
   name Input2
   xpos 158
   ypos -28
   number 1
  }
  Dot {
   name Dot2
   xpos 192
   ypos -2
  }
set N1fe932a0 [stack 0]
  Dot {
   name Dot3
   xpos 329
   ypos -2
  }
  Dot {
   name Dot4
   xpos 329
   ypos 391
  }
  Input {
   inputs 0
   name Input1
   xpos 0
   ypos -32
  }
  Dot {
   name Dot1
   xpos 34
   ypos -6
  }
set N1f5d5f00 [stack 0]
  Dot {
   name Dot6
   xpos -98
   ypos -6
  }
  Dot {
   name Dot5
   xpos -98
   ypos 336
  }
push $N1fe932a0
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop3
   xpos 158
   ypos 69
  }
  Crop {
   box {0 0 {parent.Dot2.width} 1}
   name Crop4
   xpos 158
   ypos 95
  }
  Transform {
   translate {{parent.Dot1.width} 0}
   center {1 0.5}
   name Transform2
   xpos 158
   ypos 121
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop5
   xpos 158
   ypos 167
  }
push $N1f5d5f00
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop6
   xpos 0
   ypos 66
  }
  Crop {
   box {0 0 {parent.Dot1.width} 1}
   name Crop7
   xpos 0
   ypos 92
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop8
   xpos 0
   ypos 164
  }
  Merge2 {
   inputs 2
   also_merge all
   name Merge1
   xpos 0
   ypos 262
   disable {{"\[exists parent.input1] ? 0:1"}}
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input1] ? 0:1"}}
   name Switch2
   xpos 0
   ypos 332
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:1"}}
   name Switch1
   xpos 0
   ypos 387
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
   name Switch3
   xpos 0
   ypos 456
  }
  Dot {
   name out_dot
   xpos 36
   ypos 518
  }
  Output {
   name Output1
   xpos 2
   ypos 661
  }
 end_group
 Dot {
  name obj_dot
  xpos -446
  ypos -1326
 }
set N1af4ae50 [stack 0]
 Shuffle {
  in sdf_surface
  name surface
  xpos 730
  ypos -994
 }
 Dot {
  name Dot2
  xpos 764
  ypos -822
 }
push $N1af4ae50
 Shuffle {
  in sdf_shape_mods_1
  name shape_mods_1
  xpos 620
  ypos -994
 }
 Dot {
  name Dot12
  xpos 654
  ypos -822
 }
push $N1af4ae50
 Shuffle {
  in sdf_shape_mods_0
  name shape_mods_0
  xpos 510
  ypos -994
 }
 Dot {
  name Dot3
  xpos 544
  ypos -822
 }
push $N1af4ae50
 Shuffle {
  in sdf_shape
  name shape
  xpos 400
  ypos -994
 }
 Dot {
  name Dot4
  xpos 434
  ypos -822
 }
push $N1af4ae50
 Shuffle {
  in sdf_scattering_colour
  name scattering_colour
  xpos 290
  ypos -994
 }
 Dot {
  name Dot38
  xpos 324
  ypos -822
 }
push $N1af4ae50
 Shuffle {
  in sdf_emm_colour
  name emm_colour
  xpos 180
  ypos -994
 }
 Dot {
  name Dot20
  xpos 214
  ypos -822
 }
push $N1af4ae50
 Shuffle {
  in sdf_trans_colour
  name trans_colour
  xpos 70
  ypos -994
 }
 Dot {
  name Dot19
  xpos 104
  ypos -822
 }
push $N1af4ae50
 Shuffle {
  in sdf_spec_colour
  name spec_colour
  xpos -40
  ypos -994
 }
 Dot {
  name Dot18
  xpos -6
  ypos -822
 }
push $N1af4ae50
 Shuffle {
  in sdf_colour
  name diff_colour
  xpos -150
  ypos -994
 }
 Dot {
  name Dot5
  xpos -116
  ypos -822
 }
push $N1af4ae50
 Shuffle {
  in sdf_dimensions
  name dimensions
  xpos -260
  ypos -994
 }
 Dot {
  name Dot10
  xpos -226
  ypos -822
 }
push $N1af4ae50
 Shuffle {
  in sdf_rotation_wall_thickness
  name rotation_wall_thickness
  xpos -370
  ypos -994
 }
 Dot {
  name Dot9
  xpos -336
  ypos -822
 }
push $N1af4ae50
 Shuffle {
  in sdf_position_scale
  name position_scale
  xpos -480
  ypos -994
 }
 Dot {
  name Dot6
  xpos -446
  ypos -822
 }
push $N9f51430
push $N13d2c1a0
 Reformat {
  format {{{parent.format_.format}}}
  name Reformat2
  xpos -1580
  ypos -1498
 }
set Ne434f40 [stack 0]
 Input {
  inputs 0
  name previous
  xpos -1470
  ypos -1618
  number 3
 }
 Merge2 {
  inputs 2
  name previous_merge
  xpos -1470
  ypos -1498
 }
 Dot {
  name Dot14
  xpos -1436
  ypos -1374
 }
set N1b089ed0 [stack 0]
 Shuffle {
  in variance
  name Shuffle1
  xpos -1470
  ypos -1330
 }
push $Ne434f40
 Invert {
  channels rgb
  name Invert2
  xpos -1580
  ypos -1306
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input3]"}}
  name Switch2
  xpos -1470
  ypos -1306
 }
 Dot {
  name Dot13
  xpos -1436
  ypos -462
 }
push $N1b089ed0
 Dot {
  name Dot34
  xpos -1326
  ypos -1374
 }
 Dot {
  name Dot21
  xpos -1326
  ypos -606
 }
 Constant {
  inputs 0
  channels {rgba.red rgba.green rgba.blue -rgba.alpha}
  name format_
  xpos 1830
  ypos -707
 }
 Noise {
  output {rgba.red -rgba.green -rgba.blue -rgba.alpha}
  type turbulence
  size 1
  zoffset {{parent.seeds.x}}
  lacunarity 1.6
  center {512 389}
  name Noise1
  xpos 1830
  ypos -636
 }
 Noise {
  output {-rgba.red rgba.green -rgba.blue -rgba.alpha}
  type turbulence
  size 1
  zoffset {{parent.seeds.y}}
  center {512 389}
  name Noise2
  xpos 1830
  ypos -612
 }
 Noise {
  output {-rgba.red -rgba.green rgba.blue -rgba.alpha}
  type turbulence
  size 1
  zoffset {{parent.seeds.z}}
  lacunarity 2.14
  center {512 389}
  name Noise3
  xpos 1830
  ypos -588
 }
 Noise {
  output {-rgba.red -rgba.green -rgba.blue rgba.alpha}
  type turbulence
  size 1
  zoffset {{parent.seeds.z}}
  lacunarity 2.14
  center {512 389}
  name Noise4
  xpos 1830
  ypos -562
 }
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/kernels/random.blink
  recompileCount 8
  ProgramGroup 1
  KernelDescription "2 \"Random\" iterate pixelWise f51a1ffdf1b096c3af17073edd1520221f207854b2f525ed29f01e133fbdefd4 2 \"seed\" Read Point \"dst\" Write Point 1 \"Inclusive Range\" Float 2 AAAAAAAAgD8= 1 \"_inclusiveRange\" 2 1 1 \"__rangeLength\" Float 1 1 AAAAAA=="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n#include \"math.h\"\n#include \"random.h\"\n\n\nkernel Random : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessPoint, eEdgeNone> seed; // the input image\n    Image<eWrite> dst; // the output image\n\n\n    param:\n        float2 _inclusiveRange;\n\n    local:\n        float __rangeLength;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        defineParam(_inclusiveRange, \"Inclusive Range\", float2(0, 1));\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        __rangeLength = _inclusiveRange.y - _inclusiveRange.x;\n    \}\n\n\n    /**\n     * Compute a random pixel value.\n     */\n    void process()\n    \{\n        dst() = __rangeLength * random(seed()) + _inclusiveRange.x;\n    \}\n\};\n"
  rebuild ""
  rebuild_finalise ""
  name BlinkScript7
  xpos 1830
  ypos -524
 }
 Dot {
  name resolution_dot
  xpos 1864
  ypos -462
 }
 BlinkScript {
  inputs 23
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/kernels/ray_march.blink
  recompileCount 3210
  ProgramGroup 1
  KernelDescription "2 \"RayMarchKernel\" iterate pixelWise feab6167565d9a9c6155bfb1f20616f82c8bd16150d4b0074cb14a40c6856a63 24 \"noise\" Read Point \"src\" Read Point \"variance\" Read Point \"hdri\" Read Random \"positions\" Read Random \"rotations\" Read Random \"dimensions\" Read Random \"diffusivities\" Read Random \"specularities\" Read Random \"transmittances\" Read Random \"emittances\" Read Random \"scatteringCoefficients\" Read Random \"shapeProperties\" Read Random \"shapeModParameters0\" Read Random \"shapeModParameters1\" Read Random \"surfaceProperties\" Read Random \"noiseParams0\" Read Random \"noiseParams1\" Read Random \"noiseParams2\" Read Random \"lights\" Read Random \"lightProperties\" Read Random \"lightProperties1\" Read Random \"irradiance\" Read Random \"dst\" Write Point 36 \"Focal Length\" Float 1 AABIQg== \"Horizontal Aperture\" Float 1 ppvEQQ== \"Near Plane\" Float 1 zczMPQ== \"Far Plane\" Float 1 AEAcRg== \"Camera World Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"Focal Distance\" Float 1 AACAQA== \"fstop\" Float 1 AACAQQ== \"Enable Depth Of Field\" Bool 1 AQ== \"Screen Width\" Float 1 AABwRQ== \"Screen Height\" Float 1 AAAHRQ== \"HDRI Offset Angle\" Float 1 AAAAAA== \"Use Precomputed Irradiance\" Bool 1 AQ== \"Min Paths Per Pixel\" Int 1 AQAAAA== \"Max Paths Per Pixel\" Int 1 AQAAAA== \"Roulette\" Bool 1 AQ== \"Max Bounces\" Int 1 AQAAAA== \"Max Light Sampling Bounces\" Int 1 AAAAAA== \"Sample HDRI\" Bool 1 AQ== \"Sample All Lights\" Bool 1 AA== \"Secondary Light Sampling\" Bool 1 AA== \"Light Sampling Bias\" Float 1 AAAAAA== \"Max Ray Distance\" Float 1 AAB6RA== \"Max Ray Steps\" Int 1 gAAAAA== \"Level of Detail\" Bool 1 AQ== \"Hit Tolerance\" Float 1 bxKDOg== \"Shadow Bias\" Float 1 AACAPw== \"Maximum Brightness\" Float 1 /iN0SQ== \"Index of Refraction\" Float 1 AACAPw== \"Scattering Coefficient\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Extinction Coefficient\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"Equi-Angular Samples\" Int 1 BQAAAA== \"Sample HDRI Equi-Angular\" Bool 1 AQ== \"Object Texture Width\" Int 1 AAAAAA== \"Light Texture Width\" Int 1 AAAAAA== \"Output Type\" Int 1 AAAAAA== \"Output LatLong\" Bool 1 AA== 36 \"_focalLength\" 1 1 \"_horizontalAperture\" 1 1 \"_nearPlane\" 1 1 \"_farPlane\" 1 1 \"_cameraWorldMatrix\" 16 1 \"_focalDistance\" 1 1 \"_fStop\" 1 1 \"_depthOfFieldEnabled\" 1 1 \"_formatWidth\" 1 1 \"_formatHeight\" 1 1 \"_hdriOffsetAngle\" 1 1 \"_usePrecomputedIrradiance\" 1 1 \"_minPathsPerPixel\" 1 1 \"_maxPathsPerPixel\" 1 1 \"_roulette\" 1 1 \"_maxBounces\" 1 1 \"_maxLightSamplingBounces\" 1 1 \"_sampleHDRI\" 1 1 \"_sampleAllLights\" 1 1 \"_doSecondaryLightSampling\" 1 1 \"_lightSamplingBias\" 1 1 \"_maxRayDistance\" 1 1 \"_maxRaySteps\" 1 1 \"_levelOfDetail\" 1 1 \"_hitTolerance\" 1 1 \"_shadowBias\" 1 1 \"_maxBrightness\" 1 1 \"_refractiveIndex\" 1 1 \"_scatteringCoefficient\" 4 1 \"_extinctionCoefficient\" 4 1 \"_equiangularSamples\" 1 1 \"_sampleHDRIEquiangular\" 1 1 \"_objectTextureWidth\" 1 1 \"_lightTextureWidth\" 1 1 \"_outputType\" 1 1 \"_latLong\" 1 1 13 \"__inverseCameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"__aperture\" Float 1 1 AAAAAA== \"__bouncesPerRay\" Int 1 1 AAAAAA== \"__lightSamplingEnabled\" Bool 1 1 AA== \"__lightSamplingAngle\" Float 1 1 AAAAAA== \"__equiangularSamplingEnabled\" Bool 1 1 AA== \"__hdriPixelSize\" Float 2 1 AAAAAAAAAAA= \"__irradiancePixelSize\" Float 2 1 AAAAAAAAAAA= \"__hdriOffsetRadians\" Float 1 1 AAAAAA== \"__offset0\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"__offset1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"__offset2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"__offset3\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n//\n// BlinkScript Ray Marcher\n//\n\n#include \"math.h\"\n#include \"random.h\"\n#include \"noise.h\"\n#include \"conversion.h\"\n#include \"aovs.h\"\n#include \"lights.h\"\n#include \"material.h\"\n#include \"camera.h\"\n#include \"objectInteraction.h\"\n#include \"sdfModifications.h\"\n#include \"sdfs.h\"\n\n\n// Increase this if you want more than MAX_CHILD_DEPTH direct children\n#define MAX_CHILD_DEPTH 32\n#define MAX_MIS_EMISSIVE_SHAPES 32\n\n// Number of parameters needed in the parent stacks\n#define PARENT_STACK_PARAMS 8\n#define FULL_PARENT_STACK_PARAMS 29\n\n// Indices to store parent stack data\n#define NUM_CHILDREN 0\n#define TRANSFORM_X 1\n#define TRANSFORM_Y 2\n#define TRANSFORM_Z 3\n#define SCALE 4\n#define MODIFICATIONS 5\n#define BLEND_STRENGTH 6\n#define DISTANCE 7\n#define DIFFUSE_COLOUR_R 8\n#define DIFFUSE_COLOUR_G 9\n#define DIFFUSE_COLOUR_B 10\n#define SPECULAR_ROUGHNESS 11\n#define SPECULAR_COLOUR_R 12\n#define SPECULAR_COLOUR_G 13\n#define SPECULAR_COLOUR_B 14\n#define SPECULAR 15\n#define EXTINCTION_R 16\n#define EXTINCTION_G 17\n#define EXTINCTION_B 18\n#define TRANSMISSION 19\n#define EMISSION_R 20\n#define EMISSION_G 21\n#define EMISSION_B 22\n#define SCATTERING_R 23\n#define SCATTERING_G 24\n#define SCATTERING_B 25\n#define TRANSMISSION_ROUGHNESS 26\n#define PARENT_REFRACTIVE_INDEX 27\n#define PARENT_OBJECT_ID 28\n\n// Maximum recursion depth for ray marching\n#define MAX_RAYS_PER_SUBPIXEL 100\n\n#define IS_BOUND 4096\n\n#define IS_NOT_UNION 3968\n\n\nkernel RayMarchKernel : ImageComputationKernel<ePixelWise>\n\{\n    // the input which specifies the format, process is called once per pixel\n    // in this image, which also provides random seeds\n    Image<eRead, eAccessPoint, eEdgeNone> noise;\n    Image<eRead, eAccessPoint, eEdgeNone> src;\n    Image<eRead, eAccessPoint, eEdgeNone> variance;\n\n    // the hdri in latlong format\n    Image<eRead, eAccessRandom, eEdgeNone> hdri;\n\n\n    // the shape positons.xyz, scale.w\n    Image<eRead, eAccessRandom, eEdgeNone> positions;\n\n    // the shape rotations.xyz, wall thickness.w\n    Image<eRead, eAccessRandom, eEdgeNone> rotations;\n\n    // the shape dimensions.xyzw (some shapes may not use all channels)\n    Image<eRead, eAccessRandom, eEdgeNone> dimensions;\n\n    // the shape diffusivities.xyz, specular roughness.w\n    Image<eRead, eAccessRandom, eEdgeNone> diffusivities;\n\n    Image<eRead, eAccessRandom, eEdgeNone> specularities;\n\n    Image<eRead, eAccessRandom, eEdgeNone> transmittances;\n\n    Image<eRead, eAccessRandom, eEdgeNone> emittances;\n\n    Image<eRead, eAccessRandom, eEdgeNone> scatteringCoefficients;\n\n\n    // shape type.x, operation.y, numChildren.z, blend strength.w\n    Image<eRead, eAccessRandom, eEdgeNone> shapeProperties;\n\n    // repetition params.xyzw\n    Image<eRead, eAccessRandom, eEdgeNone> shapeModParameters0;\n\n    // elongation.xyz edgeRadius.w\n    Image<eRead, eAccessRandom, eEdgeNone> shapeModParameters1;\n\n    // reflection.x, transmission.y, emission.z, roughness.w\n    Image<eRead, eAccessRandom, eEdgeNone> surfaceProperties;\n\n    // noise options.x translation.yzw\n    Image<eRead, eAccessRandom, eEdgeNone> noiseParams0;\n\n    // octaves.x, lacunarity.y, gain.z, gamma.w\n    Image<eRead, eAccessRandom, eEdgeNone> noiseParams1;\n\n    // size.x\n    Image<eRead, eAccessRandom, eEdgeNone> noiseParams2;\n\n    // the input lights direction/position.xyz intensity.w\n    Image<eRead, eAccessRandom, eEdgeNone> lights;\n\n    // colour.xyz, type.w\n    // w in \[0, 1) = directional, \[1, inf) = point\n    Image<eRead, eAccessRandom, eEdgeNone> lightProperties;\n\n    // shadow hardness.x\n    Image<eRead, eAccessRandom, eEdgeNone> lightProperties1;\n\n    // the precomputed irradiance of the hdri\n    Image<eRead, eAccessRandom, eEdgeClamped> irradiance;\n\n\n    // the output image\n    Image<eWrite> dst;\n\n\n    param:\n        // These parameters are made available to the user.\n\n        // Camera params\n        float _focalLength;\n        float _horizontalAperture;\n        float _nearPlane;\n        float _farPlane;\n        float4x4 _cameraWorldMatrix;\n        float _focalDistance;\n        float _fStop;\n        bool _depthOfFieldEnabled;\n\n        // Image params\n        float _formatWidth;\n        float _formatHeight;\n\n        float _hdriOffsetAngle;\n        bool _usePrecomputedIrradiance;\n\n        // Ray params\n        int _minPathsPerPixel;\n        int _maxPathsPerPixel;\n        bool _roulette;\n        int _maxBounces;\n        int _maxLightSamplingBounces;\n        bool _sampleHDRI;\n        bool _sampleAllLights;\n        bool _doSecondaryLightSampling;\n        float _lightSamplingBias;\n        float _maxRayDistance;\n        int _maxRaySteps;\n        bool _levelOfDetail;\n        float _hitTolerance;\n        float _shadowBias;\n        float _maxBrightness;\n\n        // Scene params\n        float _refractiveIndex;\n        float4 _scatteringCoefficient;\n        float4 _extinctionCoefficient;\n        int _equiangularSamples;\n        bool _sampleHDRIEquiangular;\n\n        // Shape Textures\n        int _objectTextureWidth;\n        int _lightTextureWidth;\n\n        int _outputType;\n\n        bool _latLong;\n\n\n    local:\n        // These local variables are not exposed to the user.\n\n        float4x4 __inverseCameraProjectionMatrix;\n        float __aperture;\n\n        int __bouncesPerRay;\n        bool __lightSamplingEnabled;\n        float __lightSamplingAngle;\n        bool __equiangularSamplingEnabled;\n\n        float2 __hdriPixelSize;\n        float2 __irradiancePixelSize;\n        float __hdriOffsetRadians;\n\n        float3 __offset0;\n        float3 __offset1;\n        float3 __offset2;\n        float3 __offset3;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        // Camera params\n        defineParam(_focalLength, \"Focal Length\", 50.0f);\n        defineParam(_horizontalAperture, \"Horizontal Aperture\", 24.576f);\n        defineParam(_nearPlane, \"Near Plane\", 0.1f);\n        defineParam(_farPlane, \"Far Plane\", 10000.0f);\n        defineParam(\n            _cameraWorldMatrix,\n            \"Camera World Matrix\",\n            float4x4(\n                1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1\n            )\n        );\n        defineParam(_focalDistance, \"Focal Distance\", 4.0f);\n        defineParam(_fStop, \"fstop\", 16.0f);\n        defineParam(_depthOfFieldEnabled, \"Enable Depth Of Field\", true);\n\n        // Image params\n        defineParam(_formatHeight, \"Screen Height\", 2160.0f);\n        defineParam(_formatWidth, \"Screen Width\", 3840.0f);\n        defineParam(_hdriOffsetAngle, \"HDRI Offset Angle\", 0.0f);\n        defineParam(_usePrecomputedIrradiance, \"Use Precomputed Irradiance\", true);\n\n        // Ray params\n        defineParam(_minPathsPerPixel, \"Min Paths Per Pixel\", 1);\n        defineParam(_maxPathsPerPixel, \"Max Paths Per Pixel\", 1);\n        defineParam(_roulette, \"Roulette\", true);\n        defineParam(_maxRayDistance, \"Max Ray Distance\", 1000.0f);\n        defineParam(_maxRaySteps, \"Max Ray Steps\", 128);\n        defineParam(_maxBounces, \"Max Bounces\", 1);\n        defineParam(_maxLightSamplingBounces, \"Max Light Sampling Bounces\", 0);\n        defineParam(_sampleHDRI, \"Sample HDRI\", true);\n        defineParam(_sampleAllLights, \"Sample All Lights\", false);\n        defineParam(_doSecondaryLightSampling, \"Secondary Light Sampling\", false);\n        defineParam(_lightSamplingBias, \"Light Sampling Bias\", 0.0f);\n        defineParam(_levelOfDetail, \"Level of Detail\", true);\n        defineParam(_hitTolerance, \"Hit Tolerance\", 0.001f);\n        defineParam(_shadowBias, \"Shadow Bias\", 1.0f);\n        defineParam(_maxBrightness, \"Maximum Brightness\", 999999.9f);\n\n        // Scene params\n        defineParam(_refractiveIndex, \"Index of Refraction\", 1.0f);\n        defineParam(_scatteringCoefficient, \"Scattering Coefficient\", float4(0));\n        defineParam(_extinctionCoefficient, \"Extinction Coefficient\", float4(1));\n        defineParam(_equiangularSamples, \"Equi-Angular Samples\", 5);\n        defineParam(_sampleHDRIEquiangular, \"Sample HDRI Equi-Angular\", true);\n\n        // Shape Counts\n        defineParam(_objectTextureWidth, \"Object Texture Width\", 0);\n        defineParam(_lightTextureWidth, \"Light Texture Width\", 0);\n\n        defineParam(_outputType, \"Output Type\", 0);\n\n        defineParam(_latLong, \"Output LatLong\", false);\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        __bouncesPerRay = max(0, _maxBounces);\n\n        __lightSamplingEnabled = _maxLightSamplingBounces > 0;\n\n        __lightSamplingAngle = PI * (1.0f - saturate(_lightSamplingBias));\n\n        __equiangularSamplingEnabled = _equiangularSamples > 0;\n\n        float aspect = aspectRatio(_formatHeight, _formatWidth);\n        float4x4 cameraProjectionMatrix = projectionMatrix(\n            _focalLength,\n            _horizontalAperture,\n            aspect,\n            _nearPlane,\n            _farPlane\n        );\n        __inverseCameraProjectionMatrix = cameraProjectionMatrix.invert();\n\n        __aperture = fStopToAperture(_fStop, _focalLength);\n\n        __hdriPixelSize = float2(\n            hdri.bounds.width() / (2 * PI),\n            hdri.bounds.height() / PI\n        );\n        __irradiancePixelSize = float2(\n            irradiance.bounds.width() / (2 * PI),\n            irradiance.bounds.height() / PI\n        );\n        __hdriOffsetRadians = degreesToRadians(_hdriOffsetAngle);\n\n        __offset0 = 0.5773f * float3(1, -1, -1);\n        __offset1 = 0.5773f * float3(-1, -1, 1);\n        __offset2 = 0.5773f * float3(-1, 1, -1);\n        __offset3 = 0.5773f * float3(1, 1, 1);\n    \}\n\n\n    /**\n     * Get the noise value at a position.\n     *\n     * @arg index: The index of the noise.\n     * @arg position: The position at which we want the noise.\n     * @arg noiseOptions: The noise modifier options.\n     *\n     * @returns: The noise value.\n     */\n    float getNoiseValue(const int index, const float3 &position, int &noiseOptions)\n    \{\n        // Make sure there is a noise node plugged into the object.\n        noiseOptions = (int) noiseParams0(index, 0, 0);\n        if ((noiseOptions & NOISE_ENABLED) == 0)\n        \{\n            return -1.0f;\n        \}\n\n        // Read the noise parameters\n        const float3 translation = float3(\n            noiseParams0(index, 0, 1),\n            noiseParams0(index, 0, 2),\n            noiseParams0(index, 0, 3)\n        );\n\n        const int octaves = noiseParams1(index, 0, 0);\n        const float lacunarity = noiseParams1(index, 0, 1);\n        const float gain = noiseParams1(index, 0, 2);\n        const float gamma = noiseParams1(index, 0, 3);\n        const float size = noiseParams2(index, 0, 0);\n\n        // Translate the noise, and convert the position to the local\n        // coordinate system\n        float3 noisePosition;\n        if (index == _objectTextureWidth)\n        \{\n            noisePosition = position + translation;\n        \}\n        else\n        \{\n            noisePosition = worldToLocal(index, position + translation);\n        \}\n\n        // Get the noise value based on which type of noise we are using\n        float noiseValue;\n        if (noiseOptions & FBM_NOISE)\n        \{\n            noiseValue = fractalBrownianMotionNoise(\n                octaves,\n                lacunarity,\n                size,\n                gain,\n                gamma,\n                noisePosition\n            );\n        \}\n        else\n        \{\n            noiseValue = turbulenceNoise(\n                octaves,\n                lacunarity,\n                size,\n                gain,\n                gamma,\n                noisePosition\n            );\n        \}\n\n        // Modify the noise using the grade parameters\n        const float whitePoint = noiseParams2(index, 0, 1);\n        const float blackPoint = noiseParams2(index, 0, 2);\n        const float lift = noiseParams2(index, 0, 3);\n\n        if (whitePoint != blackPoint)\n        \{\n            noiseValue = saturate((noiseValue - blackPoint) / (whitePoint - blackPoint));\n        \}\n\n        noiseValue = saturate(noiseValue * (1.0f - lift) + lift);\n\n        if (noiseOptions & INVERT_NOISE)\n        \{\n            noiseValue = 1.0f - noiseValue;\n        \}\n\n        return noiseValue;\n    \}\n\n\n    /**\n     * Modify the material properties of an object based on noise.\n     *\n     * @arg objectIndex: The index of the object.\n     * @arg intersectionPosition: The position at which the we are\n     *     modifying the material.\n     * @arg diffusivity: The diffuse values of the surface.\n     * @arg specularity: The specular values of the surface.\n     * @arg transmittance: The extinction coefficient and transmissive\n     *     probability of the surface.\n     * @arg emittance: The emissive values of the surface.\n     * @arg specularRoughness: The specular roughness of the surface.\n     * @arg transmissionRoughness: The transmissive roughness of the\n     *     surface.\n     * @arg refractiveIndex: The refractive index of the material.\n     */\n    void noiseMaterialInteraction(\n            const int objectIndex,\n            const float3 &intersectionPosition,\n            float4 &diffusivity,\n            float4 &specularity,\n            float4 &transmittance,\n            float4 &emittance,\n            float &specularRoughness,\n            float &transmissionRoughness,\n            float &refractiveIndex)\n    \{\n        int noiseOptions;\n        const float noiseValue = getNoiseValue(\n            objectIndex,\n            intersectionPosition,\n            noiseOptions\n        );\n        if (noiseValue >= 0.0f)\n        \{\n            useNoiseOnMaterial(\n                noiseOptions,\n                noiseValue,\n                diffusivity,\n                specularity,\n                transmittance,\n                emittance,\n                specularRoughness,\n                transmissionRoughness,\n                refractiveIndex\n            );\n        \}\n    \}\n\n\n    /**\n     * Get the value of hdri the ray would hit at infinite distance\n     *\n     * @arg rayDirection: The direction of the ray.\n     *\n     * @returns: The colour of the pixel in the direction of the ray.\n     */\n    float4 readHDRIValue(float3 rayDirection)\n    \{\n        const float2 angles = cartesionUnitVectorToSpherical(rayDirection, __hdriOffsetRadians);\n\n        // Should be able to say image access is eEdgeClamped and not do this\n        // but I see nan pixels sooo... :(\n        const float2 indices = clamp(\n            float2(\n                __hdriPixelSize.x * angles.x,\n                hdri.bounds.height() - (__hdriPixelSize.y * angles.y)\n            ),\n            float2(0),\n            float2(hdri.bounds.width(), hdri.bounds.height()) - 1.0f\n        );\n\n        return bilinear(hdri, indices.x, indices.y);\n    \}\n\n\n    /**\n     * Get the value of irradiance the hdri would provide in a direction\n     *\n     * @arg rayDirection: The direction of the ray.\n     *\n     * @returns: The colour of the pixel in the direction of the ray.\n     */\n    inline float4 readIrradianceValue(float3 rayDirection)\n    \{\n        const float2 angles = cartesionUnitVectorToSpherical(rayDirection, __hdriOffsetRadians);\n\n        // Should be able to say image access is eEdgeClamped and not do this\n        // but I see nan pixels sooo... :(\n        const float2 indices = clamp(\n            float2(\n                __irradiancePixelSize.x * angles.x,\n                irradiance.bounds.height() - (__irradiancePixelSize.y * angles.y)\n            ),\n            float2(0),\n            float2(irradiance.bounds.width(), irradiance.bounds.height()) - 1.0f\n        );\n\n        return bilinear(irradiance, indices.x, indices.y);\n    \}\n\n\n    /**\n     * Get the scale of an object.\n     *\n     * @arg objectIndex: The index of the object.\n     *\n     * @returns: The scale of the object.\n     */\n    float getScale(const int objectIndex)\n    \{\n        float scale = 1.0f;\n\n        for (int j=0; j <= objectIndex; j++)\n        \{\n            const float numChildren = shapeProperties(j, 0, 2);\n\n            if (j + numChildren < objectIndex)\n            \{\n                j += numChildren;\n                continue;\n            \}\n\n            scale *= positions(j, 0, 3);\n        \}\n\n        return scale;\n    \}\n\n\n    /**\n     * Get the radius of an object.\n     *\n     * @arg objectIndex: The index of the object.\n     *\n     * @returns: The radius of the object.\n     */\n    float getRadius(const int objectIndex)\n    \{\n        return getScale(objectIndex) * dimensions(objectIndex, 0, 0);\n    \}\n\n\n    /**\n     * Get the local position, from a world position.\n     *\n     * @arg objectIndex: The index of the object whose local coordinate\n     *     system we are using.\n     * @arg worldPosition: The world position.\n     *\n     * @returns: The local position of the worldPosition.\n     */\n    float3 worldToLocal(const int objectIndex, const float3 &worldPosition)\n    \{\n        float3 localPosition = worldPosition;\n        for (int j=0; j <= objectIndex; j++)\n        \{\n            SampleType(shapeProperties) shapeProperty = shapeProperties(j, 0);\n            const float numChildren = shapeProperty.z;\n\n            if (j + numChildren < objectIndex)\n            \{\n                j += numChildren;\n                continue;\n            \}\n\n            // Read in the shape properties\n            const SampleType(positions) position = positions(j, 0);\n            const SampleType(rotations) rotation = rotations(j, 0);\n            const SampleType(dimensions) dimension = dimensions(j, 0);\n            const SampleType(shapeModParameters0) modParameters0 = shapeModParameters0(j, 0);\n            const SampleType(shapeModParameters1) modParameters1 = shapeModParameters1(j, 0);\n\n            // const float scale = position.w;\n            const int modifications = (int) shapeProperty.y;\n\n            // Use parent transform to position child\n            localPosition = transformRay(\n                localPosition,\n                float3(position.x, position.y, position.z),\n                float3(rotation.x, rotation.y, rotation.z),\n                modifications,\n                modParameters0,\n                modParameters1\n            );\n        \}\n\n        return localPosition;\n    \}\n\n\n    /**\n     * Get the world position, from a local position.\n     *\n     * @arg objectIndex: The index of the object whose local coordinate\n     *     system we are using.\n     * @arg localPosition: The local position.\n     *\n     * @returns: The world position of the localPosition.\n     */\n    float3 localToWorld(const int objectIndex, const float3 &localPosition)\n    \{\n        float3 worldPosition = localPosition;\n        for (int j=objectIndex; j >= 0; j--)\n        \{\n            SampleType(shapeProperties) shapeProperty = shapeProperties(j, 0);\n            const float numChildren = shapeProperty.z;\n\n            if (j + numChildren < objectIndex)\n            \{\n                continue;\n            \}\n\n            // Read in the shape properties\n            const SampleType(positions) position = positions(j, 0);\n            const SampleType(rotations) rotation = rotations(j, 0);\n            const SampleType(dimensions) dimension = dimensions(j, 0);\n            const SampleType(shapeModParameters0) modParameters0 = shapeModParameters0(j, 0);\n            const SampleType(shapeModParameters1) modParameters1 = shapeModParameters1(j, 0);\n\n            // const float scale = position.w;\n            const int modifications = (int) shapeProperty.y;\n\n            // Use parent transform to position child\n            worldPosition = inverseTransformRay(\n                worldPosition,\n                float3(position.x, position.y, position.z),\n                float3(rotation.x, rotation.y, rotation.z),\n                modifications,\n                modParameters0,\n                modParameters1\n            );\n        \}\n\n        return worldPosition;\n    \}\n\n\n    /**\n     * Get the world position of an object.\n     *\n     * @arg objectIndex: The index of the object.\n     *\n     * @returns: The world position of the object.\n     */\n    float3 getObjectPosition(const int objectIndex)\n    \{\n        return localToWorld(objectIndex, float3(0));\n    \}\n\n\n    /**\n     * Check whether or not an object is set to interact with its\n     * children in a way that is not union.\n     *\n     * @arg objectIndex: The index of the object to check.\n     *\n     * @returns: True if object's interaction type is not set to union,\n     *     and false otherwise.\n     */\n    inline bool childInteractionIsNotUnion(const int objectIndex)\n    \{\n        return (int(shapeProperties(objectIndex, 0, 1)) & IS_NOT_UNION) > 0;\n    \}\n\n\n    /**\n     * Check whether or not an object is the parent of another.\n     *\n     * @arg parentIndex: The index of the potential parent.\n     * @arg childIndex: The index of the potential child.\n     *\n     * @returns: True if the object is the parent, and false otherwise.\n     */\n    inline bool isParentOf(const int parentIndex, const int childIndex)\n    \{\n        return (\n            parentIndex < childIndex\n            && parentIndex + shapeProperties(parentIndex, 0, 2) >= childIndex\n        );\n    \}\n\n\n    /**\n     * Check whether or not we will be exiting the current material if\n     * we transmit through the surface of an object.\n     *\n     * @arg currentMaterialIndex: The index of the object whose material\n     *     we are currently travelling through.\n     * @arg objectIndex: The index of the object that we have hit.\n     *\n     * @returns: True if we will be exiting, and false otherwise.\n     */\n    bool isExitingObject(const int currentMaterialIndex, const int objectIndex)\n    \{\n        return (\n            currentMaterialIndex >= 0\n            && (\n                currentMaterialIndex == objectIndex\n                || (\n                    isParentOf(objectIndex, currentMaterialIndex)\n                    && childInteractionIsNotUnion(objectIndex)\n                ) || (\n                    isParentOf(currentMaterialIndex, objectIndex)\n                    && childInteractionIsNotUnion(currentMaterialIndex)\n                )\n            )\n        );\n    \}\n\n\n    /**\n     * Compute the minimum distance to an object in the scene.\n     *\n     * @arg rayOrigin: The origin position of the ray.\n     * @arg pixelFootprint: A value proportional to the amount of world\n     *     space that fills a pixel, like the distance from camera.\n     *\n     * @returns: The minimum distance to an object in the scene.\n     */\n    float getMinDistanceToObjectInScene(const float3 &rayOrigin, const float pixelFootprint)\n    \{\n        float distance = _maxRayDistance;\n\n        // numChildren, transformedRay, scale, mods, nextDistance, diffuse colour\n        // roughness, specular colour, specular, transmissive colour, transmission,\n        // emissive colour, emission, refractive index, objectId, blendStrength\n        float parentStack\[MAX_CHILD_DEPTH]\[PARENT_STACK_PARAMS];\n        int parentStackLength = 0;\n\n        for (int j=0; j < _objectTextureWidth; j++)\n        \{\n            // Read in the shape properties\n            SampleType(positions) position = positions(j, 0);\n            SampleType(rotations) rotation = rotations(j, 0);\n            SampleType(dimensions) dimension = dimensions(j, 0);\n            SampleType(shapeProperties) shapeProperty = shapeProperties(j, 0);\n            SampleType(shapeModParameters0) modParameters0 = shapeModParameters0(j, 0);\n            SampleType(shapeModParameters1) modParameters1 = shapeModParameters1(j, 0);\n\n            float scale = position.w;\n\n            const int modifications = (int) shapeProperty.y;\n            float numChildren = shapeProperty.z;\n            const float blendStrength = shapeProperty.w;\n\n            int stackLastIndex = parentStackLength - 1;\n\n            // Position relative to the parent if we have any\n            float3 parentTransformedRay = rayOrigin;\n            if (parentStackLength > 0)\n            \{\n                parentTransformedRay.x = parentStack\[stackLastIndex]\[TRANSFORM_X];\n                parentTransformedRay.y = parentStack\[stackLastIndex]\[TRANSFORM_Y];\n                parentTransformedRay.z = parentStack\[stackLastIndex]\[TRANSFORM_Z];\n                scale *= parentStack\[stackLastIndex]\[SCALE];\n            \}\n\n            // Use parent transform to position child\n            const float3 transformedRay = transformRay(\n                parentTransformedRay,\n                float3(position.x, position.y, position.z),\n                float3(rotation.x, rotation.y, rotation.z),\n                modifications,\n                modParameters0,\n                modParameters1\n            );\n\n            // Get distance to this child\n            float nextDistance = getModifiedDistance(\n                transformedRay,\n                (int) shapeProperty.x,\n                dimension,\n                scale,\n                modifications,\n                modParameters1.w,\n                rotation.w\n            );\n\n            // Track which object was hit for the alpha channel\n            float objectId = (float) j + 1.0f;\n\n            // If this is a bounding volume, we can skip its children\n            // if we aren't close to, or inside it\n            if (\n                modifications & IS_BOUND\n                && numChildren > 0\n                && nextDistance > _hitTolerance + pixelFootprint\n            ) \{\n                // Update the min distance if this bounding volume is closest.\n                // Otherwise we could step through it, or if every object in\n                // the scene is inside it, we would not step forward at all\n                if (fabs(nextDistance) < fabs(distance))\n                \{\n                    distance = nextDistance;\n                \}\n\n                // This was tagged as a boundary object, skip its children\n                // since we arent close to hitting it\n                j += numChildren;\n\n                for (int parentIndex=stackLastIndex; parentIndex >= 0; parentIndex--)\n                \{\n                    parentStack\[parentIndex]\[NUM_CHILDREN] -= numChildren + 1.0f;\n                \}\n\n                // If there are no parents, or still children of the parent\n                // we do not need to compute anything further for this loop\n                if (parentStackLength <= 0 || parentStack\[stackLastIndex]\[NUM_CHILDREN] > 0.0f)\n                \{\n                    continue;\n                \}\n\n                // pop stack\n                // we know that there will be no more children if we did not continue\n                numChildren = 0.0f;\n                nextDistance = parentStack\[stackLastIndex]\[DISTANCE];\n                stackLastIndex--;\n                parentStackLength--;\n            \}\n\n            if (numChildren <= 0.0f)\n            \{\n                // No Children left, compute interactions with parent\n                if (parentStackLength > 0)\n                \{\n                    // Process this object, along with all parents that do not\n                    // have any more children, removing them from the stack,\n                    // but descend all the way down the stack, without removing\n                    // the objects that still have children\n                    for (int stackIndex=stackLastIndex; stackIndex >= 0; stackIndex--)\n                    \{\n                        const int parentModifications = parentStack\[stackIndex]\[MODIFICATIONS];\n\n                        // Do not need to interact with bounding volumes.\n                        // They are in the stack for relative positioning\n                        // if they weren't then we would have to manually move\n                        // the bounding box to follow the children\n                        const float parentBlendStrength = parentStack\[stackIndex]\[BLEND_STRENGTH];\n                        const float parentNextDistance = parentStack\[stackIndex]\[DISTANCE];\n\n                        // Compute interaction between parent and this child\n                        nextDistance = performChildInteraction(\n                            parentModifications,\n                            parentNextDistance,\n                            nextDistance,\n                            parentBlendStrength\n                        );\n\n                        // Update the global min distance (and surface/colour)\n                        if (fabs(nextDistance) < fabs(distance))\n                        \{\n                            distance = nextDistance;\n                        \}\n                    \}\n\n                    do\n                    \{\n                        // Decrement the number of children each parent has\n                        for (int parentIndex=stackLastIndex; parentIndex >= 0; parentIndex--)\n                        \{\n                            parentStack\[parentIndex]\[NUM_CHILDREN] -= 1.0f;\n                        \}\n\n                        // Get the number of children still remaining for the parent\n                        // If there are still children, we can break out of this loop\n                        // to process the rest of them before the parent itself\n                        numChildren = parentStack\[stackLastIndex]\[NUM_CHILDREN];\n                    \}\n                    while (numChildren <= 0.0f && --stackLastIndex >= 0);\n\n                    parentStackLength = stackLastIndex + 1;\n                \}\n                // No parents to interact with, simply check the distance\n                else if (fabs(nextDistance) < fabs(distance))\n                \{\n                    distance = nextDistance;\n                \}\n            \}\n            else\n            \{\n                // Node has Children, push it to the stack for later\n                // processing when we have all its children\n                // parentStack.push()\n                parentStack\[parentStackLength]\[NUM_CHILDREN] = numChildren;\n                parentStack\[parentStackLength]\[TRANSFORM_X] = transformedRay.x;\n                parentStack\[parentStackLength]\[TRANSFORM_Y] = transformedRay.y;\n                parentStack\[parentStackLength]\[TRANSFORM_Z] = transformedRay.z;\n                parentStack\[parentStackLength]\[SCALE] = scale;\n                parentStack\[parentStackLength]\[MODIFICATIONS] = (float) modifications;\n                parentStack\[parentStackLength]\[BLEND_STRENGTH] = blendStrength;\n                parentStack\[parentStackLength]\[DISTANCE] = nextDistance;\n                parentStackLength++;\n            \}\n        \}\n\n        return distance;\n    \}\n\n\n    /**\n     * Compute the minimum distance to an object in the scene.\n     *\n     * @arg rayOrigin: The origin position of the ray.\n     * @arg pixelFootprint: A value proportional to the amount of world\n     *     space that fills a pixel, like the distance from camera.\n     * @arg diffusivity: The diffuse values of the nearest surface.\n     * @arg specularity: The specular values of the nearest surface.\n     * @arg transmittance: The extinction coefficient and transmissive\n     *     probability of the nearest surface.\n     * @arg emittance: The emissive values of the nearest surface.\n     * @arg scatteringCoefficient: The scattering coefficient of the\n     *     nearest material.\n     * @arg specularRoughness: The specular roughness of the surface.\n     * @arg transmissionRoughness: The transmissive roughness of the\n     *     nearest surface.\n     * @arg refractiveIndex: The refractive index of the material.\n     * @arg doRefraction: Whether or not refraction is enabled on the\n     *     nearest material.\n     * @arg id: The ID of the nearest object.\n     *\n     * @returns: The minimum distance to an object in the scene.\n     */\n    float getMinDistanceToObjectInScene(\n            const float3 &rayOrigin,\n            const float pixelFootprint,\n            float4 &diffusivity,\n            float4 &specularity,\n            float4 &transmittance,\n            float4 &emittance,\n            float4 &scatteringCoefficient,\n            float &specularRoughness,\n            float &transmissionRoughness,\n            float &refractiveIndex,\n            bool &doRefraction,\n            int &id)\n    \{\n        float distance = _maxRayDistance;\n        id = 0;\n\n        // numChildren, transformedRay, scale, mods, nextDistance, diffuse colour\n        // roughness, specular colour, specular, transmissive colour, transmission,\n        // emissive colour, emission, refractive index, objectId, blendStrength\n        float parentStack\[MAX_CHILD_DEPTH]\[FULL_PARENT_STACK_PARAMS];\n        int parentStackLength = 0;\n\n        for (int j=0; j < _objectTextureWidth; j++)\n        \{\n            // Read in the shape properties\n            SampleType(positions) position = positions(j, 0);\n            SampleType(rotations) rotation = rotations(j, 0);\n            SampleType(dimensions) dimension = dimensions(j, 0);\n            SampleType(shapeProperties) shapeProperty = shapeProperties(j, 0);\n            SampleType(shapeModParameters0) modParameters0 = shapeModParameters0(j, 0);\n            SampleType(shapeModParameters1) modParameters1 = shapeModParameters1(j, 0);\n            SampleType(diffusivities) diffuseColour = diffusivities(j, 0);\n            SampleType(specularities) specularColour = specularities(j, 0);\n            SampleType(transmittances) transmissiveColour = transmittances(j, 0);\n            SampleType(emittances) emissiveColour = emittances(j, 0);\n            SampleType(scatteringCoefficients) scatteringColour = scatteringCoefficients(j, 0);\n            SampleType(surfaceProperties) surfaceProperty = surfaceProperties(j, 0);\n\n            const int modifications = ((int) shapeProperty.y) | ((int) surfaceProperty.y);\n            float scale = position.w;\n\n            const float blendStrength = shapeProperty.w;\n            float numChildren = shapeProperty.z;\n\n            int stackLastIndex = parentStackLength - 1;\n\n            float4 blendedDiffuseColour = diffuseColour;\n            float4 blendedSpecularColour = specularColour;\n            float4 blendedTransmissiveColour = transmissiveColour;\n            float4 blendedEmissiveColour = emissiveColour;\n            float4 blendedScatteringCoefficient = scatteringColour;\n            float blendedRefractiveIndex = surfaceProperty.x;\n            float blendedTransmissionRoughness = surfaceProperty.z;\n\n            // Position relative to the parent if we have any\n            float3 parentTransformedRay = rayOrigin;\n            if (parentStackLength > 0)\n            \{\n                parentTransformedRay.x = parentStack\[stackLastIndex]\[TRANSFORM_X];\n                parentTransformedRay.y = parentStack\[stackLastIndex]\[TRANSFORM_Y];\n                parentTransformedRay.z = parentStack\[stackLastIndex]\[TRANSFORM_Z];\n                scale *= parentStack\[stackLastIndex]\[SCALE];\n            \}\n\n            // Use parent transform to position child\n            const float3 transformedRay = transformRay(\n                parentTransformedRay,\n                float3(position.x, position.y, position.z),\n                float3(rotation.x, rotation.y, rotation.z),\n                modifications,\n                modParameters0,\n                modParameters1\n            );\n\n            // Get distance to this child\n            float nextDistance = getModifiedDistance(\n                transformedRay,\n                (int) shapeProperty.x,\n                dimension,\n                scale,\n                modifications,\n                modParameters1.w,\n                rotation.w,\n                blendedDiffuseColour,\n                blendedSpecularColour,\n                blendedTransmissiveColour,\n                blendedEmissiveColour,\n                blendedScatteringCoefficient\n            );\n\n            // Track which object was hit for the alpha channel\n            float objectId = (float) j + 1.0f;\n\n            // If this is a bounding volume, we can skip its children\n            // if we aren't close to, or inside it\n            if (\n                modifications & IS_BOUND\n                && numChildren > 0\n                && nextDistance > _hitTolerance + pixelFootprint\n            ) \{\n                // Update the min distance if this bounding volume is closest.\n                // Otherwise we could step through it, or if every object in\n                // the scene is inside it, we would not step forward at all\n                if (fabs(nextDistance) < fabs(distance))\n                \{\n                    distance = nextDistance;\n\n                    diffusivity = blendedDiffuseColour;\n                    specularity = blendedSpecularColour;\n                    transmittance = blendedTransmissiveColour;\n                    emittance = blendedEmissiveColour;\n                    scatteringCoefficient = blendedScatteringCoefficient;\n                    specularRoughness = blendedDiffuseColour.w;\n                    transmissionRoughness = blendedTransmissionRoughness;\n                    refractiveIndex = blendedRefractiveIndex;\n\n                    id = objectId;\n\n                    doRefraction = modifications & 262144;\n                \}\n\n                // This was tagged as a boundary object, skip its children\n                // since we arent close to hitting it\n                j += numChildren;\n\n                for (int parentIndex=stackLastIndex; parentIndex >= 0; parentIndex--)\n                \{\n                    parentStack\[parentIndex]\[NUM_CHILDREN] -= numChildren + 1.0f;\n                \}\n\n                // If there are no parents, or still children of the parent\n                // we do not need to compute anything further for this loop\n                if (parentStackLength <= 0 || parentStack\[stackLastIndex]\[NUM_CHILDREN] > 0.0f)\n                \{\n                    continue;\n                \}\n\n                // pop stack\n                // we know that there will be no more children if we did not continue\n                numChildren = 0.0f;\n                nextDistance = parentStack\[stackLastIndex]\[DISTANCE];\n                blendedDiffuseColour = float4(\n                    parentStack\[stackLastIndex]\[DIFFUSE_COLOUR_R],\n                    parentStack\[stackLastIndex]\[DIFFUSE_COLOUR_G],\n                    parentStack\[stackLastIndex]\[DIFFUSE_COLOUR_B],\n                    parentStack\[stackLastIndex]\[SPECULAR_ROUGHNESS]\n                );\n                blendedSpecularColour = float4(\n                    parentStack\[stackLastIndex]\[SPECULAR_COLOUR_R],\n                    parentStack\[stackLastIndex]\[SPECULAR_COLOUR_G],\n                    parentStack\[stackLastIndex]\[SPECULAR_COLOUR_B],\n                    parentStack\[stackLastIndex]\[SPECULAR]\n                );\n                blendedTransmissiveColour = float4(\n                    parentStack\[stackLastIndex]\[EXTINCTION_R],\n                    parentStack\[stackLastIndex]\[EXTINCTION_G],\n                    parentStack\[stackLastIndex]\[EXTINCTION_B],\n                    parentStack\[stackLastIndex]\[TRANSMISSION]\n                );\n                blendedEmissiveColour = float4(\n                    parentStack\[stackLastIndex]\[EMISSION_R],\n                    parentStack\[stackLastIndex]\[EMISSION_G],\n                    parentStack\[stackLastIndex]\[EMISSION_B],\n                    0\n                );\n                blendedScatteringCoefficient = float4(\n                    parentStack\[stackLastIndex]\[SCATTERING_R],\n                    parentStack\[stackLastIndex]\[SCATTERING_G],\n                    parentStack\[stackLastIndex]\[SCATTERING_B],\n                    0\n                );\n                blendedTransmissionRoughness = parentStack\[stackLastIndex]\[TRANSMISSION_ROUGHNESS];\n                blendedRefractiveIndex = parentStack\[stackLastIndex]\[PARENT_REFRACTIVE_INDEX];\n\n                objectId = parentStack\[stackLastIndex]\[PARENT_OBJECT_ID];\n                stackLastIndex--;\n                parentStackLength--;\n            \}\n\n            if (numChildren <= 0.0f)\n            \{\n                // No Children left, compute interactions with parent\n                if (parentStackLength > 0)\n                \{\n                    // Process this object, along with all parents that do not\n                    // have any more children, removing them from the stack,\n                    // but descend all the way down the stack, without removing\n                    // the objects that still have children\n                    for (int stackIndex=stackLastIndex; stackIndex >= 0; stackIndex--)\n                    \{\n                        const int parentModifications = parentStack\[stackIndex]\[MODIFICATIONS];\n\n                        // Do not need to interact with bounding volumes.\n                        // They are in the stack for relative positioning\n                        // if they weren't then we would have to manually move\n                        // the bounding box to follow the children\n                        const float parentBlendStrength = (\n                            parentStack\[stackIndex]\[BLEND_STRENGTH]\n                        );\n                        const float parentNextDistance = parentStack\[stackIndex]\[DISTANCE];\n                        const float4 parentDiffuseColour = float4(\n                            parentStack\[stackIndex]\[DIFFUSE_COLOUR_R],\n                            parentStack\[stackIndex]\[DIFFUSE_COLOUR_G],\n                            parentStack\[stackIndex]\[DIFFUSE_COLOUR_B],\n                            parentStack\[stackIndex]\[SPECULAR_ROUGHNESS]\n                        );\n                        const float4 parentSpecularColour = float4(\n                            parentStack\[stackIndex]\[SPECULAR_COLOUR_R],\n                            parentStack\[stackIndex]\[SPECULAR_COLOUR_G],\n                            parentStack\[stackIndex]\[SPECULAR_COLOUR_B],\n                            parentStack\[stackIndex]\[SPECULAR]\n                        );\n                        const float4 parentTransmissiveColour = float4(\n                            parentStack\[stackIndex]\[EXTINCTION_R],\n                            parentStack\[stackIndex]\[EXTINCTION_G],\n                            parentStack\[stackIndex]\[EXTINCTION_B],\n                            parentStack\[stackIndex]\[TRANSMISSION]\n                        );\n                        const float4 parentEmissiveColour = float4(\n                            parentStack\[stackIndex]\[EMISSION_R],\n                            parentStack\[stackIndex]\[EMISSION_G],\n                            parentStack\[stackIndex]\[EMISSION_B],\n                            0\n                        );\n                        const float4 parentScatteringCoefficient = float4(\n                            parentStack\[stackIndex]\[SCATTERING_R],\n                            parentStack\[stackIndex]\[SCATTERING_G],\n                            parentStack\[stackIndex]\[SCATTERING_B],\n                            0\n                        );\n                        const float parentTransmissionRoughness = (\n                            parentStack\[stackLastIndex]\[TRANSMISSION_ROUGHNESS]\n                        );\n\n                        const float parentRefractiveIndex = (\n                            parentStack\[stackLastIndex]\[PARENT_REFRACTIVE_INDEX]\n                        );\n\n                        if (fabs(nextDistance) > fabs(parentNextDistance))\n                        \{\n                            objectId = parentStack\[stackIndex]\[PARENT_OBJECT_ID];\n                        \}\n\n                        // Compute interaction between parent and this child\n                        nextDistance = performChildInteraction(\n                            parentModifications,\n                            parentNextDistance,\n                            nextDistance,\n                            parentDiffuseColour,\n                            blendedDiffuseColour,\n                            parentSpecularColour,\n                            blendedSpecularColour,\n                            parentTransmissiveColour,\n                            blendedTransmissiveColour,\n                            parentEmissiveColour,\n                            blendedEmissiveColour,\n                            parentScatteringCoefficient,\n                            blendedScatteringCoefficient,\n                            parentTransmissionRoughness,\n                            blendedTransmissionRoughness,\n                            parentRefractiveIndex,\n                            blendedRefractiveIndex,\n                            parentBlendStrength\n                        );\n\n                        // Update the global min distance (and surface/colour)\n                        if (fabs(nextDistance) < fabs(distance))\n                        \{\n                            distance = nextDistance;\n\n                            diffusivity = blendedDiffuseColour;\n                            specularity = blendedSpecularColour;\n                            transmittance = blendedTransmissiveColour;\n                            emittance = blendedEmissiveColour;\n                            scatteringCoefficient = blendedScatteringCoefficient;\n                            specularRoughness = blendedDiffuseColour.w;\n                            transmissionRoughness = blendedTransmissionRoughness;\n                            refractiveIndex = blendedRefractiveIndex;\n\n                            id = objectId;\n\n                            doRefraction = parentModifications & 262144;\n                        \}\n                    \}\n\n                    do\n                    \{\n                        // Decrement the number of children each parent has\n                        for (int parentIndex=stackLastIndex; parentIndex >= 0; parentIndex--)\n                        \{\n                            parentStack\[parentIndex]\[NUM_CHILDREN] -= 1.0f;\n                        \}\n\n                        // Get the number of children still remaining for the parent\n                        // If there are still children, we can break out of this loop\n                        // to process the rest of them before the parent itself\n                        numChildren = parentStack\[stackLastIndex]\[NUM_CHILDREN];\n                    \}\n                    while (numChildren <= 0.0f && --stackLastIndex >= 0);\n\n                    parentStackLength = stackLastIndex + 1;\n                \}\n                // No parents to interact with, simply check the distance\n                else if (fabs(nextDistance) < fabs(distance))\n                \{\n                    distance = nextDistance;\n\n                    diffusivity = blendedDiffuseColour;\n                    specularity = blendedSpecularColour;\n                    transmittance = blendedTransmissiveColour;\n                    emittance = blendedEmissiveColour;\n                    scatteringCoefficient = blendedScatteringCoefficient;\n                    specularRoughness = blendedDiffuseColour.w;\n                    transmissionRoughness = blendedTransmissionRoughness;\n                    refractiveIndex = blendedRefractiveIndex;\n\n                    id = objectId;\n\n                    doRefraction = modifications & 262144;\n                \}\n            \}\n            else\n            \{\n                // Node has Children, push it to the stack for later\n                // processing when we have all its children\n                // parentStack.push()\n                parentStack\[parentStackLength]\[NUM_CHILDREN] = numChildren;\n                parentStack\[parentStackLength]\[TRANSFORM_X] = transformedRay.x;\n                parentStack\[parentStackLength]\[TRANSFORM_Y] = transformedRay.y;\n                parentStack\[parentStackLength]\[TRANSFORM_Z] = transformedRay.z;\n                parentStack\[parentStackLength]\[SCALE] = scale;\n                parentStack\[parentStackLength]\[MODIFICATIONS] = (float) modifications;\n                parentStack\[parentStackLength]\[BLEND_STRENGTH] = blendStrength;\n                parentStack\[parentStackLength]\[DISTANCE] = nextDistance;\n                parentStack\[parentStackLength]\[DIFFUSE_COLOUR_R] = blendedDiffuseColour.x;\n                parentStack\[parentStackLength]\[DIFFUSE_COLOUR_G] = blendedDiffuseColour.y;\n                parentStack\[parentStackLength]\[DIFFUSE_COLOUR_B] = blendedDiffuseColour.z;\n                parentStack\[parentStackLength]\[SPECULAR_ROUGHNESS] = blendedDiffuseColour.w;\n                parentStack\[parentStackLength]\[SPECULAR_COLOUR_R] = blendedSpecularColour.x;\n                parentStack\[parentStackLength]\[SPECULAR_COLOUR_G] = blendedSpecularColour.y;\n                parentStack\[parentStackLength]\[SPECULAR_COLOUR_B] = blendedSpecularColour.z;\n                parentStack\[parentStackLength]\[SPECULAR] = blendedSpecularColour.w;\n                parentStack\[parentStackLength]\[EXTINCTION_R] = blendedTransmissiveColour.x;\n                parentStack\[parentStackLength]\[EXTINCTION_G] = blendedTransmissiveColour.y;\n                parentStack\[parentStackLength]\[EXTINCTION_B] = blendedTransmissiveColour.z;\n                parentStack\[parentStackLength]\[TRANSMISSION] = blendedTransmissiveColour.w;\n                parentStack\[parentStackLength]\[EMISSION_R] = blendedEmissiveColour.x;\n                parentStack\[parentStackLength]\[EMISSION_G] = blendedEmissiveColour.y;\n                parentStack\[parentStackLength]\[EMISSION_B] = blendedEmissiveColour.z;\n                parentStack\[parentStackLength]\[SCATTERING_R] = blendedScatteringCoefficient.x;\n                parentStack\[parentStackLength]\[SCATTERING_G] = blendedScatteringCoefficient.y;\n                parentStack\[parentStackLength]\[SCATTERING_B] = blendedScatteringCoefficient.z;\n                parentStack\[parentStackLength]\[TRANSMISSION_ROUGHNESS] = blendedTransmissionRoughness;\n                parentStack\[parentStackLength]\[PARENT_REFRACTIVE_INDEX] = blendedRefractiveIndex;\n                parentStack\[parentStackLength]\[PARENT_OBJECT_ID] = objectId;\n                parentStackLength++;\n            \}\n        \}\n\n        diffusivity.w = 1.0f - specularity.w - transmittance.w;\n\n        return distance;\n    \}\n\n\n    /**\n     * Estimate the surface normal at the closest point on the closest\n     * object to a point\n     *\n     * @arg point: The point near which to get the surface normal\n     * @arg pixelFootprint: A value proportional to the amount of world\n     *     space that fills a pixel, like the distance from camera.\n     *\n     * @returns: The normalized surface normal.\n     */\n    float3 estimateSurfaceNormal(const float3 &point, const float pixelFootprint)\n    \{\n        return normalize(\n            __offset0 * getMinDistanceToObjectInScene(\n                point + __offset0 * _hitTolerance,\n                pixelFootprint\n            )\n            + __offset1 * getMinDistanceToObjectInScene(\n                point + __offset1 * _hitTolerance,\n                pixelFootprint\n            )\n            + __offset2 * getMinDistanceToObjectInScene(\n                point + __offset2 * _hitTolerance,\n                pixelFootprint\n            )\n            + __offset3 * getMinDistanceToObjectInScene(\n                point + __offset3 * _hitTolerance,\n                pixelFootprint\n            )\n        );\n    \}\n\n\n    /**\n     * Sample the data of a particular artificial light in the scene.\n     * Artificial lights are any that are passed into the 'lights'\n     * input.\n     *\n     * @arg position: The position on the surface to sample the data of.\n     * @arg lightIndex: The index of the chosen light in the lights\n     *     texture.\n     * @arg numLights: The number of lights in the scene.\n     * @arg lightDirection: The direction from the surface to the light.\n     * @arg distanceToLight: The distance to the light's surface.\n     *\n     * @returns: The PDF of the light.\n     */\n    float sampleArtificialLightData(\n            const float3 &position,\n            const int lightIndex,\n            const int numLights,\n            float3 &lightDirection,\n            float &distanceToLight)\n    \{\n        float visibleSurfaceArea = 1.0f;\n\n        // Selected a 'fake' light eg. point, directional, ambient\n        SampleType(lights) light = lights(lightIndex, 0);\n        const int lightType = abs((int) lightProperties(lightIndex, 0, 3));\n\n        if (lightType > 1)\n        \{\n            getLightData(\n                position,\n                float3(light.x, light.y, light.z),\n                lightType,\n                _maxRayDistance,\n                distanceToLight,\n                visibleSurfaceArea,\n                lightDirection\n            );\n        \}\n\n        return sampleLightsPDF(max(1, numLights), visibleSurfaceArea);\n    \}\n\n\n    /**\n     * Sample the data of a particular physical light in the scene.\n     * Physical lights are any that have an emissive material, rather\n     * than being passed into the 'lights' input with the artificial\n     * lights.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg position: The position on the surface to sample the data of.\n     * @arg objectIndex: The index of the chosen light in the object\n     *     texture.\n     * @arg numLights: The number of lights in the scene.\n     * @arg lightDirection: The direction from the surface to the light.\n     * @arg distanceToLight: The distance to the light's surface.\n     *\n     * @returns: The PDF of the light.\n     */\n    float samplePhysicalLightData(\n            const float3 &seed,\n            const float3 &position,\n            const int objectIndex,\n            const int numLights,\n            float3 &lightDirection,\n            float &distanceToLight)\n    \{\n        float visibleSurfaceArea = 1.0f;\n\n        const float3 objectPosition = getObjectPosition(objectIndex);\n\n        sphericalLightData(\n            seed,\n            position,\n            objectPosition,\n            getRadius(objectIndex),\n            lightDirection,\n            distanceToLight,\n            visibleSurfaceArea\n        );\n\n        if (_maxLightSamplingBounces > 1 && __lightSamplingAngle > 0.0f)\n        \{\n            lightDirection = uniformDirectionInSolidAngle(\n                lightDirection,\n                __lightSamplingAngle,\n                RAND_CONST_0 * seed\n            );\n        \}\n\n        return sampleLightsPDF(max(1, numLights), visibleSurfaceArea);\n    \}\n\n\n    /**\n     * Sample the data of a particular light in the scene.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg position: The position on the surface to sample the data of.\n     * @arg surfaceNormal: The normal to the surface at the position we\n     *     are sampling the data of.\n     * @arg emissiveIndices: The indices of the emissive objects in the\n     *     scene.\n     * @arg numEmissive: The number of emissive objects in the scene.\n     * @arg numLights: The number of lights in the scene.\n     * @arg selectedLight: The index of the chosen light to sample.\n     * @arg lightDirection: The direction from the surface to the light.\n     * @arg distanceToLight: The distance to the light's surface.\n     *\n     * @returns: The PDF of the light.\n     */\n    float sampleLightData(\n            const float3 &seed,\n            const float3 &position,\n            const float3 &surfaceNormal,\n            const int emissiveIndices\[MAX_MIS_EMISSIVE_SHAPES],\n            const int numEmissive,\n            const int numLights,\n            const int selectedLight,\n            float3 &lightDirection,\n            float &distanceToLight)\n    \{\n        float visibleSurfaceArea = 1.0f;\n\n        if (selectedLight < _lightTextureWidth)\n        \{\n            return sampleArtificialLightData(\n                position,\n                selectedLight,\n                numLights,\n                lightDirection,\n                distanceToLight\n            );\n        \}\n        else if (selectedLight - _lightTextureWidth < numEmissive)\n        \{\n            return samplePhysicalLightData(\n                seed,\n                position,\n                emissiveIndices\[selectedLight - _lightTextureWidth],\n                numLights,\n                lightDirection,\n                distanceToLight\n            );\n        \}\n\n        hdriLightData(\n            seed * RAND_CONST_1,\n            surfaceNormal,\n            lightDirection,\n            distanceToLight\n        );\n        return sampleLightsPDF(max(1, numLights), 1.0f);\n    \}\n\n\n    /**\n     * Sample the data of a random light in the scene.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg position: The position on the surface to sample the data of.\n     * @arg surfaceNormal: The normal to the surface at the position we\n     *     are sampling the data of.\n     * @arg emissiveIndices: The indices of the emissive objects in the\n     *     scene.\n     * @arg numEmissive: The number of emissive objects in the scene.\n     * @arg sampleHDRI: Whether or not to sample the HDRI. If there are\n     *     lights in the scene this will increase the noise, but will be\n     *     more accurate.\n     * @arg lightDirection: The direction from the surface to the light.\n     * @arg distanceToLight: The distance to the light's surface.\n     * @arg selectedLight: The index of the chosen light to sample.\n     *\n     * @returns: The PDF of the light.\n     */\n    float sampleRandomLightData(\n            const float3 &seed,\n            const float3 &position,\n            const float3 &surfaceNormal,\n            const int emissiveIndices\[MAX_MIS_EMISSIVE_SHAPES],\n            const int numEmissive,\n            const bool sampleHDRI,\n            float3 &lightDirection,\n            float &distanceToLight,\n            int &selectedLight)\n    \{\n        const float rng = random(random(seed.x + seed.y) + random(seed.z));\n        const int numSamplingOptions = (\n            numEmissive\n            + _lightTextureWidth\n            + sampleHDRI\n        );\n        selectedLight = max(0, (int) floor(rng * (numSamplingOptions - 0.0001f)));\n\n        return sampleLightData(\n            seed,\n            position,\n            surfaceNormal,\n            emissiveIndices,\n            numEmissive,\n            numSamplingOptions,\n            selectedLight,\n            lightDirection,\n            distanceToLight\n        );\n    \}\n\n\n    /**\n     * Compute a soft shadow value.\n     *\n     * @arg rayOrigin: The origin of the ray.\n     * @arg rayDirection: The direction to cast the shadow ray.\n     * @arg distanceToShadePoint: The maximum distance to check for\n     *     a shadow casting object.\n     * @arg softness: The softness of the shadow.\n     *\n     * @returns: The shadow intenstity.\n     */\n    inline float sampleSoftShadow(\n            const float3 &rayOrigin,\n            const float3 &rayDirection,\n            const float distanceToShadePoint,\n            const float softness)\n    \{\n        float distanceTravelled = 0;\n        float shadowIntensity = 1.0f;\n        float lastStepDistance = FLT_MAX;\n\n        int iterations = 0;\n        float pixelFootprint = _hitTolerance;\n\n        float3 position = rayOrigin;\n        while (distanceTravelled < distanceToShadePoint && iterations < _maxRaySteps / 2)\n        \{\n            const float stepDistance = fabs(\n                getMinDistanceToObjectInScene(position, pixelFootprint)\n            );\n            const float stepDistanceSquared = stepDistance * stepDistance;\n            float softOffset = stepDistanceSquared / (2.0f * lastStepDistance);\n            shadowIntensity = min(\n                shadowIntensity,\n                softness * sqrt(stepDistanceSquared - softOffset * softOffset)\n                / max(0.0f, distanceTravelled - softOffset)\n            );\n\n            if (stepDistance < pixelFootprint)\n            \{\n                shadowIntensity = saturate(shadowIntensity);\n                return shadowIntensity * shadowIntensity * (3.0f - 2.0f * shadowIntensity);\n            \}\n\n            lastStepDistance = stepDistance;\n            position += rayDirection * stepDistance;\n            distanceTravelled += stepDistance;\n            pixelFootprint += stepDistance * _hitTolerance;\n            iterations++;\n        \}\n\n        shadowIntensity = saturate(shadowIntensity);\n        return shadowIntensity * shadowIntensity * (3.0f - 2.0f * shadowIntensity);\n    \}\n\n\n    /**\n     * Compute a shadow value.\n     *\n     * @arg rayOrigin: The origin of the ray.\n     * @arg rayDirection: The direction to cast the shadow ray.\n     * @arg distanceToShadePoint: The maximum distance to check for\n     *     a shadow casting object.\n     *\n     * @returns: The shadow intenstity.\n     */\n    float sampleShadow(\n            const float3 &rayOrigin,\n            const float3 &rayDirection,\n            const float distanceToShadePoint)\n    \{\n        float distanceTravelled = 0;\n        int iterations = 0;\n        float pixelFootprint = _hitTolerance;\n        float3 position = rayOrigin;\n\n        while (distanceTravelled < distanceToShadePoint && iterations < _maxRaySteps / 2)\n        \{\n            const float stepDistance = fabs(\n                getMinDistanceToObjectInScene(position, pixelFootprint)\n            );\n\n            if (stepDistance < pixelFootprint)\n            \{\n                return 0;\n            \}\n\n            position += rayDirection * stepDistance;\n            distanceTravelled += stepDistance;\n            pixelFootprint += stepDistance * _hitTolerance;\n            iterations++;\n        \}\n\n        return 1;\n    \}\n\n\n    /**\n     * Compute the ambient occlusion.\n     *\n     * @arg rayOrigin: The origin of the ray.\n     * @arg surfaceNormal: The normal to the surface.\n     * @arg amount: The amount to scale the occlusion value by.\n     * @arg iterations: The number of iterations to refine the\n     *     occlusion.\n     *\n     * @returns: The occlusion value.\n     */\n    inline float sampleAmbientOcclusion(\n            const float3 &rayOrigin,\n            const float3 &surfaceNormal,\n            const float amount,\n            const int iterations)\n    \{\n        float occlusion = 0.0f;\n        float occlusionScaleFactor = 1.0f;\n        for (int iteration=0; iteration < iterations; iteration++)\n        \{\n            const float stepDistance = 0.001f + 0.15f * float(iteration) / 4.0f;\n            const float distanceToClosestObject = fabs(\n                getMinDistanceToObjectInScene(\n                    rayOrigin + stepDistance * surfaceNormal,\n                    _hitTolerance\n                )\n            );\n            occlusion += (stepDistance - distanceToClosestObject) * occlusionScaleFactor;\n            occlusionScaleFactor *= 0.95;\n        \}\n\n        return (\n            amount\n            * saturate(0.5f + 0.5f * surfaceNormal.y)  // ambient\n            * saturate(1.0f - 1.5f * occlusion)       // occlusion\n        );\n    \}\n\n\n    /**\n     * Perform direct illumination light sampling on a chosen artificial\n     * light in the scene.\n     *\n     * @arg pointOnSurface: The point on the surface to compute the\n     *     light intensity at.\n     * @arg surfaceNormal: The normal to the surface at the position we\n     *     are sampling the illumination of.\n     * @arg lightDirection: The direction from the surface to the light.\n     * @arg distanceToLight: The distance to the light's surface.\n     * @arg selectedLight: The index of the chosen light to sample.\n     *\n     * @returns: The colour of the sampled light.\n     */\n    inline float4 sampleArtificialLight(\n            const float3 &pointOnSurface,\n            const float3 &surfaceNormal,\n            const float3 &lightDirection,\n            const float distanceToLight,\n            const int selectedLight)\n    \{\n        // Read the light properties\n        SampleType(lights) light = lights(selectedLight, 0);\n        SampleType(lightProperties) lightProperty = lightProperties(selectedLight, 0);\n        SampleType(lightProperties1) lightProperty1 = lightProperties1(selectedLight, 0);\n\n        float2 intensity;\n\n        int lightType = (int) lightProperty.w;\n        int absLightType = abs(lightType);\n\n        if (absLightType == 0)\n        \{\n            // Ambient light, simply return the intensity.\n            intensity = float2(light.w, 1);\n        \}\n        else if (absLightType == 1)\n        \{\n            intensity = float2(\n                1.0f,\n                sampleAmbientOcclusion(\n                    pointOnSurface,\n                    surfaceNormal,\n                    light.w,\n                    (int) light.x\n                )\n            );\n        \}\n        else\n        \{\n            float intensityAtPosition = lightIntensity(\n                light.w,\n                lightProperty1.y,\n                distanceToLight\n            );\n\n            float shadowIntensityAtPosition;\n            if (lightType < 0)\n            \{\n                shadowIntensityAtPosition = sampleSoftShadow(\n                    pointOnSurface,\n                    lightDirection,\n                    distanceToLight,\n                    lightProperty1.x\n                );\n            \}\n            else\n            \{\n                shadowIntensityAtPosition = sampleShadow(\n                    pointOnSurface,\n                    lightDirection,\n                    distanceToLight\n                );\n            \}\n\n            intensity = float2(intensityAtPosition, shadowIntensityAtPosition);\n        \}\n\n        return intensity.x * intensity.y * float4(\n            lightProperty.x,\n            lightProperty.y,\n            lightProperty.z,\n            0\n        );\n    \}\n\n\n    /**\n     * Perform direct illumination light sampling on every artificial\n     * light in the scene.\n     *\n     * @arg position: The position on the surface to sample the\n     *     illumination of.\n     * @arg surfaceNormal: The surface normal at the intersection point.\n     * @arg throughput: The throughput of the ray.\n     * @arg materialBRDF: The BRDF of the surface at the position we\n     *     are sampling the illumination of.\n     * @arg materialPDF: The PDF of the material we are sampling the\n     *     direct illumination of.\n     *\n     * @returns: The colour of the sampled light.\n     */\n    inline float4 sampleArtificialLights(\n            const float3 &position,\n            const float3 &surfaceNormal,\n            const float4 &throughput,\n            const float4 &materialBRDF,\n            const float materialPDF)\n    \{\n        float4 lightColour = float4(0);\n\n        for (int lightIndex=0; lightIndex < _lightTextureWidth; lightIndex++)\n        \{\n            float3 lightDirection = surfaceNormal;\n            float distanceToLight = 0.0f;\n\n            const float lightPDF = sampleArtificialLightData(\n                position,\n                lightIndex,\n                _lightTextureWidth,\n                lightDirection,\n                distanceToLight\n            );\n\n            float geometryFactor = saturate(dot(lightDirection, surfaceNormal));\n\n            lightColour += multipleImportanceSample(\n                sampleArtificialLight(\n                    position,\n                    surfaceNormal,\n                    lightDirection,\n                    distanceToLight,\n                    lightIndex\n                ),\n                throughput * materialBRDF * geometryFactor / lightPDF,\n                lightPDF,\n                materialPDF * geometryFactor\n            );\n        \}\n\n        return lightColour;\n    \}\n\n\n    /**\n     * Handle the interaction between a ray and the surface of a material.\n     *\n     * @arg pixelFootprint: A value proportional to the amount of world\n     *     space that fills a pixel, like the distance from camera.\n     * @arg distance: The distance travelled since the last bounce.\n     * @arg intersectionPosition: The position at which the ray\n     *     intersects the geometry.\n     * @arg surfaceNormal: The surface normal at the intersection point.\n     * @arg objectId: The ID of the object that was hit.\n     * @arg doRefraction: Whether or not refraction is enabled on the\n     *     material.\n     * @arg numLights: The number of lights in the scene.\n     * @arg seed: The seed to use in randomization.\n     * @arg direction: The incoming ray direction.\n     * @arg origin: The ray origin.\n     * @arg diffusivity: The diffuse values of the surface.\n     * @arg specularity: The specular values of the surface.\n     * @arg transmittance: The extinction coefficient and transmissive\n     *     probability of the surface.\n     * @arg emittance: The emissive values of the surface.\n     * @arg specularRoughness: The specular roughness of the surface.\n     * @arg transmissionRoughness: The transmissive roughness of the\n     *     surface.\n     * @arg refractiveIndex: The refractive index of the material.\n     * @arg scatteringCoefficient: The scattering coefficient of the\n     *     material.\n     * @arg nestedDielectrics: The stack of dielectrics that we have\n     *     entered without exiting.\n     * @arg numNestedDielectrics: The number of dielectrics in the\n     *     stack.\n     * @arg rayColour: The colour of the ray.\n     * @arg throughput: The throughput of the ray.\n     * @arg previousMaterialPDF: The PDF of the last material interacted\n     *     with.\n     */\n    void materialInteraction(\n            const float pixelFootprint,\n            const float distance,\n            const float3 &intersectionPosition,\n            const float3 &surfaceNormal,\n            const int objectId,\n            const bool doRefraction,\n            const float numLights,\n            float3 &seed,\n            float3 &direction,\n            float3 &origin,\n            float4 &diffusivity,\n            float4 &specularity,\n            float4 &transmittance,\n            float4 &emittance,\n            float &specularRoughness,\n            float &transmissionRoughness,\n            float &refractiveIndex,\n            float4 &scatteringCoefficient,\n            float nestedDielectrics\[MAX_NESTED_DIELECTRICS]\[NESTED_DIELECTRIC_PARAMS],\n            int &numNestedDielectrics,\n            float4 &rayColour,\n            float4 &throughput,\n            float &previousMaterialPDF)\n    \{\n        // Use the noise to modify the surface properties\n        noiseMaterialInteraction(\n            objectId - 1,\n            intersectionPosition,\n            diffusivity,\n            specularity,\n            transmittance,\n            emittance,\n            specularRoughness,\n            transmissionRoughness,\n            refractiveIndex\n        );\n\n        // Compute the amount we would offset a point to escape the surface\n        const float offset = 2.0f * pixelFootprint * _shadowBias;\n\n        const float4 extinctionCoefficient = getExtinctionCoefficient(\n            nestedDielectrics,\n            numNestedDielectrics\n        );\n        throughput *= exp(-distance * extinctionCoefficient);\n\n        origin = intersectionPosition;\n\n        // Get material data for material and light sampling\n        float4 materialBRDF;\n        float3 bounceDirection;\n        float materialLightPDF;\n        const float materialPDF = sampleMaterial(\n            seed,\n            surfaceNormal,\n            direction,\n            diffusivity,\n            offset,\n            transmittance,\n            doRefraction,\n            refractiveIndex,\n            scatteringCoefficient,\n            transmissionRoughness,\n            specularity,\n            specularRoughness,\n            objectId,\n            isExitingObject(\n                nestedDielectrics\[numNestedDielectrics]\[OBJECT_ID] - 1,\n                objectId - 1\n            ),\n            materialBRDF,\n            bounceDirection,\n            origin,\n            nestedDielectrics,\n            numNestedDielectrics,\n            materialLightPDF\n        );\n\n        if (\n            __lightSamplingEnabled\n            && _doSecondaryLightSampling\n            && materialLightPDF > 0.0f\n            && _lightTextureWidth > 0\n        ) \{\n            const float3 offsetPosition = offsetPoint(\n                origin,\n                surfaceNormal,\n                offset\n            );\n            // Perform MIS light sampling\n            rayColour += sampleArtificialLights(\n                offsetPosition,\n                surfaceNormal,\n                throughput,\n                materialBRDF,\n                materialLightPDF\n            );\n        \}\n\n        const float radius = getRadius(objectId - 1);\n        const float visibleSurfaceArea = 2.0f * PI * radius * radius;\n\n        rayColour += multipleImportanceSample(\n            emittance,\n            throughput,\n            previousMaterialPDF,\n            sampleLightsPDF(numLights, visibleSurfaceArea)\n        );\n\n        throughput *= materialBRDF / materialPDF;\n\n        // Prepare the variables for the next march\n        previousMaterialPDF = materialPDF;\n\n        direction = bounceDirection;\n    \}\n\n\n    /**\n     * March a path through the scene, with only MIS material and\n     * artifical light sampling.\n     *\n     * @arg rayOrigin: The origin of the ray.\n     * @arg rayDirection: The direction of the ray.\n     * @arg initialSeed: The seed to use in randomization.\n     * @arg sampleHDRI: Whether or not to sample the HDRI. If there are\n     *     lights in the scene this will increase the noise, but will be\n     *     more accurate.\n     * @arg maxRayDistance: The maximum distance the ray can travel.\n     * @arg currentNestedDielectrics: The stack of dielectrics that we\n     *     have entered without exiting.\n     * @arg currentNumNestedDielectrics: The number of dielectrics in\n     *     the stack.\n     * @arg numEmissive: The number of emissive objects in the scene.\n     * @arg distanceTravelled: Location to store the distance the ray\n     *     actually travels.\n     *\n     * @returns: The ray colour.\n     */\n    inline float4 marchPath(\n            const float3 &rayOrigin,\n            const float3 &rayDirection,\n            const float3 &initialSeed,\n            const bool sampleHDRI,\n            const float maxRayDistance,\n            const float currentNestedDielectrics\[MAX_NESTED_DIELECTRICS]\[NESTED_DIELECTRIC_PARAMS],\n            const int currentNumNestedDielectrics,\n            const int numEmissive,\n            float &distanceTravelled)\n    \{\n        const int numLights = _lightTextureWidth + numEmissive + sampleHDRI;\n\n        float nestedDielectrics\[MAX_NESTED_DIELECTRICS]\[NESTED_DIELECTRIC_PARAMS];\n        for (int nestedIndex=0; nestedIndex <= currentNumNestedDielectrics; nestedIndex++)\n        \{\n            for (int dataIndex=0; dataIndex < NESTED_DIELECTRIC_PARAMS; dataIndex++)\n            \{\n                nestedDielectrics\[nestedIndex]\[dataIndex] = (\n                    currentNestedDielectrics\[nestedIndex]\[dataIndex]\n                );\n            \}\n        \}\n        int numNestedDielectrics = currentNumNestedDielectrics;\n\n        float4 rayColour = float4(0);\n        float4 throughput = float4(1);\n\n        float lastStepDistance = 1.0f;\n\n        float firstObjectId = 0.0f;\n\n        int iterations = 0;\n        int bounces = 0;\n\n        distanceTravelled = 0;\n        float distanceSinceLastBounce = distanceTravelled;\n\n        // Get the next ray\n        float3 origin = rayOrigin;\n        float3 direction = rayDirection;\n        float3 positionOnRay = origin;\n\n        float4 diffusivity;\n        float4 specularity;\n        float4 transmittance;\n        float4 emittance;\n\n        float pixelFootprint = _hitTolerance;\n\n        float previousMaterialPDF = 1.0f;\n\n        float3 seed = initialSeed;\n\n        // March the ray\n        while (\n            distanceTravelled < maxRayDistance\n            && iterations < _maxRaySteps\n            && sumComponent(throughput) > _hitTolerance\n        ) \{\n            positionOnRay = origin + distanceSinceLastBounce * direction;\n\n            // Get the closest distance to an object\n            bool doRefraction = true;\n            float4 scatteringCoefficient = float4(0);\n            float specularRoughness = 0.0f;\n            float transmissionRoughness = 0.0f;\n            float refractiveIndex = 1.0f;\n            int objectId = 0;\n\n            const float signedStepDistance = getMinDistanceToObjectInScene(\n                positionOnRay,\n                pixelFootprint,\n                diffusivity,\n                specularity,\n                transmittance,\n                emittance,\n                scatteringCoefficient,\n                specularRoughness,\n                transmissionRoughness,\n                refractiveIndex,\n                doRefraction,\n                objectId\n            );\n\n            // Get the absolute value, the true shortest distance to a\n            // surface\n            const float stepDistance = fabs(signedStepDistance);\n\n            // Keep track of the distance the ray has travelled\n            distanceTravelled += stepDistance;\n            distanceSinceLastBounce += stepDistance;\n\n            // Have we hit the nearest object?\n            if (stepDistance < pixelFootprint)\n            \{\n                float3 intersectionPosition = positionOnRay + stepDistance * direction;\n\n                // The normal to the surface at that position\n                float3 surfaceNormal = sign(lastStepDistance) * estimateSurfaceNormal(\n                    intersectionPosition,\n                    pixelFootprint\n                );\n\n                materialInteraction(\n                    pixelFootprint,\n                    distanceSinceLastBounce,\n                    intersectionPosition,\n                    surfaceNormal,\n                    objectId,\n                    doRefraction,\n                    numLights,\n                    seed,\n                    direction,\n                    origin,\n                    diffusivity,\n                    specularity,\n                    transmittance,\n                    emittance,\n                    specularRoughness,\n                    transmissionRoughness,\n                    refractiveIndex,\n                    scatteringCoefficient,\n                    nestedDielectrics,\n                    numNestedDielectrics,\n                    rayColour,\n                    throughput,\n                    previousMaterialPDF\n                );\n\n                // Exit if we have reached the bounce limit\n                // or with a random chance\n                const float rng = random(random(seed.x) + random(seed.y + random(seed.z)));\n                const float exitProbability = max(\n                    throughput.x,\n                    throughput.y,\n                    throughput.z\n                );\n                if (\n                    ++bounces > _maxLightSamplingBounces\n                    || emittance.w > 0.0f\n                    || (_roulette && exitProbability <= rng)\n                ) \{\n                    return rayColour;\n                \}\n                if (_roulette)\n                \{\n                    // Account for the lost intensity from the early exits\n                    throughput /= exitProbability;\n                \}\n\n                // Update the random seed\n                seed = RAND_CONST_8 * random(\n                    seed\n                    + rng\n                    + random(fabs(intersectionPosition + direction))\n                );\n\n                // Reset the pixel footprint so multiple reflections don't\n                // reduce precision\n                pixelFootprint = _hitTolerance;\n            \}\n            else if (_levelOfDetail)\n            \{\n                pixelFootprint += _hitTolerance * stepDistance;\n            \}\n\n            lastStepDistance = signedStepDistance;\n            iterations++;\n        \}\n\n        distanceTravelled = (\n            distanceSinceLastBounce\n            + _maxRayDistance\n            - distanceTravelled\n        );\n\n        // Read the hdri value in the direction the ray was last travelling\n        // and absorb an amount of light proportional to the distance travelled\n        // through the last material\n        rayColour += (\n            throughput\n            * readHDRIValue(direction)\n            * getScatteringCoefficient(\n                nestedDielectrics,\n                numNestedDielectrics\n            ) * exp(\n                -distanceTravelled\n                * getExtinctionCoefficient(\n                    nestedDielectrics,\n                    numNestedDielectrics\n                )\n            )\n        );\n\n        return rayColour;\n    \}\n\n\n    /**\n     * Perform direct illumination light sampling on a chosen light in\n     * the scene.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg throughput: The throughput of the ray.\n     * @arg materialBRDF: The BRDF of the surface at the position we\n     *     are sampling the illumination of.\n     * @arg distanceToLight: The distance to the light's surface.\n     * @arg surfaceNormal: The normal to the surface at the position we\n     *     are sampling the illumination of.\n     * @arg position: The position on the surface to sample the\n     *     illumination of.\n     * @arg lightDirection: The direction from the surface to the light.\n     * @arg lightPDF: The PDF of the light we are sampling the\n     *     direct illumination of.\n     * @arg materialPDF: The PDF of the material we are sampling the\n     *     direct illumination of.\n     * @arg selectedLight: The index of the chosen light to sample.\n     * @arg numEmissive: The number of emissive objects in the scene.\n     * @arg sampleHDRI: Whether or not to sample the HDRI. If there are\n     *     lights in the scene this will increase the noise, but will be\n     *     more accurate.\n     * @arg nestedDielectrics: The stack of dielectrics that we have\n     *     entered without exiting.\n     * @arg numNestedDielectrics: The number of dielectrics in the\n     *     stack.\n     *\n     * @returns: The colour of the sampled light.\n     */\n    float4 sampleLight(\n            const float3 &seed,\n            const float4 &throughput,\n            const float4 &materialBRDF,\n            const float distanceToLight,\n            const float3 &surfaceNormal,\n            const float3 &position,\n            const float3 &lightDirection,\n            const float lightPDF,\n            const float materialPDF,\n            const int selectedLight,\n            const int numEmissive,\n            const bool sampleHDRI,\n            const float nestedDielectrics\[MAX_NESTED_DIELECTRICS]\[NESTED_DIELECTRIC_PARAMS],\n            const int numNestedDielectrics)\n    \{\n        float4 lightColour = float4(0);\n        float lightGeometryFactor;\n\n        if (selectedLight < _lightTextureWidth)\n        \{\n            lightColour = sampleArtificialLight(\n                position,\n                surfaceNormal,\n                lightDirection,\n                distanceToLight,\n                selectedLight\n            );\n            lightGeometryFactor = saturate(dot(lightDirection, surfaceNormal));\n        \}\n        else if (selectedLight - _lightTextureWidth - sampleHDRI < numEmissive)\n        \{\n            float actualDistance;\n            lightColour = marchPath(\n                position,\n                lightDirection,\n                seed,\n                sampleHDRI,\n                distanceToLight * 2.0f,\n                nestedDielectrics,\n                numNestedDielectrics,\n                numEmissive,\n                actualDistance\n            );\n            lightGeometryFactor = geometryFactor(\n                lightDirection,\n                surfaceNormal,\n                actualDistance\n            );\n        \}\n\n        return multipleImportanceSample(\n            lightColour,\n            throughput * materialBRDF * lightGeometryFactor / lightPDF,\n            lightPDF,\n            materialPDF * lightGeometryFactor\n        );\n    \}\n\n\n\n    /**\n     * Perform direct illumination light sampling on a random light in\n     * the scene.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg throughput: The throughput of the ray.\n     * @arg materialBRDF: The BRDF of the surface at the position we\n     *     are sampling the illumination of.\n     * @arg surfaceNormal: The normal to the surface at the position we\n     *     are sampling the illumination of.\n     * @arg position: The position on the surface to sample the\n     *     illumination of.\n     * @arg materialPDF: The PDF of the material we are sampling the\n     *     direct illumination of.\n     * @arg emissiveIndices: The indices of the emissive objects in the\n     *     scene.\n     * @arg numEmissive: The number of emissive objects in the scene.\n     * @arg sampleHDRI: Whether or not to sample the HDRI. If there are\n     *     lights in the scene this will increase the noise, but will be\n     *     more accurate.\n     * @arg nestedDielectrics: The stack of dielectrics that we have\n     *     entered without exiting.\n     * @arg numNestedDielectrics: The number of dielectrics in the\n     *     stack.\n     *\n     * @returns: The colour of the sampled light.\n     */\n    inline float4 sampleRandomLight(\n            const float3 &seed,\n            const float4 &throughput,\n            const float4 &materialBRDF,\n            const float3 &surfaceNormal,\n            const float3 &position,\n            const float materialPDF,\n            const int emissiveIndices\[MAX_MIS_EMISSIVE_SHAPES],\n            const int numEmissive,\n            const bool sampleHDRI,\n            const float nestedDielectrics\[MAX_NESTED_DIELECTRICS]\[NESTED_DIELECTRIC_PARAMS],\n            const int numNestedDielectrics)\n    \{\n        float3 lightDirection = surfaceNormal;\n        float distanceToLight = 0.0f;\n        int selectedLight;\n\n        // Get data for light sampling\n        float lightPDF = sampleRandomLightData(\n            seed,\n            position,\n            surfaceNormal,\n            emissiveIndices,\n            numEmissive,\n            sampleHDRI,\n            lightDirection,\n            distanceToLight,\n            selectedLight\n        );\n\n        // Perform MIS light sampling\n        return sampleLight(\n            seed * RAND_CONST_2,\n            throughput,\n            materialBRDF,\n            distanceToLight,\n            surfaceNormal,\n            position,\n            lightDirection,\n            lightPDF,\n            materialPDF,\n            selectedLight,\n            numEmissive,\n            sampleHDRI,\n            nestedDielectrics,\n            numNestedDielectrics\n        );\n    \}\n\n\n    /**\n     * Perform direct illumination light sampling on every light in the\n     * scene.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg throughput: The throughput of the ray.\n     * @arg materialBRDF: The BRDF of the surface at the position we\n     *     are sampling the illumination of.\n     * @arg surfaceNormal: The normal to the surface at the position we\n     *     are sampling the illumination of.\n     * @arg position: The position on the surface to sample the\n     *     illumination of.\n     * @arg materialPDF: The PDF of the material we are sampling the\n     *     direct illumination of.\n     * @arg emissiveIndices: The indices of the emissive objects in the\n     *     scene.\n     * @arg numEmissive: The number of emissive objects in the scene.\n     * @arg sampleHDRI: Whether or not to sample the HDRI. If there are\n     *     lights in the scene this will increase the noise, but will be\n     *     more accurate.\n     * @arg nestedDielectrics: The stack of dielectrics that we have\n     *     entered without exiting.\n     * @arg numNestedDielectrics: The number of dielectrics in the\n     *     stack.\n     *\n     * @returns: The colour of the sampled light.\n     */\n    inline float4 sampleLights(\n            const float3 &seed,\n            const float4 &throughput,\n            const float4 &materialBRDF,\n            const float3 &surfaceNormal,\n            const float3 &position,\n            const float materialPDF,\n            const int emissiveIndices\[MAX_MIS_EMISSIVE_SHAPES],\n            const int numEmissive,\n            const bool sampleHDRI,\n            const float nestedDielectrics\[MAX_NESTED_DIELECTRICS]\[NESTED_DIELECTRIC_PARAMS],\n            const int numNestedDielectrics)\n    \{\n        float4 lightColour = float4(0);\n        const int numLights = numEmissive + _lightTextureWidth + sampleHDRI;\n\n        for (int path=0; path < numLights; path++)\n        \{\n            float3 lightDirection = surfaceNormal;\n            float distanceToLight = 0.0f;\n\n            const float lightPDF = sampleLightData(\n                seed * RAND_CONST_3 / (path + 1),\n                position,\n                surfaceNormal,\n                emissiveIndices,\n                numEmissive,\n                numLights,\n                path,\n                lightDirection,\n                distanceToLight\n            );\n\n            lightColour += sampleLight(\n                seed * RAND_CONST_4 * (path + 1),\n                throughput,\n                materialBRDF,\n                distanceToLight,\n                surfaceNormal,\n                position,\n                lightDirection,\n                lightPDF,\n                materialPDF,\n                path,\n                numEmissive,\n                sampleHDRI,\n                nestedDielectrics,\n                numNestedDielectrics\n            );\n        \}\n\n        return lightColour;\n    \}\n\n\n    /**\n     * Perform direct illumination light sampling.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg throughput: The throughput of the ray.\n     * @arg materialBRDF: The BRDF of the surface at the position we\n     *     are sampling the illumination of.\n     * @arg surfaceNormal: The normal to the surface at the position we\n     *     are sampling the illumination of.\n     * @arg position: The position on the surface to sample the\n     *     illumination of.\n     * @arg materialPDF: The PDF of the material we are sampling the\n     *     direct illumination of.\n     * @arg offset: The amount to offset the ray in order to escape the\n     *     surface.\n     * @arg emissiveIndices: The indices of the emissive objects in the\n     *     scene.\n     * @arg numEmissive: The number of emissive objects in the scene.\n     * @arg sampleHDRI: Whether or not to sample the HDRI. If there are\n     *     lights in the scene this will increase the noise, but will be\n     *     more accurate.\n     * @arg nestedDielectrics: The stack of dielectrics that we have\n     *     entered without exiting.\n     * @arg numNestedDielectrics: The number of dielectrics in the\n     *     stack.\n     *\n     * @returns: The colour of the sampled light.\n     */\n    inline float4 lightSampling(\n            const float3 &seed,\n            const float4 &throughput,\n            const float4 &materialBRDF,\n            const float3 &surfaceNormal,\n            const float3 &position,\n            const float materialPDF,\n            const float offset,\n            const int emissiveIndices\[MAX_MIS_EMISSIVE_SHAPES],\n            const int numEmissive,\n            const bool sampleHDRI,\n            const float nestedDielectrics\[MAX_NESTED_DIELECTRICS]\[NESTED_DIELECTRIC_PARAMS],\n            const int numNestedDielectrics)\n    \{\n        const float3 offsetPosition = offsetPoint(\n            position,\n            surfaceNormal,\n            offset\n        );\n        if (_sampleAllLights)\n        \{\n            return sampleLights(\n                seed,\n                throughput,\n                materialBRDF,\n                surfaceNormal,\n                offsetPosition,\n                materialPDF,\n                emissiveIndices,\n                numEmissive,\n                sampleHDRI,\n                nestedDielectrics,\n                numNestedDielectrics\n            );\n        \}\n        return sampleRandomLight(\n            seed,\n            throughput,\n            materialBRDF,\n            surfaceNormal,\n            offsetPosition,\n            materialPDF,\n            emissiveIndices,\n            numEmissive,\n            sampleHDRI,\n            nestedDielectrics,\n            numNestedDielectrics\n        );\n    \}\n\n\n    /**\n     * Perform equi-angular sampling for participating media.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg intersectionPosition: The position at which the ray\n     *     intersects the geometry.\n     * @arg rayOrigin: The ray origin.\n     * @arg rayDirection: The incoming ray direction.\n     * @arg distanceSinceLastBounce: The distance travelled since the\n     *     last bounce.\n     * @arg emissiveIndices: The indices of the emissive objects in the\n     *     scene.\n     * @arg numEmissive: The number of emissive objects in the scene.\n     * @arg nestedDielectrics: The stack of dielectrics that we have\n     *     entered without exiting.\n     * @arg numNestedDielectrics: The number of dielectrics in the\n     *     stack.\n     * @arg throughput: The throughput of the ray.\n     *\n     * @returns: The colour of the ray.\n     */\n    float4 sampleEquiangular(\n            const float3 &seed,\n            const float3 &intersectionPosition,\n            const float3 &rayOrigin,\n            const float3 &rayDirection,\n            const float distanceSinceLastBounce,\n            const int emissiveIndices\[MAX_MIS_EMISSIVE_SHAPES],\n            const int numEmissive,\n            const float nestedDielectrics\[MAX_NESTED_DIELECTRICS]\[NESTED_DIELECTRIC_PARAMS],\n            const int numNestedDielectrics,\n            float4 &throughput)\n    \{\n        // Get the scattering coefficient of the material we are in\n        const float4 scatteringCoefficient = getScatteringCoefficient(\n            nestedDielectrics,\n            numNestedDielectrics\n        );\n        const float4 extinctionCoefficient = getExtinctionCoefficient(\n            nestedDielectrics,\n            numNestedDielectrics\n        );\n        float4 scatteredColour = float4(0);\n\n        if (\n            !__equiangularSamplingEnabled\n            || (\n                length(scatteringCoefficient) <= 0.0f\n                && length(extinctionCoefficient) <= 0.0f\n            )\n        ) \{\n            throughput *= exp(-extinctionCoefficient * distanceSinceLastBounce);\n            return scatteredColour;\n        \}\n\n        int objectIndex = nestedDielectrics\[numNestedDielectrics]\[OBJECT_ID] - 1;\n        if (objectIndex < 0)\n        \{\n            // blink cannot handle single pixel images in versions < 12.1\n            // so we have a weird dummy pixel when only one object is passed\n            // to the scene\n            objectIndex = _objectTextureWidth == 0 ? 1 : _objectTextureWidth;\n        \}\n\n        const float offset = random(random(seed.z) + random(seed.y + random(seed.x)));\n\n        float extinctionNoiseSum = 0.0f;\n\n        for (int step=1; step <= _equiangularSamples; step++)\n        \{\n            const float uniform = (step + offset - 1) / (float) _equiangularSamples;\n\n            float3 surfaceNormal = randomUnitVector(seed * RAND_CONST_5);\n            float3 lightDirection = surfaceNormal;\n            float distanceToLight = 0.0f;\n            int selectedLight;\n\n            const float lightPDF = sampleRandomLightData(\n                seed * RAND_CONST_6 * step,\n                intersectionPosition,\n                surfaceNormal,\n                emissiveIndices,\n                numEmissive,\n                _sampleHDRIEquiangular,\n                lightDirection,\n                distanceToLight,\n                selectedLight\n            );\n            const float3 lightPosition = intersectionPosition + lightDirection * distanceToLight;\n\n            float equiangularDistance;\n            float equiangularPDF = _equiangularSamples * sampleEquiangularPDF(\n                uniform,\n                distanceSinceLastBounce,\n                rayOrigin,\n                rayDirection,\n                lightPosition,\n                equiangularDistance\n            );\n\n            const float3 particlePosition = rayOrigin + equiangularDistance * rayDirection;\n            const float3 particleToLight = lightPosition - particlePosition;\n            distanceToLight = length(particleToLight);\n\n            if (distanceToLight > 0.0f)\n            \{\n                lightDirection = normalize(particleToLight);\n            \}\n\n            int noiseOptions;\n            float noiseValue = getNoiseValue(\n                objectIndex,\n                particlePosition,\n                noiseOptions\n            );\n            float scatteringNoise = noiseValue;\n            float extinctionNoise = noiseValue;\n            if (noiseValue < 0.0f || !(noiseOptions & SCATTERING_NOISE))\n            \{\n                scatteringNoise = 1.0f;\n            \}\n            if (noiseValue < 0.0f || !(noiseOptions & EXTINCTION_NOISE))\n            \{\n                extinctionNoise = 1.0f;\n            \}\n\n            extinctionNoiseSum += extinctionNoise;\n\n            const float4 lightBRDF = exp(\n                -extinctionCoefficient\n                * extinctionNoise\n                * (distanceToLight + equiangularDistance)\n            );\n\n            scatteredColour += scatteringCoefficient * scatteringNoise * sampleLight(\n                seed * RAND_CONST_7 / step,\n                throughput,\n                lightBRDF,\n                distanceToLight,\n                lightDirection,\n                particlePosition,\n                lightDirection,\n                equiangularPDF,\n                lightPDF,\n                selectedLight,\n                numEmissive,\n                _sampleHDRIEquiangular,\n                nestedDielectrics,\n                numNestedDielectrics\n            );\n        \}\n\n        throughput *= exp(\n            -extinctionCoefficient\n            * extinctionNoiseSum\n            * distanceSinceLastBounce\n            / (float) _equiangularSamples\n        );\n\n        return scatteredColour;\n    \}\n\n\n    /**\n     * Handle the interaction between a ray and the surface of a material.\n     *\n     * @arg stepDistance: The last step size to be marched.\n     * @arg pixelFootprint: A value proportional to the amount of world\n     *     space that fills a pixel, like the distance from camera.\n     * @arg distance: The distance travelled since the last bounce.\n     * @arg intersectionPosition: The position at which the ray\n     *     intersects the geometry.\n     * @arg surfaceNormal: The surface normal at the intersection point.\n     * @arg objectId: The ID of the object that was hit.\n     * @arg emissiveIndices: The indices of the emissive objects in the\n     *     scene.\n     * @arg numEmissive: The number of emissive objects in the scene.\n     * @arg doRefraction: Whether or not refraction is enabled on the\n     *     material.\n     * @arg numLights: The number of lights in the scene.\n     * @arg seed: The seed to use in randomization.\n     * @arg direction: The incoming ray direction.\n     * @arg origin: The ray origin.\n     * @arg diffusivity: The diffuse values of the surface.\n     * @arg specularity: The specular values of the surface.\n     * @arg transmittance: The extinction coefficient and transmissive\n     *     probability of the surface.\n     * @arg emittance: The emissive values of the surface.\n     * @arg specularRoughness: The specular roughness of the surface.\n     * @arg transmissionRoughness: The transmissive roughness of the\n     *     surface.\n     * @arg refractiveIndex: The refractive index of the material.\n     * @arg scatteringCoefficient: The scattering coefficient of the\n     *     material.\n     * @arg nestedDielectrics: The stack of dielectrics that we have\n     *     entered without exiting.\n     * @arg numNestedDielectrics: The number of dielectrics in the\n     *     stack.\n     * @arg rayColour: The colour of the ray.\n     * @arg throughput: The throughput of the ray.\n     * @arg previousMaterialPDF: The PDF of the last material interacted\n     *     with.\n     * @arg usedPrecomputedIrradiance: Whether or not we have used the\n     *     precomputed irradiance.\n     */\n    void materialInteraction(\n            const float stepDistance,\n            const float pixelFootprint,\n            const float distance,\n            const float3 &intersectionPosition,\n            const float3 &surfaceNormal,\n            const int objectId,\n            const int emissiveIndices\[MAX_MIS_EMISSIVE_SHAPES],\n            const int numEmissive,\n            const bool doRefraction,\n            const float numLights,\n            float3 &seed,\n            float3 &direction,\n            float3 &origin,\n            float4 &diffusivity,\n            float4 &specularity,\n            float4 &transmittance,\n            float4 &emittance,\n            float &specularRoughness,\n            float &transmissionRoughness,\n            float &refractiveIndex,\n            float4 &scatteringCoefficient,\n            float nestedDielectrics\[MAX_NESTED_DIELECTRICS]\[NESTED_DIELECTRIC_PARAMS],\n            int &numNestedDielectrics,\n            float4 &rayColour,\n            float4 &throughput,\n            float &previousMaterialPDF,\n            bool &usedPrecomputedIrradiance)\n    \{\n        // Use the noise to modify the surface properties\n        noiseMaterialInteraction(\n            objectId - 1,\n            intersectionPosition,\n            diffusivity,\n            specularity,\n            transmittance,\n            emittance,\n            specularRoughness,\n            transmissionRoughness,\n            refractiveIndex\n        );\n\n        // Compute the amount we would offset a point to escape the surface\n        const float offset = 2.0f * pixelFootprint * _shadowBias;\n\n        // Perform Equi-Angular Sampling\n        rayColour += sampleEquiangular(\n            seed,\n            intersectionPosition,\n            origin,\n            direction,\n            distance,\n            emissiveIndices,\n            numEmissive,\n            nestedDielectrics,\n            numNestedDielectrics,\n            throughput\n        );\n\n        origin = intersectionPosition;\n\n        // Get material data for material and light sampling\n        float4 materialBRDF;\n        float3 bounceDirection;\n        float materialLightPDF;\n        const float materialPDF = sampleMaterial(\n            seed * RAND_CONST_8,\n            surfaceNormal,\n            direction,\n            diffusivity,\n            offset,\n            transmittance,\n            doRefraction,\n            refractiveIndex,\n            scatteringCoefficient,\n            transmissionRoughness,\n            specularity,\n            specularRoughness,\n            objectId,\n            isExitingObject(\n                nestedDielectrics\[numNestedDielectrics]\[OBJECT_ID] - 1,\n                objectId - 1\n            ),\n            materialBRDF,\n            bounceDirection,\n            origin,\n            nestedDielectrics,\n            numNestedDielectrics,\n            materialLightPDF\n        );\n\n        if (\n            __lightSamplingEnabled\n            && materialLightPDF > 0.0f\n            && numLights > 0\n        ) \{\n            // Perform MIS light sampling\n            rayColour += lightSampling(\n                seed * RAND_CONST_9,\n                throughput,\n                materialBRDF,\n                surfaceNormal,\n                origin,\n                materialLightPDF,\n                offset,\n                emissiveIndices,\n                numEmissive,\n                _sampleHDRI,\n                nestedDielectrics,\n                numNestedDielectrics\n            );\n        \}\n\n        if (_usePrecomputedIrradiance && materialLightPDF > 0.0f)\n        \{\n            emittance += diffusivity * diffusivity.w * readIrradianceValue(surfaceNormal);\n            usedPrecomputedIrradiance = true;\n        \}\n\n        // Perform MIS material sampling\n        const float radius = getRadius(objectId - 1);\n        const float visibleSurfaceArea = 2.0f * PI * radius * radius;\n\n        rayColour += multipleImportanceSample(\n            emittance,\n            throughput,\n            previousMaterialPDF,\n            sampleLightsPDF(numLights, visibleSurfaceArea)\n        );\n\n        float materialGeometryFactor = 1.0f;\n        if (materialLightPDF > 0.0f)\n        \{\n            materialGeometryFactor = saturate(dot(bounceDirection, surfaceNormal));\n        \}\n\n        throughput *= materialBRDF * materialGeometryFactor / materialPDF;\n\n        // Prepare the variables for the next march\n        previousMaterialPDF = materialPDF;\n\n        direction = bounceDirection;\n    \}\n\n\n    /**\n     * March a path through the scene.\n     *\n     * @arg rayOrigin: The origin of the ray.\n     * @arg rayDirection: The direction of the ray.\n     * @arg emissiveIndices: The indices of the emissive objects in the\n     *     scene.\n     * @arg numEmissive: The number of emissive objects in the scene.\n     * @arg seed: The seed to use in randomization.\n     *\n     * @returns: The ray colour.\n     */\n    float4 marchPath(\n            const float3 &rayOrigin,\n            const float3 &rayDirection,\n            const int emissiveIndices\[MAX_MIS_EMISSIVE_SHAPES],\n            const int numEmissive,\n            float3 &seed)\n    \{\n        const int numLights = _lightTextureWidth + numEmissive + _sampleHDRI;\n\n        float nestedDielectrics\[MAX_NESTED_DIELECTRICS]\[NESTED_DIELECTRIC_PARAMS];\n        nestedDielectrics\[0]\[EXTINCTION_X] = _extinctionCoefficient.x;\n        nestedDielectrics\[0]\[EXTINCTION_Y] = _extinctionCoefficient.y;\n        nestedDielectrics\[0]\[EXTINCTION_Z] = _extinctionCoefficient.z;\n        nestedDielectrics\[0]\[OBJECT_ID] = -1;\n        nestedDielectrics\[0]\[REFRACTIVE_INDEX] = _refractiveIndex;\n        nestedDielectrics\[0]\[SCATTERING_X] = _scatteringCoefficient.x;\n        nestedDielectrics\[0]\[SCATTERING_Y] = _scatteringCoefficient.y;\n        nestedDielectrics\[0]\[SCATTERING_Z] = _scatteringCoefficient.z;\n        nestedDielectrics\[0]\[DO_REFRACTION] = false;\n        int numNestedDielectrics = 0;\n\n        float4 rayColour = float4(0);\n        float4 throughput = float4(1);\n\n        float lastStepDistance = 1.0f;\n\n        float firstObjectId = 0.0f;\n\n        int iterations = 0;\n        int bounces = 0;\n\n        float distanceTravelled = 0;\n        float distanceSinceLastBounce = distanceTravelled;\n\n        // Get the next ray\n        float3 origin = rayOrigin;\n        float3 direction = rayDirection;\n        float3 positionOnRay = origin;\n\n        float4 diffusivity;\n        float4 specularity;\n        float4 transmittance;\n        float4 emittance;\n\n        float pixelFootprint = _hitTolerance;\n\n        float previousMaterialPDF = 1.0f;\n\n        bool usedPrecomputedIrradiance = false;\n\n        // March the ray\n        while (\n            distanceTravelled < _maxRayDistance\n            && iterations < _maxRaySteps\n            && sumComponent(throughput) > _hitTolerance\n            && length(rayColour) < _maxBrightness\n        ) \{\n            positionOnRay = origin + distanceSinceLastBounce * direction;\n\n            // Get the closest distance to an object\n            bool doRefraction = true;\n            float4 scatteringCoefficient = float4(0);\n            float specularRoughness = 0.0f;\n            float transmissionRoughness = 0.0f;\n            float refractiveIndex = 1.0f;\n            int objectId = 0;\n\n            // Keep the signed distance so we know whether or not we are\n            // inside the object\n            const float signedStepDistance = getMinDistanceToObjectInScene(\n                positionOnRay,\n                pixelFootprint,\n                diffusivity,\n                specularity,\n                transmittance,\n                emittance,\n                scatteringCoefficient,\n                specularRoughness,\n                transmissionRoughness,\n                refractiveIndex,\n                doRefraction,\n                objectId\n            );\n\n            // Get the absolute value, the true shortest distance to a\n            // surface\n            const float stepDistance = fabs(signedStepDistance);\n\n            // Keep track of the distance the ray has travelled\n            distanceTravelled += stepDistance;\n            distanceSinceLastBounce += stepDistance;\n\n            // Have we hit the nearest object?\n            if (stepDistance < pixelFootprint)\n            \{\n                float3 intersectionPosition = positionOnRay + stepDistance * direction;\n\n                // The normal to the surface at that position\n                float3 surfaceNormal = sign(lastStepDistance) * estimateSurfaceNormal(\n                    intersectionPosition,\n                    pixelFootprint\n                );\n\n                if (bounces == 0)\n                \{\n                    // Keep the ID of the first object hit, so we can\n                    // store it in the alpha channel\n                    firstObjectId = objectId;\n\n                    // Early exit for the various AOVs that are not 'beauty'\n                    if (_outputType > BEAUTY_AOV && _outputType < STATS_AOV)\n                    \{\n                        return earlyExitAOVs(\n                            _outputType,\n                            intersectionPosition,\n                            worldToLocal(firstObjectId - 1, intersectionPosition),\n                            surfaceNormal,\n                            fabs(matmul(\n                                _cameraWorldMatrix.invert(),\n                                float4(\n                                    intersectionPosition.x,\n                                    intersectionPosition.y,\n                                    intersectionPosition.z,\n                                    1.0f\n                                )\n                            )\[2]),\n                            firstObjectId\n                        );\n                    \}\n                \}\n\n                materialInteraction(\n                    stepDistance,\n                    pixelFootprint,\n                    distanceSinceLastBounce,\n                    intersectionPosition,\n                    surfaceNormal,\n                    objectId,\n                    emissiveIndices,\n                    numEmissive,\n                    doRefraction,\n                    numLights,\n                    seed,\n                    direction,\n                    origin,\n                    diffusivity,\n                    specularity,\n                    transmittance,\n                    emittance,\n                    specularRoughness,\n                    transmissionRoughness,\n                    refractiveIndex,\n                    scatteringCoefficient,\n                    nestedDielectrics,\n                    numNestedDielectrics,\n                    rayColour,\n                    throughput,\n                    previousMaterialPDF,\n                    usedPrecomputedIrradiance\n                );\n\n                // Exit if we have reached the bounce limit\n                // or with a random chance\n                const float rng = random(random(seed.x) + random(seed.y + random(seed.z)));\n                const float exitProbability = max(\n                    throughput.x,\n                    throughput.y,\n                    throughput.z\n                );\n                if (\n                    ++bounces > __bouncesPerRay\n                    || emittance.w >= 1.0f\n                    || usedPrecomputedIrradiance\n                    || (_roulette && exitProbability <= rng)\n                ) \{\n                    return finalAOVs(\n                        _outputType,\n                        iterations,\n                        bounces,\n                        firstObjectId,\n                        rayColour\n                    );\n                \}\n                if (_roulette)\n                \{\n                    // Account for the lost intensity from the early exits\n                    throughput /= exitProbability;\n                \}\n\n                // Update the random seed\n                seed = RAND_CONST_12 * random(\n                    seed\n                    + rng\n                    + random(fabs(intersectionPosition + direction))\n                );\n\n                distanceSinceLastBounce = 0.0f;\n\n                // Reset the pixel footprint so multiple reflections don't\n                // reduce precision\n                pixelFootprint = _hitTolerance;\n            \}\n            else if (_levelOfDetail)\n            \{\n                pixelFootprint += _hitTolerance * stepDistance;\n            \}\n\n            lastStepDistance = signedStepDistance;\n            iterations++;\n        \}\n\n        // If we are not computing the scene value and we have missed all\n        // objects, return an appropriate colour.\n        if (_outputType > BEAUTY_AOV)\n        \{\n            return rayMissAOVs(\n                _outputType,\n                iterations,\n                bounces,\n                firstObjectId\n            );\n        \}\n\n        const float correctedDistance = (\n            distanceSinceLastBounce\n            + _maxRayDistance\n            - distanceTravelled\n        );\n\n        // Perform Equi-Angular Sampling\n        rayColour += sampleEquiangular(\n            seed,\n            origin + correctedDistance * direction,\n            origin,\n            direction,\n            correctedDistance,\n            emissiveIndices,\n            numEmissive,\n            nestedDielectrics,\n            numNestedDielectrics,\n            throughput\n        );\n\n        // Read the hdri value in the direction the ray was last travelling\n        rayColour += throughput * readHDRIValue(direction);\n\n        rayColour.w = (bounces > 0) * firstObjectId;\n        return rayColour;\n    \}\n\n\n    /**\n     * Get the indices of all the emissive objects in the scene.\n     *\n     * @arg emissiveIndices: The array to store the indices in.\n     *\n     * @returns: The total number of emissive objects found.\n     */\n    int getEmissiveIndices(int emissiveIndices\[MAX_MIS_EMISSIVE_SHAPES])\n    \{\n        int currentIndex = 0;\n        for (int j=0; j < min(_objectTextureWidth, MAX_MIS_EMISSIVE_SHAPES); j++)\n        \{\n            if (emittances(j, 0, 3) > 0.0f)\n            \{\n                emissiveIndices\[currentIndex++] = j;\n            \}\n        \}\n\n        return currentIndex;\n    \}\n\n\n    /**\n     * Create a ray out of the camera. It will be either a standard ray,\n     * a latlong ray, or a ray that will result in depth of field.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg pixelLocation: The x, and y locations of the pixel.\n     * @arg rayOrigin: The location to store the origin of the new ray.\n     * @arg rayDirection: The location to store the direction of the new\n     *     ray.\n     */\n    void getCameraRay(\n            const float3 &seed,\n            const float2 &pixelLocation,\n            float3 &rayOrigin,\n            float3 &rayDirection)\n    \{\n        const float2 uvCoordinates = pixelsToUV(\n            pixelLocation + random(float2(seed.x, seed.y)),\n            float2(_formatWidth, _formatHeight)\n        );\n        if (_latLong)\n        \{\n            createLatLongCameraRay(\n                _cameraWorldMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else if (_depthOfFieldEnabled)\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                __aperture,\n                _focalDistance,\n                seed,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n    \}\n\n\n    /**\n     * Compute a raymarched pixel value.\n     *\n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        SampleType(noise) noisePixel = noise();\n        float3 seed = random(float3(noisePixel.x, noisePixel.y, noisePixel.z));\n\n        const float4 variancePixel = variance();\n\n        const float numPaths = adaptiveSamples(\n            _minPathsPerPixel,\n            _maxPathsPerPixel,\n            float3(variancePixel.x, variancePixel.y, variancePixel.z)\n        );\n        const float numPrecomputedPaths = variancePixel.w;\n        const float totalPaths = numPaths + numPrecomputedPaths;\n\n        float4 resultPixel = float4(0);\n\n        float2 pixelLocation = float2(pos.x, pos.y);\n\n        int emissiveMISOptions\[MAX_MIS_EMISSIVE_SHAPES];\n\n        const int numEmissive = getEmissiveIndices(emissiveMISOptions);\n\n        for (int path=1; path <= numPaths; path++)\n        \{\n            // Generate a ray from the camera\n            float3 rayOrigin;\n            float3 rayDirection;\n            getCameraRay(\n                seed,\n                pixelLocation,\n                rayOrigin,\n                rayDirection\n            );\n\n            // Determine the colour of the ray\n            resultPixel += marchPath(\n                rayOrigin,\n                rayDirection,\n                emissiveMISOptions,\n                numEmissive,\n                seed\n            ) / totalPaths;\n\n            seed = RAND_CONST_10 * random(seed * path * RAND_CONST_11);\n        \}\n\n        const uint objectId = resultPixel.w / totalPaths;\n\n        dst() = resultPixel + numPrecomputedPaths * src() / totalPaths;\n\n        if (_outputType == STATS_AOV)\n        \{\n            dst(2) = totalPaths;\n        \}\n\n        dst(3) = encodeTwoValuesInUint(objectId, totalPaths);\n    \}\n\};\n"
  rebuild ""
  "RayMarchKernel_Focal Length" {{parent.DummyCam.focal}}
  "RayMarchKernel_Horizontal Aperture" {{parent.DummyCam.haperture}}
  "RayMarchKernel_Near Plane" {{parent.DummyCam.near}}
  "RayMarchKernel_Far Plane" {{parent.DummyCam.far}}
  "RayMarchKernel_Camera World Matrix" {
      {{parent.DummyCam.world_matrix.0} {parent.DummyCam.world_matrix.1} {parent.DummyCam.world_matrix.2} {parent.DummyCam.world_matrix.3}}
      {{parent.DummyCam.world_matrix.4} {parent.DummyCam.world_matrix.5} {parent.DummyCam.world_matrix.6} {parent.DummyCam.world_matrix.7}}
      {{parent.DummyCam.world_matrix.8} {parent.DummyCam.world_matrix.9} {parent.DummyCam.world_matrix.10} {parent.DummyCam.world_matrix.11}}
      {{parent.DummyCam.world_matrix.12} {parent.DummyCam.world_matrix.13} {parent.DummyCam.world_matrix.14} {parent.DummyCam.world_matrix.15}}
    }
  "RayMarchKernel_Focal Distance" {{parent.DummyCam.focal_point}}
  RayMarchKernel_fstop {{parent.DummyCam.fstop}}
  "RayMarchKernel_Enable Depth Of Field" {{parent.enable_dof}}
  "RayMarchKernel_Screen Width" {{parent.resolution_dot.width}}
  "RayMarchKernel_Screen Height" {{parent.resolution_dot.height}}
  "RayMarchKernel_HDRI Offset Angle" {{parent.hdri_offset_angle}}
  "RayMarchKernel_Use Precomputed Irradiance" {{parent.use_precomputed_irradiance}}
  "RayMarchKernel_Min Paths Per Pixel" {{parent.min_paths_per_pixel}}
  "RayMarchKernel_Max Paths Per Pixel" {{parent.max_paths_per_pixel}}
  RayMarchKernel_Roulette {{parent.roulette}}
  "RayMarchKernel_Max Bounces" {{parent.max_bounces}}
  "RayMarchKernel_Max Light Sampling Bounces" {{parent.max_light_sampling_bounces}}
  "RayMarchKernel_Sample HDRI" {{parent.sample_hdri}}
  "RayMarchKernel_Sample All Lights" {{parent.sample_all_lights}}
  "RayMarchKernel_Secondary Light Sampling" {{parent.secondary_sampling}}
  "RayMarchKernel_Light Sampling Bias" {{parent.light_sampling_bias}}
  "RayMarchKernel_Max Ray Distance" {{parent.ray_distance}}
  "RayMarchKernel_Max Ray Steps" {{parent.max_ray_steps}}
  "RayMarchKernel_Level of Detail" {{parent.level_of_detail}}
  "RayMarchKernel_Hit Tolerance" {{parent.hit_tolerance}}
  "RayMarchKernel_Shadow Bias" {{parent.shadow_bias}}
  "RayMarchKernel_Maximum Brightness" {{parent.max_brightness}}
  "RayMarchKernel_Index of Refraction" {{parent.refractive_index}}
  "RayMarchKernel_Scattering Coefficient" {{"parent.scattering_colour * parent.scattering_coefficient"} {"parent.scattering_colour * parent.scattering_coefficient"} {"parent.scattering_colour * parent.scattering_coefficient"} 0}
  "RayMarchKernel_Extinction Coefficient" {{"(1 - clamp(parent.extinction_colour.r, 0, 1)) * parent.extinction_coefficient"} {"(1 - clamp(parent.extinction_colour.g, 0, 1)) * parent.extinction_coefficient"} {"(1 - clamp(parent.extinction_colour.b, 0, 1)) * parent.extinction_coefficient"} 0}
  "RayMarchKernel_Equi-Angular Samples" {{parent.equiangular_samples}}
  "RayMarchKernel_Sample HDRI Equi-Angular" {{parent.sample_hdri_equiangular}}
  "RayMarchKernel_Object Texture Width" {{"parent.object_input_protection.disable ? parent.obj_dot.width : parent.scene.width == 1 ? 1 : 0"}}
  "RayMarchKernel_Light Texture Width" {{"parent.light_input_protection.disable ? parent.light_dot.width : parent.lights.width == 1 ? 1 : 0"}}
  "RayMarchKernel_Output Type" {{parent.output_type}}
  "RayMarchKernel_Output LatLong" {{parent.latlong}}
  rebuild_finalise ""
  name BlinkPathMarcher
  xpos 1610
  ypos -472
 }
 Reformat {
  format {{{parent.format_.format}}}
  name Reformat1
  xpos 1610
  ypos -434
 }
 Expression {
  expr0 "isnan(r) ? 0 : (isinf(r) ? parent.max_brightness : clamp(r, 0, parent.max_brightness))"
  expr1 "isnan(g) ? 0 : (isinf(g) ? parent.max_brightness : clamp(g, 0, parent.max_brightness))"
  expr2 "isnan(b) ? 0 : (isinf(b) ? parent.max_brightness : clamp(b, 0, parent.max_brightness))"
  name Expression2
  xpos 1610
  ypos -408
 }
 Dot {
  name Dot11
  xpos 1644
  ypos -270
 }
set N1af54c50 [stack 0]
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/kernels/decode_alpha.blink
  recompileCount 3
  ProgramGroup 1
  KernelDescription "2 \"DecodeAlpha\" iterate pixelWise 1c4995e5ef3c4395ca22dae32e63f03d3c8b0eb4c438ef32fcb399691563ff7d 2 \"src\" Read Point \"dst\" Write Point 0 0 0"
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n#include \"conversion.h\"\n\n\nkernel DecodeAlpha : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessPoint, eEdgeNone> src; // the input image\n    Image<eWrite> dst; // the output image\n\n\n    /**\n     * Decode the multiple values stored in the alpha channel.\n     */\n    void process()\n    \{\n        SampleType(src) srcPixel = src();\n\n        const int2 decoded = decodeTwoValuesFromUint(srcPixel.w);\n        dst() = float4(decoded.x, decoded.y, 0, 0);\n    \}\n\};\n"
  rebuild ""
  rebuild_finalise ""
  name BlinkScript1
  xpos 1610
  ypos -40
 }
set N1af59aa0 [stack 0]
push $N1af54c50
 Dot {
  name Dot8
  xpos 1754
  ypos -270
 }
 ShuffleCopy {
  inputs 2
  in2 rgb
  alpha red
  green2 green2
  name ShuffleCopy2
  xpos 1720
  ypos -34
 }
push $N1af54c50
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/kernels/variance.blink
  recompileCount 18
  KernelDescription "2 \"Variance\" iterate pixelWise 9ffe5cb17cce3fe6b29c96cc653303e51591ce19298e8dbdc053847856d3fddc 2 \"src\" Read Ranged2D \"dst\" Write Point 1 \"Range\" Float 2 AABAQAAAQEA= 1 \"_range\" 2 1 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"__numSamples\" Float 1 1 AAAAAA=="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n#include \"math.h\"\n\n\nkernel Variance : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessRanged2D, eEdgeClamped> src; // the input image\n    Image<eWrite> dst; // the output image\n\n    param:\n        float2 _range;\n\n    local:\n        float __numSamples;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        defineParam(_range, \"Range\", float2(3, 3));\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        src.setRange(-_range.x, -_range.y, _range.x, _range.y);\n\n        __numSamples = (2.0f * _range.x + 1.0f) * (2.0f * _range.y + 1.0f);\n    \}\n\n\n    /**\n     * Compute the variance of a pixel.\n     * \n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        float4 mean = float4(0);\n        for (int yOffset=-_range.y; yOffset <= _range.y; yOffset++)\n        \{\n            for (int xOffset=-_range.x; xOffset <= _range.x; xOffset++)\n            \{\n                mean += src(xOffset, yOffset) / __numSamples;\n            \}\n        \}\n\n        float4 sumOfSquares = float4(0);\n        for (int yOffset=-_range.y; yOffset <= _range.y; yOffset++)\n        \{\n            for (int xOffset=-_range.x; xOffset <= _range.x; xOffset++)\n            \{\n                const float4 sample = src(xOffset, yOffset);\n\n                const float4 deviation = src(xOffset, yOffset) - mean;\n\n                sumOfSquares += deviation * deviation / (__numSamples - 1.0f);\n            \}\n        \}\n\n        dst() = sumOfSquares;\n    \}\n\};\n"
  rebuild ""
  Variance_Range {{parent.variance_range} {parent.variance_range}}
  rebuild_finalise ""
  name BlinkScript2
  xpos 1500
  ypos -280
 }
 Dot {
  name Dot17
  xpos 1534
  ypos -222
 }
set N1f286d80 [stack 0]
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/kernels/minMax.blink
  recompileCount 8
  KernelDescription "2 \"MinMaxMeanDeviation\" iterate pixelWise d658e53ec264cb72124ab1c5eeaddc8daaefd311b02e7e408e47a126f7c2db06 2 \"src\" Read Random \"dst\" Write Point 1 \"Inclusive Range\" Float 1 80/DRw== 1 \"_maximum\" 1 1 1 \"__numSamples\" Float 1 1 AAAAAA=="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n#include \"math.h\"\n\n\nkernel MinMaxMeanDeviation : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessRandom, eEdgeNone> src; // the input image\n    Image<eWrite> dst; // the output image\n\n    param:\n        float _maximum;\n\n    local:\n        float __numSamples;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        defineParam(_maximum, \"Inclusive Range\", 99999.9f);\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        __numSamples = 3.0f * src.bounds.width() * src.bounds.height();\n    \}\n\n\n    /**\n     * Compute the min max and standard deviation of the image.\n     *\n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        if (length(float2(pos.x, pos.y)) > 0)\n        \{\n            dst() = 0;\n            return;\n        \}\n\n        float minValue = FLT_MAX;\n        float maxValue = 0.0f;\n        float mean = 0.0f;\n\n        for (int y=src.bounds.y1; y < src.bounds.y2; y++)\n        \{\n            for (int x=src.bounds.x1; x < src.bounds.x2; x++)\n            \{\n                const float3 pixelValue = float3(\n                    src(x, y, 0),\n                    src(x, y, 1),\n                    src(x, y, 2)\n                );\n\n                minValue = min(minValue, minComponent(pixelValue));\n                maxValue = max(maxValue, maxComponent(pixelValue));\n\n                mean += sumComponent(pixelValue) / __numSamples;\n            \}\n        \}\n\n        float standardDeviation = 0.0f;\n\n        for (int y=src.bounds.y1; y < src.bounds.y2; y++)\n        \{\n            for (int x=src.bounds.x1; x < src.bounds.x2; x++)\n            \{\n                const float3 pixelValue = float3(\n                    src(x, y, 0),\n                    src(x, y, 1),\n                    src(x, y, 2)\n                );\n\n                const float deviation = sumComponent(fabs(pixelValue - mean));\n\n                standardDeviation += min(deviation * deviation, _maximum) / __numSamples;\n            \}\n        \}\n\n        dst() = float4(minValue, maxValue, mean, sqrt(standardDeviation));\n    \}\n\};\n"
  rebuild ""
  "MinMaxMeanDeviation_Inclusive Range" 99999.99
  rebuild_finalise ""
  name BlinkScript3
  xpos 1390
  ypos -232
 }
 Dot {
  name Dot29
  xpos 1424
  ypos -150
 }
push $N1f286d80
 BlinkScript {
  inputs 2
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/kernels/normalize.blink
  recompileCount 11
  KernelDescription "2 \"Normalize\" iterate pixelWise 5a966d373c338a72f091ff982ef82b54a18f6a1983de644d989df8ef81655617 3 \"src\" Read Point \"minMax\" Read Random \"dst\" Write Point 2 \"Normalization Method\" Int 1 AAAAAA== \"Clamp To Standard Deviation\" Bool 1 AA== 2 \"_normalizationMethod\" 1 1 \"_clampToStdDev\" 1 1 1 \"minMaxconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n#include \"math.h\"\n\n\nkernel Normalize : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessPoint, eEdgeNone> src; // the input image\n    Image<eRead, eAccessRandom, eEdgeConstant> minMax; // the input image\n    Image<eWrite> dst; // the output image\n\n\n    param:\n        int _normalizationMethod;\n        bool _clampToStdDev;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        defineParam(_normalizationMethod, \"Normalization Method\", 0);\n        defineParam(_clampToStdDev, \"Clamp To Standard Deviation\", false);\n    \}\n\n\n    /**\n     * The normalized values.\n     */\n    void process()\n    \{\n        float minValue = minMax(0, 0, 0);\n        float maxValue = minMax(0, 0, 1);\n        const float meanValue = minMax(0, 0, 2);\n        const float standardDeviationValue = minMax(0, 0, 3);\n\n        float4 srcValue;\n        if (_clampToStdDev)\n        \{\n            const float lowerBound = meanValue - standardDeviationValue;\n            const float upperBound = meanValue + standardDeviationValue;\n\n            srcValue = clamp(src(), lowerBound, upperBound);\n            minValue = clamp(minValue, lowerBound, upperBound);\n            maxValue = clamp(maxValue, lowerBound, upperBound);\n        \}\n        else\n        \{\n            srcValue = src();\n        \}\n\n        float4 output;\n\n        if (_normalizationMethod == 0 && minValue != maxValue)\n        \{\n            dst() = (srcValue - minValue) / (maxValue - minValue);\n        \}\n        else if (_normalizationMethod == 1 && standardDeviationValue != 0.0f)\n        \{\n            dst() = (srcValue - meanValue) / standardDeviationValue;\n        \}\n        else\n        \{\n            dst() = 0.0f;\n        \}\n    \}\n\};\n"
  rebuild ""
  "Normalize_Normalization Method" 1
  rebuild_finalise ""
  name BlinkScript4
  xpos 1500
  ypos -160
 }
 Dot {
  name Dot31
  xpos 1534
  ypos -102
 }
set N149f0c40 [stack 0]
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/kernels/minMax.blink
  recompileCount 8
  KernelDescription "2 \"MinMaxMeanDeviation\" iterate pixelWise d658e53ec264cb72124ab1c5eeaddc8daaefd311b02e7e408e47a126f7c2db06 2 \"src\" Read Random \"dst\" Write Point 1 \"Inclusive Range\" Float 1 80/DRw== 1 \"_maximum\" 1 1 1 \"__numSamples\" Float 1 1 AAAAAA=="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n#include \"math.h\"\n\n\nkernel MinMaxMeanDeviation : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessRandom, eEdgeNone> src; // the input image\n    Image<eWrite> dst; // the output image\n\n    param:\n        float _maximum;\n\n    local:\n        float __numSamples;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        defineParam(_maximum, \"Inclusive Range\", 99999.9f);\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        __numSamples = 3.0f * src.bounds.width() * src.bounds.height();\n    \}\n\n\n    /**\n     * Compute the min max and standard deviation of the image.\n     *\n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        if (length(float2(pos.x, pos.y)) > 0)\n        \{\n            dst() = 0;\n            return;\n        \}\n\n        float minValue = FLT_MAX;\n        float maxValue = 0.0f;\n        float mean = 0.0f;\n\n        for (int y=src.bounds.y1; y < src.bounds.y2; y++)\n        \{\n            for (int x=src.bounds.x1; x < src.bounds.x2; x++)\n            \{\n                const float3 pixelValue = float3(\n                    src(x, y, 0),\n                    src(x, y, 1),\n                    src(x, y, 2)\n                );\n\n                minValue = min(minValue, minComponent(pixelValue));\n                maxValue = max(maxValue, maxComponent(pixelValue));\n\n                mean += sumComponent(pixelValue) / __numSamples;\n            \}\n        \}\n\n        float standardDeviation = 0.0f;\n\n        for (int y=src.bounds.y1; y < src.bounds.y2; y++)\n        \{\n            for (int x=src.bounds.x1; x < src.bounds.x2; x++)\n            \{\n                const float3 pixelValue = float3(\n                    src(x, y, 0),\n                    src(x, y, 1),\n                    src(x, y, 2)\n                );\n\n                const float deviation = sumComponent(fabs(pixelValue - mean));\n\n                standardDeviation += min(deviation * deviation, _maximum) / __numSamples;\n            \}\n        \}\n\n        dst() = float4(minValue, maxValue, mean, sqrt(standardDeviation));\n    \}\n\};\n"
  rebuild ""
  "MinMaxMeanDeviation_Inclusive Range" 99999.99
  rebuild_finalise ""
  name BlinkScript5
  xpos 1390
  ypos -112
 }
 Dot {
  name Dot32
  xpos 1424
  ypos -30
 }
push $N149f0c40
 BlinkScript {
  inputs 2
  kernelSourceFile /home/ob1/software/nuke/dev/raymarch/src/blink/kernels/normalize.blink
  recompileCount 10
  KernelDescription "2 \"Normalize\" iterate pixelWise 5a966d373c338a72f091ff982ef82b54a18f6a1983de644d989df8ef81655617 3 \"src\" Read Point \"minMax\" Read Random \"dst\" Write Point 2 \"Normalization Method\" Int 1 AAAAAA== \"Clamp To Standard Deviation\" Bool 1 AA== 2 \"_normalizationMethod\" 1 1 \"_clampToStdDev\" 1 1 1 \"minMaxconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n#include \"math.h\"\n\n\nkernel Normalize : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessPoint, eEdgeNone> src; // the input image\n    Image<eRead, eAccessRandom, eEdgeConstant> minMax; // the input image\n    Image<eWrite> dst; // the output image\n\n\n    param:\n        int _normalizationMethod;\n        bool _clampToStdDev;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        defineParam(_normalizationMethod, \"Normalization Method\", 0);\n        defineParam(_clampToStdDev, \"Clamp To Standard Deviation\", false);\n    \}\n\n\n    /**\n     * The normalized values.\n     */\n    void process()\n    \{\n        float minValue = minMax(0, 0, 0);\n        float maxValue = minMax(0, 0, 1);\n        const float meanValue = minMax(0, 0, 2);\n        const float standardDeviationValue = minMax(0, 0, 3);\n\n        float4 srcValue;\n        if (_clampToStdDev)\n        \{\n            const float lowerBound = meanValue - standardDeviationValue;\n            const float upperBound = meanValue + standardDeviationValue;\n\n            srcValue = clamp(src(), lowerBound, upperBound);\n            minValue = clamp(minValue, lowerBound, upperBound);\n            maxValue = clamp(maxValue, lowerBound, upperBound);\n        \}\n        else\n        \{\n            srcValue = src();\n        \}\n\n        float4 output;\n\n        if (_normalizationMethod == 0 && minValue != maxValue)\n        \{\n            dst() = (srcValue - minValue) / (maxValue - minValue);\n        \}\n        else if (_normalizationMethod == 1 && standardDeviationValue != 0.0f)\n        \{\n            dst() = (srcValue - meanValue) / standardDeviationValue;\n        \}\n        else\n        \{\n            dst() = 0.0f;\n        \}\n    \}\n\};\n"
  rebuild ""
  "Normalize_Clamp To Standard Deviation" true
  rebuild_finalise ""
  name BlinkScript6
  xpos 1500
  ypos -40
 }
 Dot {
  name Dot30
  xpos 1534
  ypos 90
 }
push $N1af59aa0
 ShuffleCopy {
  inputs 2
  in rgb
  in2 rgb
  red red
  green green
  blue blue
  alpha green2
  black red
  white green
  red2 blue
  green2 green2
  out variance
  name ShuffleCopy1
  xpos 1610
  ypos 86
 }
 Copy {
  inputs 2
  channels all
  name Copy1
  xpos 1720
  ypos 74
 }
 Output {
  name Output1
  xpos 1720
  ypos 182
 }
end_group
